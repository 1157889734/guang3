; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\drvuart.o --asm_dir=..\list\ --list_dir=..\list\ --depend=..\output\drvuart.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\inc -I..\..\ISD91XX_SDK\CMSIS\CM0\CoreSupport -I..\..\ISD91XX_SDK\CMSIS\CM0\DeviceSupport\Nuvoton\ISD91xx -I..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Include\Driver -I..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Include -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Nuvoton --omf_browse=..\output\drvuart.crf ..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Src\Driver\DrvUART.c]
                          THUMB

                          AREA ||i.DrvUART_BaudRateCalculator||, CODE, READONLY, ALIGN=2

                  DrvUART_BaudRateCalculator PROC
;;;62     /*---------------------------------------------------------------------------------------------------------*/
;;;63     void DrvUART_BaudRateCalculator(uint32_t i32clk, uint32_t i32baudRate, UART_BAUD_T *baud)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;64     {
000002  b082              SUB      sp,sp,#8
000004  4607              MOV      r7,r0
000006  4614              MOV      r4,r2
;;;65       	int32_t i32tmp;
;;;66     	int32_t i32div;
;;;67     
;;;68     	if(((i32clk / i32baudRate)%16)<3)	      /* Source Clock mod 16 <3 => Using Divider X =16 (MODE#0) */
000008  4638              MOV      r0,r7
00000a  9903              LDR      r1,[sp,#0xc]
00000c  f7fffffe          BL       __aeabi_uidivmod
000010  0700              LSLS     r0,r0,#28
000012  0f00              LSRS     r0,r0,#28
000014  2803              CMP      r0,#3
000016  d20f              BCS      |L1.56|
;;;69     	{
;;;70     		baud->DIVX_EN = 0;
000018  6820              LDR      r0,[r4,#0]
00001a  2101              MOVS     r1,#1
00001c  0749              LSLS     r1,r1,#29
00001e  4388              BICS     r0,r0,r1
000020  6020              STR      r0,[r4,#0]
;;;71     	    baud->DIVX_ONE   = 0;
000022  6820              LDR      r0,[r4,#0]
000024  1049              ASRS     r1,r1,#1
000026  4388              BICS     r0,r0,r1
000028  6020              STR      r0,[r4,#0]
;;;72     		i32tmp = i32clk / i32baudRate/16  -2;
00002a  4638              MOV      r0,r7
00002c  9903              LDR      r1,[sp,#0xc]
00002e  f7fffffe          BL       __aeabi_uidivmod
000032  0900              LSRS     r0,r0,#4
000034  1e86              SUBS     r6,r0,#2
000036  e03b              B        |L1.176|
                  |L1.56|
;;;73     	}
;;;74     	else							  /* Source Clock mod 16 >3 => Up 5% Error BaudRate */
;;;75     	{
;;;76     	    baud->DIVX_EN = 1;			  /* Try to Set Divider X = 1 (MODE#2)*/
000038  6820              LDR      r0,[r4,#0]
00003a  2101              MOVS     r1,#1
00003c  0749              LSLS     r1,r1,#29
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  6020              STR      r0,[r4,#0]
;;;77     	    baud->DIVX_ONE   = 1;
000044  6820              LDR      r0,[r4,#0]
000046  1049              ASRS     r1,r1,#1
000048  4388              BICS     r0,r0,r1
00004a  1840              ADDS     r0,r0,r1
00004c  6020              STR      r0,[r4,#0]
;;;78     		i32tmp = i32clk / i32baudRate  -2;
00004e  4638              MOV      r0,r7
000050  9903              LDR      r1,[sp,#0xc]
000052  f7fffffe          BL       __aeabi_uidivmod
000056  1e86              SUBS     r6,r0,#2
;;;79     
;;;80     		if(i32tmp > 0xFFFF)			  /* If Divider > Range  */
000058  4819              LDR      r0,|L1.192|
00005a  4286              CMP      r6,r0
00005c  dd28              BLE      |L1.176|
;;;81     		{
;;;82     			baud->DIVX_ONE = 0;		  /* Try to Set Divider X up 10 (MODE#1) */
00005e  6820              LDR      r0,[r4,#0]
000060  2101              MOVS     r1,#1
000062  0709              LSLS     r1,r1,#28
000064  4388              BICS     r0,r0,r1
000066  6020              STR      r0,[r4,#0]
;;;83     
;;;84     			for(i32div = 8; i32div <16;i32div++)
000068  2508              MOVS     r5,#8
00006a  e01e              B        |L1.170|
                  |L1.108|
;;;85     			{
;;;86     				if(((i32clk / i32baudRate)%(i32div+1))<3)
00006c  4638              MOV      r0,r7
00006e  9903              LDR      r1,[sp,#0xc]
000070  f7fffffe          BL       __aeabi_uidivmod
000074  1c69              ADDS     r1,r5,#1
000076  9001              STR      r0,[sp,#4]
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  2903              CMP      r1,#3
00007e  d213              BCS      |L1.168|
;;;87     				{
;;;88     					baud->DIVX   = i32div;
000080  6820              LDR      r0,[r4,#0]
000082  210f              MOVS     r1,#0xf
000084  0609              LSLS     r1,r1,#24
000086  4388              BICS     r0,r0,r1
000088  0629              LSLS     r1,r5,#24
00008a  220f              MOVS     r2,#0xf
00008c  0612              LSLS     r2,r2,#24
00008e  4011              ANDS     r1,r1,r2
000090  4308              ORRS     r0,r0,r1
000092  6020              STR      r0,[r4,#0]
;;;89     					i32tmp = i32clk / i32baudRate / (i32div+1) -2;
000094  4638              MOV      r0,r7
000096  9903              LDR      r1,[sp,#0xc]
000098  f7fffffe          BL       __aeabi_uidivmod
00009c  1c69              ADDS     r1,r5,#1
00009e  9001              STR      r0,[sp,#4]
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  1e86              SUBS     r6,r0,#2
;;;90     					break;
0000a6  e002              B        |L1.174|
                  |L1.168|
0000a8  1c6d              ADDS     r5,r5,#1              ;84
                  |L1.170|
0000aa  2d10              CMP      r5,#0x10              ;84
0000ac  dbde              BLT      |L1.108|
                  |L1.174|
0000ae  bf00              NOP      
                  |L1.176|
;;;91     				}
;;;92     			}
;;;93     		}
;;;94     	}
;;;95     
;;;96     	baud->BRD = i32tmp;
0000b0  6820              LDR      r0,[r4,#0]
0000b2  0c00              LSRS     r0,r0,#16
0000b4  0400              LSLS     r0,r0,#16
0000b6  b2b1              UXTH     r1,r6
0000b8  4308              ORRS     r0,r0,r1
0000ba  6020              STR      r0,[r4,#0]
;;;97     
;;;98     }
0000bc  b005              ADD      sp,sp,#0x14
0000be  bdf0              POP      {r4-r7,pc}
;;;99     
                          ENDP

                  |L1.192|
                          DCD      0x0000ffff

                          AREA ||i.DrvUART_ClearInt||, CODE, READONLY, ALIGN=2

                  DrvUART_ClearInt PROC
;;;425    /*---------------------------------------------------------------------------------------------------------*/
;;;426    uint32_t DrvUART_ClearInt(UART_PORT	u16Port,uint32_t u32InterruptFlag)
000000  b510              PUSH     {r4,lr}
;;;427    {
000002  4602              MOV      r2,r0
;;;428    	if((u32InterruptFlag & DRVUART_RDAINT) == DRVUART_RDAINT)    			/* clear Rx read Interrupt */
000004  07c8              LSLS     r0,r1,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L2.18|
;;;429    		inpw(&UART0->DATA + u16Port);
00000c  4813              LDR      r0,|L2.92|
00000e  1810              ADDS     r0,r2,r0
000010  6800              LDR      r0,[r0,#0]
                  |L2.18|
;;;430    
;;;431    	if((u32InterruptFlag & DRVUART_RLSNT) == DRVUART_RLSNT)					/* clear Receive Line Status Interrupt */
000012  2004              MOVS     r0,#4
000014  4008              ANDS     r0,r0,r1
000016  2804              CMP      r0,#4
000018  d109              BNE      |L2.46|
;;;432    		outpw(&UART0->FSR + u16Port , inpw(&UART0->FSR + u16Port) | 0x70);
00001a  4810              LDR      r0,|L2.92|
00001c  3018              ADDS     r0,r0,#0x18
00001e  0093              LSLS     r3,r2,#2
000020  58c0              LDR      r0,[r0,r3]
000022  2370              MOVS     r3,#0x70
000024  4318              ORRS     r0,r0,r3
000026  4b0d              LDR      r3,|L2.92|
000028  3318              ADDS     r3,r3,#0x18
00002a  0094              LSLS     r4,r2,#2
00002c  5118              STR      r0,[r3,r4]
                  |L2.46|
;;;433    
;;;434    	if((u32InterruptFlag & DRVUART_MOSINT) == DRVUART_MOSINT)				/* clear Modem Interrupt */
00002e  2008              MOVS     r0,#8
000030  4008              ANDS     r0,r0,r1
000032  2808              CMP      r0,#8
000034  d109              BNE      |L2.74|
;;;435    		outpw(&UART0->MSR + u16Port,inpw(&UART0->MSR + u16Port) | 0x1);
000036  4809              LDR      r0,|L2.92|
000038  3014              ADDS     r0,r0,#0x14
00003a  0093              LSLS     r3,r2,#2
00003c  58c0              LDR      r0,[r0,r3]
00003e  2301              MOVS     r3,#1
000040  4318              ORRS     r0,r0,r3
000042  4b06              LDR      r3,|L2.92|
000044  3314              ADDS     r3,r3,#0x14
000046  0094              LSLS     r4,r2,#2
000048  5118              STR      r0,[r3,r4]
                  |L2.74|
;;;436    
;;;437    	if((u32InterruptFlag & DRVUART_TOUTINT) == DRVUART_TOUTINT)				/* clear Time-out Interrupt */
00004a  2010              MOVS     r0,#0x10
00004c  4008              ANDS     r0,r0,r1
00004e  2810              CMP      r0,#0x10
000050  d102              BNE      |L2.88|
;;;438    	{
;;;439    		inpw(&UART0->DATA + u16Port);
000052  4802              LDR      r0,|L2.92|
000054  1810              ADDS     r0,r2,r0
000056  6800              LDR      r0,[r0,#0]
                  |L2.88|
;;;440    	}
;;;441    
;;;442    	return E_SUCCESS;
000058  2000              MOVS     r0,#0
;;;443    
;;;444    
;;;445    }
00005a  bd10              POP      {r4,pc}
;;;446    
                          ENDP

                  |L2.92|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Close||, CODE, READONLY, ALIGN=2

                  DrvUART_Close PROC
;;;286    
;;;287    void DrvUART_Close(UART_PORT u16Port)
000000  b510              PUSH     {r4,lr}
;;;288    {
000002  4604              MOV      r4,r0
;;;289    	if(u16Port == UART_PORT0)
000004  2c00              CMP      r4,#0
000006  d112              BNE      |L3.46|
;;;290    	{
;;;291    		while(!UART0->FSR.TX_EMPTY);
000008  bf00              NOP      
                  |L3.10|
00000a  4809              LDR      r0,|L3.48|
00000c  6980              LDR      r0,[r0,#0x18]
00000e  0240              LSLS     r0,r0,#9
000010  0fc0              LSRS     r0,r0,#31
000012  d0fa              BEQ      |L3.10|
;;;292    		SYSCLK->APBCLK.UART0_EN = 0;
000014  4807              LDR      r0,|L3.52|
000016  6880              LDR      r0,[r0,#8]
000018  2101              MOVS     r1,#1
00001a  0409              LSLS     r1,r1,#16
00001c  4388              BICS     r0,r0,r1
00001e  4905              LDR      r1,|L3.52|
000020  6088              STR      r0,[r1,#8]
;;;293    		g_pfnUART0callback = NULL;
000022  2000              MOVS     r0,#0
000024  4904              LDR      r1,|L3.56|
000026  6008              STR      r0,[r1,#0]  ; g_pfnUART0callback
;;;294            NVIC_DisableIRQ(UART0_IRQn);
000028  200c              MOVS     r0,#0xc
00002a  f7fffffe          BL       NVIC_DisableIRQ
                  |L3.46|
;;;295    	}
;;;296    }
00002e  bd10              POP      {r4,pc}
;;;297    
                          ENDP

                  |L3.48|
                          DCD      0x40050000
                  |L3.52|
                          DCD      0x50000200
                  |L3.56|
                          DCD      g_pfnUART0callback

                          AREA ||i.DrvUART_DisableInt||, CODE, READONLY, ALIGN=2

                  DrvUART_DisableInt PROC
;;;387    /*---------------------------------------------------------------------------------------------------------*/
;;;388    void DrvUART_DisableInt(UART_PORT u16Port,uint32_t u32InterruptFlag)
000000  b570              PUSH     {r4-r6,lr}
;;;389    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;390    	if(u16Port == UART_PORT0)
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L4.24|
;;;391    	{
;;;392    		outpw(&UART0->IER + u16Port,inpw(&UART0->IER + u16Port) &~u32InterruptFlag);	   /* Disable INT  */
00000a  480f              LDR      r0,|L4.72|
00000c  00a1              LSLS     r1,r4,#2
00000e  5840              LDR      r0,[r0,r1]
000010  43a8              BICS     r0,r0,r5
000012  490d              LDR      r1,|L4.72|
000014  00a2              LSLS     r2,r4,#2
000016  5088              STR      r0,[r1,r2]
                  |L4.24|
;;;393    	}
;;;394    
;;;395    	if(u32InterruptFlag & DRVUART_TOUTINT)			  							 /* Disable Counter Enable */
000018  2010              MOVS     r0,#0x10
00001a  4205              TST      r5,r0
00001c  d008              BEQ      |L4.48|
;;;396    	{
;;;397    		if(u16Port == DRVUART_PORT0)
00001e  2c00              CMP      r4,#0
000020  d106              BNE      |L4.48|
;;;398    			UART0->IER.RTO_IEN = 0;
000022  4809              LDR      r0,|L4.72|
000024  1f00              SUBS     r0,r0,#4
000026  6840              LDR      r0,[r0,#4]
000028  2110              MOVS     r1,#0x10
00002a  4388              BICS     r0,r0,r1
00002c  4907              LDR      r1,|L4.76|
00002e  6048              STR      r0,[r1,#4]
                  |L4.48|
;;;399    	}
;;;400    
;;;401    	switch (u16Port)									   			 /* Disable Callback function and NVIC */
000030  2c00              CMP      r4,#0
000032  d106              BNE      |L4.66|
;;;402        {
;;;403            case UART_PORT0:
;;;404    			g_pfnUART0callback = NULL;
000034  2000              MOVS     r0,#0
000036  4906              LDR      r1,|L4.80|
000038  6008              STR      r0,[r1,#0]  ; g_pfnUART0callback
;;;405                NVIC_DisableIRQ(UART0_IRQn);
00003a  200c              MOVS     r0,#0xc
00003c  f7fffffe          BL       NVIC_DisableIRQ
;;;406                break;
000040  e000              B        |L4.68|
                  |L4.66|
;;;407            default:
;;;408                break;
000042  bf00              NOP      
                  |L4.68|
000044  bf00              NOP                            ;406
;;;409        }
;;;410    
;;;411    }
000046  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

                  |L4.72|
                          DCD      0x40050004
                  |L4.76|
                          DCD      0x40050000
                  |L4.80|
                          DCD      g_pfnUART0callback

                          AREA ||i.DrvUART_EnableInt||, CODE, READONLY, ALIGN=2

                  DrvUART_EnableInt PROC
;;;316    /*---------------------------------------------------------------------------------------------------------*/
;;;317    int32_t DrvUART_EnableInt(
000000  b530              PUSH     {r4,r5,lr}
;;;318    	UART_PORT   u16Port,
;;;319    	uint32_t  u32InterruptFlag,
;;;320    	PFN_DRVUART_CALLBACK pfncallback
;;;321    )
;;;322    {
000002  4603              MOV      r3,r0
;;;323        if((u16Port != UART_PORT0) )
000004  2b00              CMP      r3,#0
000006  d001              BEQ      |L5.12|
;;;324        {
;;;325            return E_DRVUART_ARGUMENT;
000008  4837              LDR      r0,|L5.232|
                  |L5.10|
;;;326        }
;;;327    
;;;328     	if(u16Port == UART_PORT0)											   	/* Set Specified Interrupt */
;;;329    	{
;;;330    		UART0->IER.RDA_IEN		=(u32InterruptFlag & DRVUART_RDAINT)?1:0 ;
;;;331    		UART0->IER.THRE_IEN		=(u32InterruptFlag & DRVUART_THREINT)?1:0;
;;;332    		UART0->IER.RLS_IEN		=(u32InterruptFlag & DRVUART_RLSNT)?1:0;
;;;333    		UART0->IER.MS_IEN		=(u32InterruptFlag & DRVUART_MOSINT)?1:0;
;;;334    
;;;335    		UART0->IER.TOC_EN		=(u32InterruptFlag & DRVUART_TOUTINT)?1:0;   	/* Time-out count enable */
;;;336    		UART0->IER.RTO_IEN		=(u32InterruptFlag & DRVUART_TOUTINT)?1:0;		/* Time-out INT enable */
;;;337    
;;;338    		UART0->IER.BUF_ERR_IEN	=(u32InterruptFlag & DRVUART_BUFERRINT)?1:0;
;;;339    		UART0->IER.LIN_RX_BRK_IEN=(u32InterruptFlag & DRVUART_LININT)?1:0;
;;;340    
;;;341    	}
;;;342        if(u16Port == UART_PORT0)											   	/* Install Callback function */
;;;343        {
;;;344    		g_pfnUART0callback = pfncallback;
;;;345    		NVIC_EnableIRQ(UART0_IRQn);
;;;346        }
;;;347    
;;;348    	return E_SUCCESS;
;;;349    
;;;350    }
00000a  bd30              POP      {r4,r5,pc}
                  |L5.12|
00000c  2b00              CMP      r3,#0                 ;328
00000e  d15e              BNE      |L5.206|
000010  4836              LDR      r0,|L5.236|
000012  6840              LDR      r0,[r0,#4]            ;330
000014  0840              LSRS     r0,r0,#1              ;330
000016  0040              LSLS     r0,r0,#1              ;330
000018  07cc              LSLS     r4,r1,#31             ;330
00001a  0fe4              LSRS     r4,r4,#31             ;330
00001c  4320              ORRS     r0,r0,r4              ;330
00001e  4c33              LDR      r4,|L5.236|
000020  6060              STR      r0,[r4,#4]            ;330
000022  4620              MOV      r0,r4                 ;331
000024  6840              LDR      r0,[r0,#4]            ;331
000026  2402              MOVS     r4,#2                 ;331
000028  43a0              BICS     r0,r0,r4              ;331
00002a  400c              ANDS     r4,r4,r1              ;331
00002c  0864              LSRS     r4,r4,#1              ;331
00002e  0064              LSLS     r4,r4,#1              ;331
000030  2502              MOVS     r5,#2                 ;331
000032  402c              ANDS     r4,r4,r5              ;331
000034  4320              ORRS     r0,r0,r4              ;331
000036  4c2d              LDR      r4,|L5.236|
000038  6060              STR      r0,[r4,#4]            ;331
00003a  4620              MOV      r0,r4                 ;332
00003c  6840              LDR      r0,[r0,#4]            ;332
00003e  2404              MOVS     r4,#4                 ;332
000040  43a0              BICS     r0,r0,r4              ;332
000042  400c              ANDS     r4,r4,r1              ;332
000044  08a4              LSRS     r4,r4,#2              ;332
000046  00a4              LSLS     r4,r4,#2              ;332
000048  2504              MOVS     r5,#4                 ;332
00004a  402c              ANDS     r4,r4,r5              ;332
00004c  4320              ORRS     r0,r0,r4              ;332
00004e  4c27              LDR      r4,|L5.236|
000050  6060              STR      r0,[r4,#4]            ;332
000052  4620              MOV      r0,r4                 ;333
000054  6840              LDR      r0,[r0,#4]            ;333
000056  2408              MOVS     r4,#8                 ;333
000058  43a0              BICS     r0,r0,r4              ;333
00005a  400c              ANDS     r4,r4,r1              ;333
00005c  08e4              LSRS     r4,r4,#3              ;333
00005e  00e4              LSLS     r4,r4,#3              ;333
000060  2508              MOVS     r5,#8                 ;333
000062  402c              ANDS     r4,r4,r5              ;333
000064  4320              ORRS     r0,r0,r4              ;333
000066  4c21              LDR      r4,|L5.236|
000068  6060              STR      r0,[r4,#4]            ;333
00006a  4620              MOV      r0,r4                 ;335
00006c  6840              LDR      r0,[r0,#4]            ;335
00006e  4c20              LDR      r4,|L5.240|
000070  43a0              BICS     r0,r0,r4              ;335
000072  2410              MOVS     r4,#0x10              ;335
000074  400c              ANDS     r4,r4,r1              ;335
000076  0924              LSRS     r4,r4,#4              ;335
000078  02e4              LSLS     r4,r4,#11             ;335
00007a  022d              LSLS     r5,r5,#8              ;335
00007c  402c              ANDS     r4,r4,r5              ;335
00007e  4320              ORRS     r0,r0,r4              ;335
000080  4c1a              LDR      r4,|L5.236|
000082  6060              STR      r0,[r4,#4]            ;335
000084  4620              MOV      r0,r4                 ;336
000086  6840              LDR      r0,[r0,#4]            ;336
000088  2410              MOVS     r4,#0x10              ;336
00008a  43a0              BICS     r0,r0,r4              ;336
00008c  400c              ANDS     r4,r4,r1              ;336
00008e  0924              LSRS     r4,r4,#4              ;336
000090  0124              LSLS     r4,r4,#4              ;336
000092  2510              MOVS     r5,#0x10              ;336
000094  402c              ANDS     r4,r4,r5              ;336
000096  4320              ORRS     r0,r0,r4              ;336
000098  4c14              LDR      r4,|L5.236|
00009a  6060              STR      r0,[r4,#4]            ;336
00009c  4620              MOV      r0,r4                 ;338
00009e  6840              LDR      r0,[r0,#4]            ;338
0000a0  2420              MOVS     r4,#0x20              ;338
0000a2  43a0              BICS     r0,r0,r4              ;338
0000a4  400c              ANDS     r4,r4,r1              ;338
0000a6  0964              LSRS     r4,r4,#5              ;338
0000a8  0164              LSLS     r4,r4,#5              ;338
0000aa  2520              MOVS     r5,#0x20              ;338
0000ac  402c              ANDS     r4,r4,r5              ;338
0000ae  4320              ORRS     r0,r0,r4              ;338
0000b0  4c0e              LDR      r4,|L5.236|
0000b2  6060              STR      r0,[r4,#4]            ;338
0000b4  4620              MOV      r0,r4                 ;339
0000b6  6840              LDR      r0,[r0,#4]            ;339
0000b8  4c0e              LDR      r4,|L5.244|
0000ba  43a0              BICS     r0,r0,r4              ;339
0000bc  2480              MOVS     r4,#0x80              ;339
0000be  400c              ANDS     r4,r4,r1              ;339
0000c0  09e4              LSRS     r4,r4,#7              ;339
0000c2  0224              LSLS     r4,r4,#8              ;339
0000c4  00ed              LSLS     r5,r5,#3              ;339
0000c6  402c              ANDS     r4,r4,r5              ;339
0000c8  4320              ORRS     r0,r0,r4              ;339
0000ca  4c08              LDR      r4,|L5.236|
0000cc  6060              STR      r0,[r4,#4]            ;339
                  |L5.206|
0000ce  2b00              CMP      r3,#0                 ;342
0000d0  d108              BNE      |L5.228|
0000d2  4809              LDR      r0,|L5.248|
0000d4  6002              STR      r2,[r0,#0]            ;344  ; g_pfnUART0callback
0000d6  200c              MOVS     r0,#0xc               ;345
0000d8  2401              MOVS     r4,#1                 ;345
0000da  4084              LSLS     r4,r4,r0              ;345
0000dc  4d07              LDR      r5,|L5.252|
0000de  602c              STR      r4,[r5,#0]            ;345
0000e0  bf00              NOP                            ;345
0000e2  bf00              NOP                            ;345
                  |L5.228|
0000e4  2000              MOVS     r0,#0                 ;348
0000e6  e790              B        |L5.10|
;;;351    
                          ENDP

                  |L5.232|
                          DCD      0xffff9807
                  |L5.236|
                          DCD      0x40050000
                  |L5.240|
                          DCD      0x00000800
                  |L5.244|
                          DCD      0x00000100
                  |L5.248|
                          DCD      g_pfnUART0callback
                  |L5.252|
                          DCD      0xe000e100

                          AREA ||i.DrvUART_GetCTS||, CODE, READONLY, ALIGN=2

                  DrvUART_GetCTS PROC
;;;520    /*---------------------------------------------------------------------------------------------------------*/
;;;521    void DrvUART_GetCTS(UART_PORT u16Port,uint8_t *pu8CTSValue,	uint8_t	*pu8CTSChangeState)
000000  2800              CMP      r0,#0
;;;522    {
;;;523    	if(u16Port == UART_PORT0)
000002  d10a              BNE      |L6.26|
;;;524    	{
;;;525    		*pu8CTSValue 		= UART0->MSR.CTS;
000004  4b06              LDR      r3,|L6.32|
000006  695b              LDR      r3,[r3,#0x14]
000008  06db              LSLS     r3,r3,#27
00000a  0fdb              LSRS     r3,r3,#31
00000c  700b              STRB     r3,[r1,#0]
;;;526    		*pu8CTSChangeState 	= UART0->MSR.DCTS;
00000e  4b04              LDR      r3,|L6.32|
000010  695b              LDR      r3,[r3,#0x14]
000012  07db              LSLS     r3,r3,#31
000014  0fdb              LSRS     r3,r3,#31
000016  7013              STRB     r3,[r2,#0]
000018  e000              B        |L6.28|
                  |L6.26|
;;;527    	}
;;;528    	else
;;;529    		return;   /* CTS */
;;;530    }
00001a  4770              BX       lr
                  |L6.28|
00001c  bf00              NOP      
00001e  e7fc              B        |L6.26|
;;;531    
                          ENDP

                  |L6.32|
                          DCD      0x40050000

                          AREA ||i.DrvUART_GetIntStatus||, CODE, READONLY, ALIGN=2

                  DrvUART_GetIntStatus PROC
;;;460    /*---------------------------------------------------------------------------------------------------------*/
;;;461    int8_t DrvUART_GetIntStatus(UART_PORT u16Port,uint32_t u32InterruptFlag)
000000  4602              MOV      r2,r0
;;;462    {
;;;463    
;;;464    	switch(u32InterruptFlag)
000002  2904              CMP      r1,#4
000004  d011              BEQ      |L7.42|
000006  dc04              BGT      |L7.18|
000008  2901              CMP      r1,#1
00000a  d01c              BEQ      |L7.70|
00000c  2902              CMP      r1,#2
00000e  d127              BNE      |L7.96|
000010  e012              B        |L7.56|
                  |L7.18|
000012  2908              CMP      r1,#8
000014  d002              BEQ      |L7.28|
000016  2910              CMP      r1,#0x10
000018  d122              BNE      |L7.96|
00001a  e01a              B        |L7.82|
                  |L7.28|
;;;465    	{
;;;466    		case DRVUART_MOSINT:				  	/* MODEM Status Interrupt */
;;;467    				return (inpw(&UART0->ISR + u16Port) & DRVUART_MOSINT)?TRUE:FALSE;
00001c  4811              LDR      r0,|L7.100|
00001e  0093              LSLS     r3,r2,#2
000020  58c0              LDR      r0,[r0,r3]
000022  2308              MOVS     r3,#8
000024  4018              ANDS     r0,r0,r3
000026  08c0              LSRS     r0,r0,#3
                  |L7.40|
;;;468    
;;;469    		case DRVUART_RLSNT:						/* Receive Line Status Interrupt */
;;;470    				return (inpw(&UART0->ISR + u16Port) & DRVUART_RLSNT)?TRUE:FALSE;
;;;471    
;;;472    		case DRVUART_THREINT:					/* Transmit Holding Register Empty Interrupt */
;;;473    				return (inpw(&UART0->ISR + u16Port) & DRVUART_THREINT)?TRUE:FALSE;
;;;474    
;;;475    		case DRVUART_RDAINT:					/* Receive Data Available Interrupt */
;;;476    				return (inpw(&UART0->ISR + u16Port) & DRVUART_RDAINT)?TRUE:FALSE;
;;;477    
;;;478    		case DRVUART_TOUTINT:					/* Time-out Interrupt */
;;;479    				return (inpw(&UART0->ISR + u16Port) & DRVUART_TOUTINT)?TRUE:FALSE;
;;;480    
;;;481    		default:
;;;482    			return FALSE;
;;;483    	}
;;;484    
;;;485    }
000028  4770              BX       lr
                  |L7.42|
00002a  480e              LDR      r0,|L7.100|
00002c  0093              LSLS     r3,r2,#2              ;470
00002e  58c0              LDR      r0,[r0,r3]            ;470
000030  2304              MOVS     r3,#4                 ;470
000032  4018              ANDS     r0,r0,r3              ;470
000034  0880              LSRS     r0,r0,#2              ;470
000036  e7f7              B        |L7.40|
                  |L7.56|
000038  480a              LDR      r0,|L7.100|
00003a  0093              LSLS     r3,r2,#2              ;473
00003c  58c0              LDR      r0,[r0,r3]            ;473
00003e  2302              MOVS     r3,#2                 ;473
000040  4018              ANDS     r0,r0,r3              ;473
000042  0840              LSRS     r0,r0,#1              ;473
000044  e7f0              B        |L7.40|
                  |L7.70|
000046  4807              LDR      r0,|L7.100|
000048  0093              LSLS     r3,r2,#2              ;476
00004a  58c0              LDR      r0,[r0,r3]            ;476
00004c  07c0              LSLS     r0,r0,#31             ;476
00004e  0fc0              LSRS     r0,r0,#31             ;476
000050  e7ea              B        |L7.40|
                  |L7.82|
000052  4804              LDR      r0,|L7.100|
000054  0093              LSLS     r3,r2,#2              ;479
000056  58c0              LDR      r0,[r0,r3]            ;479
000058  2310              MOVS     r3,#0x10              ;479
00005a  4018              ANDS     r0,r0,r3              ;479
00005c  0900              LSRS     r0,r0,#4              ;479
00005e  e7e3              B        |L7.40|
                  |L7.96|
000060  2000              MOVS     r0,#0                 ;482
000062  e7e1              B        |L7.40|
;;;486    
                          ENDP

                  |L7.100|
                          DCD      0x4005001c

                          AREA ||i.DrvUART_GetUartCLk||, CODE, READONLY, ALIGN=2

                  DrvUART_GetUartCLk PROC
;;;111    //static uint32_t DrvUART_GetUartCLk(void)
;;;112    uint32_t DrvUART_GetUartCLk(void)
000000  b570              PUSH     {r4-r6,lr}
;;;113    {
;;;114    	uint32_t u32clk =0;
000002  bf00              NOP      
;;;115    													/* Check UART Clock Source Setting */
;;;116    //	u32clk = 49152000;								    /* Clock 49Mhz  */
;;;117    	u32clk = DrvSYS_GetHCLK() * 1000 / (SYSCLK->CLKDIV.UART_N + 1) ;					
000004  f7fffffe          BL       DrvSYS_GetHCLK
000008  217d              MOVS     r1,#0x7d
00000a  00c9              LSLS     r1,r1,#3
00000c  4348              MULS     r0,r1,r0
00000e  4605              MOV      r5,r0
000010  4805              LDR      r0,|L8.40|
000012  6980              LDR      r0,[r0,#0x18]
000014  0500              LSLS     r0,r0,#20
000016  0f00              LSRS     r0,r0,#28
000018  1c41              ADDS     r1,r0,#1
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  4604              MOV      r4,r0
;;;118    	return u32clk;
000022  4620              MOV      r0,r4
;;;119    }
000024  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x50000200

                          AREA ||i.DrvUART_GetVersion||, CODE, READONLY, ALIGN=2

                  DrvUART_GetVersion PROC
;;;758    /*---------------------------------------------------------------------------------------------------------*/
;;;759    int32_t	DrvUART_GetVersion(void)
000000  4800              LDR      r0,|L9.4|
;;;760    {
;;;761    	return DRVUART_VERSION_NUM;
;;;762    
;;;763    }
000002  4770              BX       lr
;;;764    
                          ENDP

                  |L9.4|
                          DCD      0x00010001

                          AREA ||i.DrvUART_Init||, CODE, READONLY, ALIGN=2

                  DrvUART_Init PROC
;;;782    
;;;783    void DrvUART_Init(int baudrate)
000000  b570              PUSH     {r4-r6,lr}
;;;784    {
000002  4604              MOV      r4,r0
;;;785        /* Multi-Function Pin: Enable UART0:Tx Rx */
;;;786    	SYS->GPA_ALT.GPA8 = 1;
000004  481a              LDR      r0,|L10.112|
000006  6b80              LDR      r0,[r0,#0x38]
000008  491a              LDR      r1,|L10.116|
00000a  4388              BICS     r0,r0,r1
00000c  2101              MOVS     r1,#1
00000e  0409              LSLS     r1,r1,#16
000010  1840              ADDS     r0,r0,r1
000012  4917              LDR      r1,|L10.112|
000014  6388              STR      r0,[r1,#0x38]
;;;787    	SYS->GPA_ALT.GPA9 = 1;
000016  4608              MOV      r0,r1
000018  6b80              LDR      r0,[r0,#0x38]
00001a  4917              LDR      r1,|L10.120|
00001c  4388              BICS     r0,r0,r1
00001e  2101              MOVS     r1,#1
000020  0489              LSLS     r1,r1,#18
000022  1840              ADDS     r0,r0,r1
000024  4912              LDR      r1,|L10.112|
000026  6388              STR      r0,[r1,#0x38]
;;;788        /* Configure GCR to reset UART0 */
;;;789        SYS->IPRSTC2.UART0_RST = 1;
000028  4608              MOV      r0,r1
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  4913              LDR      r1,|L10.124|
00002e  4388              BICS     r0,r0,r1
000030  1840              ADDS     r0,r0,r1
000032  490f              LDR      r1,|L10.112|
000034  60c8              STR      r0,[r1,#0xc]
;;;790        SYS->IPRSTC2.UART0_RST = 0;
000036  4608              MOV      r0,r1
000038  68c0              LDR      r0,[r0,#0xc]
00003a  4910              LDR      r1,|L10.124|
00003c  4388              BICS     r0,r0,r1
00003e  490c              LDR      r1,|L10.112|
000040  60c8              STR      r0,[r1,#0xc]
;;;791    
;;;792        /* Enable UART clock */
;;;793    	SYSCLK->APBCLK.UART0_EN = 1;
000042  480f              LDR      r0,|L10.128|
000044  6880              LDR      r0,[r0,#8]
000046  490d              LDR      r1,|L10.124|
000048  4388              BICS     r0,r0,r1
00004a  1840              ADDS     r0,r0,r1
00004c  490c              LDR      r1,|L10.128|
00004e  6088              STR      r0,[r1,#8]
;;;794    
;;;795        /* Select UART clock source */
;;;796    //    SYSCLK->CLKSEL1.UART_S = 0;
;;;797    
;;;798        /* Data format */
;;;799        UART0->LCR.WLS = 3;
000050  480c              LDR      r0,|L10.132|
000052  68c0              LDR      r0,[r0,#0xc]
000054  0880              LSRS     r0,r0,#2
000056  0080              LSLS     r0,r0,#2
000058  1cc0              ADDS     r0,r0,#3
00005a  490a              LDR      r1,|L10.132|
00005c  60c8              STR      r0,[r1,#0xc]
;;;800    
;;;801        /* Configure the baud rate */
;;;802    	DrvUART_BaudRateCalculator(DrvUART_GetUartCLk(), baudrate, &UART0->BAUD);
00005e  f7fffffe          BL       DrvUART_GetUartCLk
000062  4605              MOV      r5,r0
000064  4a07              LDR      r2,|L10.132|
000066  3224              ADDS     r2,r2,#0x24
000068  4621              MOV      r1,r4
00006a  f7fffffe          BL       DrvUART_BaudRateCalculator
;;;803    }
00006e  bd70              POP      {r4-r6,pc}
;;;804    
                          ENDP

                  |L10.112|
                          DCD      0x50000000
                  |L10.116|
                          DCD      0x00030000
                  |L10.120|
                          DCD      0x000c0000
                  |L10.124|
                          DCD      0x00010000
                  |L10.128|
                          DCD      0x50000200
                  |L10.132|
                          DCD      0x40050000

                          AREA ||i.DrvUART_IsIntEnabled||, CODE, READONLY, ALIGN=2

                  DrvUART_IsIntEnabled PROC
;;;364    /*---------------------------------------------------------------------------------------------------------*/
;;;365    uint32_t DrvUART_IsIntEnabled(UART_PORT	u16Port,uint32_t u32InterruptFlag)
000000  4602              MOV      r2,r0
;;;366    {
;;;367    		/* Read IER Register and check specified flag is enable */
;;;368    		return ((inpw(&UART0->IER) &
000002  4804              LDR      r0,|L11.20|
000004  6840              LDR      r0,[r0,#4]
000006  b2cb              UXTB     r3,r1
000008  4218              TST      r0,r3
00000a  d001              BEQ      |L11.16|
;;;369    		 (u32InterruptFlag & (DRVUART_LININT | DRVUART_WAKEUPINT | DRVUART_BUFERRINT |
;;;370    		 		DRVUART_TOUTINT | DRVUART_MOSINT | DRVUART_RLSNT | DRVUART_THREINT | DRVUART_RDAINT))))?1:0;
00000c  2001              MOVS     r0,#1
                  |L11.14|
;;;371    
;;;372    
;;;373    }
00000e  4770              BX       lr
                  |L11.16|
000010  2000              MOVS     r0,#0                 ;370
000012  e7fc              B        |L11.14|
;;;374    
                          ENDP

                  |L11.20|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Open||, CODE, READONLY, ALIGN=2

                  DrvUART_Open PROC
;;;171    /*---------------------------------------------------------------------------------------------------------*/
;;;172    int32_t DrvUART_Open(UART_PORT u16Port, STR_UART_T *sParam)
000000  b570              PUSH     {r4-r6,lr}
;;;173    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;174    
;;;175        /*-----------------------------------------------------------------------------------------------------*/
;;;176        /* Check UART port                                                                                     */
;;;177        /*-----------------------------------------------------------------------------------------------------*/
;;;178        if (u16Port != UART_PORT0) 
000006  2d00              CMP      r5,#0
000008  d001              BEQ      |L12.14|
;;;179        {
;;;180    
;;;181    		return E_DRVUART_ERR_PORT_INVALID;
00000a  4866              LDR      r0,|L12.420|
                  |L12.12|
;;;182        }
;;;183    
;;;184    
;;;185        /*-----------------------------------------------------------------------------------------------------*/
;;;186        /* Check the supplied parity                                                                           */
;;;187        /*-----------------------------------------------------------------------------------------------------*/
;;;188        if ((sParam->u8cParity != DRVUART_PARITY_NONE) &&
;;;189            (sParam->u8cParity != DRVUART_PARITY_EVEN) &&
;;;190            (sParam->u8cParity != DRVUART_PARITY_ODD)  &&
;;;191            (sParam->u8cParity != DRVUART_PARITY_MARK) &&
;;;192            (sParam->u8cParity != DRVUART_PARITY_SPACE))
;;;193        {
;;;194     		return E_DRVUART_ERR_PARITY_INVALID;
;;;195        }
;;;196        /*-----------------------------------------------------------------------------------------------------*/
;;;197        /* Check the supplied number of data bits                                                              */
;;;198        /*-----------------------------------------------------------------------------------------------------*/
;;;199        else if ((sParam->u8cDataBits != DRVUART_DATABITS_5) &&
;;;200                 (sParam->u8cDataBits != DRVUART_DATABITS_6) &&
;;;201                 (sParam->u8cDataBits != DRVUART_DATABITS_7) &&
;;;202                 (sParam->u8cDataBits != DRVUART_DATABITS_8))
;;;203        {
;;;204     		return E_DRVUART_ERR_DATA_BITS_INVALID;
;;;205        }
;;;206        /*-----------------------------------------------------------------------------------------------------*/
;;;207        /* Check the supplied number of stop bits                                                              */
;;;208        /*-----------------------------------------------------------------------------------------------------*/
;;;209        else if ((sParam->u8cStopBits != DRVUART_STOPBITS_1) &&
;;;210                 (sParam->u8cStopBits != DRVUART_STOPBITS_2) &&
;;;211                 (sParam->u8cStopBits != DRVUART_STOPBITS_1_5)
;;;212                 )
;;;213        {
;;;214          	return E_DRVUART_ERR_STOP_BITS_INVALID;
;;;215        }
;;;216    
;;;217    
;;;218        /*-----------------------------------------------------------------------------------------------------*/
;;;219        /* Check the supplied nember of trigger level bytes                                                    */
;;;220        /*-----------------------------------------------------------------------------------------------------*/
;;;221        else if ((sParam->u8cRxTriggerLevel != DRVUART_FIFO_1BYTES) &&
;;;222                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_4BYTES) &&
;;;223                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_8BYTES) &&
;;;224                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_14BYTES)&&
;;;225                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_30BYTES)&&
;;;226                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_46BYTES)&&
;;;227                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_62BYTES))
;;;228        {
;;;229    		return E_DRVUART_ERR_TRIGGERLEVEL_INVALID;
;;;230        }
;;;231    
;;;232    	if(u16Port == UART_PORT0)
;;;233    	{
;;;234    		/* Reset IP */
;;;235    		SYS->IPRSTC2.UART0_RST = 1;
;;;236    		SYS->IPRSTC2.UART0_RST = 0;
;;;237    
;;;238    		/* Enable UART clock */
;;;239    	    SYSCLK->APBCLK.UART0_EN = 1;
;;;240    
;;;241    
;;;242    	}
;;;243    
;;;244    	/* Tx FIFO Reset & Rx FIFO Reset & FIFO Mode Enable */
;;;245    	if(u16Port == UART_PORT0)
;;;246    	{
;;;247    	  	UART0->FCR.TFR =1;
;;;248    	  	UART0->FCR.RFR =1;
;;;249    	}
;;;250    
;;;251    	if (u16Port == UART_PORT0)
;;;252    	{
;;;253    		/* Set Rx Trigger Level */
;;;254    		UART0->FCR.RFITL = sParam->u8cRxTriggerLevel;
;;;255    
;;;256    		/* Set Parity & Data bits & Stop bits */
;;;257    		UART0->LCR.SPE	=((sParam->u8cParity)&0x4)?1:0;
;;;258    		UART0->LCR.EPE	=((sParam->u8cParity)&0x2)?1:0;
;;;259    		UART0->LCR.PBE	=((sParam->u8cParity)&0x1)?1:0;
;;;260    
;;;261    		UART0->LCR.WLS	=sParam->u8cDataBits;
;;;262    		UART0->LCR.NSB	=sParam->u8cStopBits;
;;;263    
;;;264    		/* Set Time-Out */
;;;265    		UART0->TOR.TOIC 		=sParam->u8TimeOut;
;;;266    
;;;267    		/* Set BaudRate */
;;;268    		DrvUART_BaudRateCalculator(DrvUART_GetUartCLk(), sParam->u32BaudRate, &UART0->BAUD);
;;;269    	}
;;;270    
;;;271    	return E_SUCCESS;
;;;272    }
00000c  bd70              POP      {r4-r6,pc}
                  |L12.14|
00000e  79a0              LDRB     r0,[r4,#6]            ;188
000010  2800              CMP      r0,#0                 ;188
000012  d00e              BEQ      |L12.50|
000014  79a0              LDRB     r0,[r4,#6]            ;189
000016  2803              CMP      r0,#3                 ;189
000018  d00b              BEQ      |L12.50|
00001a  79a0              LDRB     r0,[r4,#6]            ;190
00001c  2801              CMP      r0,#1                 ;190
00001e  d008              BEQ      |L12.50|
000020  79a0              LDRB     r0,[r4,#6]            ;191
000022  2805              CMP      r0,#5                 ;191
000024  d005              BEQ      |L12.50|
000026  79a0              LDRB     r0,[r4,#6]            ;192
000028  2807              CMP      r0,#7                 ;192
00002a  d002              BEQ      |L12.50|
00002c  485d              LDR      r0,|L12.420|
00002e  1c40              ADDS     r0,r0,#1              ;194
000030  e7ec              B        |L12.12|
                  |L12.50|
000032  7920              LDRB     r0,[r4,#4]            ;199
000034  2800              CMP      r0,#0                 ;199
000036  d00b              BEQ      |L12.80|
000038  7920              LDRB     r0,[r4,#4]            ;200
00003a  2801              CMP      r0,#1                 ;200
00003c  d008              BEQ      |L12.80|
00003e  7920              LDRB     r0,[r4,#4]            ;201
000040  2802              CMP      r0,#2                 ;201
000042  d005              BEQ      |L12.80|
000044  7920              LDRB     r0,[r4,#4]            ;202
000046  2803              CMP      r0,#3                 ;202
000048  d002              BEQ      |L12.80|
00004a  4856              LDR      r0,|L12.420|
00004c  1c80              ADDS     r0,r0,#2              ;204
00004e  e7dd              B        |L12.12|
                  |L12.80|
000050  7960              LDRB     r0,[r4,#5]            ;209
000052  2800              CMP      r0,#0                 ;209
000054  d008              BEQ      |L12.104|
000056  7960              LDRB     r0,[r4,#5]            ;210
000058  2801              CMP      r0,#1                 ;210
00005a  d005              BEQ      |L12.104|
00005c  7960              LDRB     r0,[r4,#5]            ;211
00005e  2801              CMP      r0,#1                 ;211
000060  d002              BEQ      |L12.104|
000062  4850              LDR      r0,|L12.420|
000064  1cc0              ADDS     r0,r0,#3              ;214
000066  e7d1              B        |L12.12|
                  |L12.104|
000068  79e0              LDRB     r0,[r4,#7]            ;221
00006a  2800              CMP      r0,#0                 ;221
00006c  d014              BEQ      |L12.152|
00006e  79e0              LDRB     r0,[r4,#7]            ;222
000070  2801              CMP      r0,#1                 ;222
000072  d011              BEQ      |L12.152|
000074  79e0              LDRB     r0,[r4,#7]            ;223
000076  2802              CMP      r0,#2                 ;223
000078  d00e              BEQ      |L12.152|
00007a  79e0              LDRB     r0,[r4,#7]            ;224
00007c  2803              CMP      r0,#3                 ;224
00007e  d00b              BEQ      |L12.152|
000080  79e0              LDRB     r0,[r4,#7]            ;225
000082  2804              CMP      r0,#4                 ;225
000084  d008              BEQ      |L12.152|
000086  79e0              LDRB     r0,[r4,#7]            ;226
000088  2805              CMP      r0,#5                 ;226
00008a  d005              BEQ      |L12.152|
00008c  79e0              LDRB     r0,[r4,#7]            ;227
00008e  2806              CMP      r0,#6                 ;227
000090  d002              BEQ      |L12.152|
000092  4844              LDR      r0,|L12.420|
000094  1d00              ADDS     r0,r0,#4              ;229
000096  e7b9              B        |L12.12|
                  |L12.152|
000098  2d00              CMP      r5,#0                 ;232
00009a  d115              BNE      |L12.200|
00009c  2005              MOVS     r0,#5                 ;235
00009e  0700              LSLS     r0,r0,#28             ;235
0000a0  68c0              LDR      r0,[r0,#0xc]          ;235
0000a2  2101              MOVS     r1,#1                 ;235
0000a4  0409              LSLS     r1,r1,#16             ;235
0000a6  4388              BICS     r0,r0,r1              ;235
0000a8  1840              ADDS     r0,r0,r1              ;235
0000aa  493f              LDR      r1,|L12.424|
0000ac  60c8              STR      r0,[r1,#0xc]          ;235
0000ae  4608              MOV      r0,r1                 ;236
0000b0  68c0              LDR      r0,[r0,#0xc]          ;236
0000b2  493e              LDR      r1,|L12.428|
0000b4  4388              BICS     r0,r0,r1              ;236
0000b6  493c              LDR      r1,|L12.424|
0000b8  60c8              STR      r0,[r1,#0xc]          ;236
0000ba  483d              LDR      r0,|L12.432|
0000bc  6880              LDR      r0,[r0,#8]            ;239
0000be  493b              LDR      r1,|L12.428|
0000c0  4388              BICS     r0,r0,r1              ;239
0000c2  1840              ADDS     r0,r0,r1              ;239
0000c4  493a              LDR      r1,|L12.432|
0000c6  6088              STR      r0,[r1,#8]            ;239
                  |L12.200|
0000c8  2d00              CMP      r5,#0                 ;245
0000ca  d10d              BNE      |L12.232|
0000cc  4839              LDR      r0,|L12.436|
0000ce  6880              LDR      r0,[r0,#8]            ;247
0000d0  2104              MOVS     r1,#4                 ;247
0000d2  4388              BICS     r0,r0,r1              ;247
0000d4  1d00              ADDS     r0,r0,#4              ;247
0000d6  4937              LDR      r1,|L12.436|
0000d8  6088              STR      r0,[r1,#8]            ;247
0000da  4608              MOV      r0,r1                 ;248
0000dc  6880              LDR      r0,[r0,#8]            ;248
0000de  2102              MOVS     r1,#2                 ;248
0000e0  4388              BICS     r0,r0,r1              ;248
0000e2  1c80              ADDS     r0,r0,#2              ;248
0000e4  4933              LDR      r1,|L12.436|
0000e6  6088              STR      r0,[r1,#8]            ;248
                  |L12.232|
0000e8  2d00              CMP      r5,#0                 ;251
0000ea  d158              BNE      |L12.414|
0000ec  4831              LDR      r0,|L12.436|
0000ee  6880              LDR      r0,[r0,#8]            ;254
0000f0  21f0              MOVS     r1,#0xf0              ;254
0000f2  4388              BICS     r0,r0,r1              ;254
0000f4  79e1              LDRB     r1,[r4,#7]            ;254
0000f6  0109              LSLS     r1,r1,#4              ;254
0000f8  22f0              MOVS     r2,#0xf0              ;254
0000fa  4011              ANDS     r1,r1,r2              ;254
0000fc  4308              ORRS     r0,r0,r1              ;254
0000fe  492d              LDR      r1,|L12.436|
000100  6088              STR      r0,[r1,#8]            ;254
000102  4608              MOV      r0,r1                 ;257
000104  68c0              LDR      r0,[r0,#0xc]          ;257
000106  2120              MOVS     r1,#0x20              ;257
000108  4388              BICS     r0,r0,r1              ;257
00010a  79a1              LDRB     r1,[r4,#6]            ;257
00010c  2204              MOVS     r2,#4                 ;257
00010e  4011              ANDS     r1,r1,r2              ;257
000110  0889              LSRS     r1,r1,#2              ;257
000112  0149              LSLS     r1,r1,#5              ;257
000114  2220              MOVS     r2,#0x20              ;257
000116  4011              ANDS     r1,r1,r2              ;257
000118  4308              ORRS     r0,r0,r1              ;257
00011a  4926              LDR      r1,|L12.436|
00011c  60c8              STR      r0,[r1,#0xc]          ;257
00011e  4608              MOV      r0,r1                 ;258
000120  68c0              LDR      r0,[r0,#0xc]          ;258
000122  2110              MOVS     r1,#0x10              ;258
000124  4388              BICS     r0,r0,r1              ;258
000126  79a1              LDRB     r1,[r4,#6]            ;258
000128  2202              MOVS     r2,#2                 ;258
00012a  4011              ANDS     r1,r1,r2              ;258
00012c  0849              LSRS     r1,r1,#1              ;258
00012e  0109              LSLS     r1,r1,#4              ;258
000130  2210              MOVS     r2,#0x10              ;258
000132  4011              ANDS     r1,r1,r2              ;258
000134  4308              ORRS     r0,r0,r1              ;258
000136  491f              LDR      r1,|L12.436|
000138  60c8              STR      r0,[r1,#0xc]          ;258
00013a  4608              MOV      r0,r1                 ;259
00013c  68c0              LDR      r0,[r0,#0xc]          ;259
00013e  2108              MOVS     r1,#8                 ;259
000140  4388              BICS     r0,r0,r1              ;259
000142  79a1              LDRB     r1,[r4,#6]            ;259
000144  00c9              LSLS     r1,r1,#3              ;259
000146  2208              MOVS     r2,#8                 ;259
000148  4011              ANDS     r1,r1,r2              ;259
00014a  4308              ORRS     r0,r0,r1              ;259
00014c  4919              LDR      r1,|L12.436|
00014e  60c8              STR      r0,[r1,#0xc]          ;259
000150  4608              MOV      r0,r1                 ;261
000152  68c0              LDR      r0,[r0,#0xc]          ;261
000154  0880              LSRS     r0,r0,#2              ;261
000156  0080              LSLS     r0,r0,#2              ;261
000158  7921              LDRB     r1,[r4,#4]            ;261
00015a  0789              LSLS     r1,r1,#30             ;261
00015c  0f89              LSRS     r1,r1,#30             ;261
00015e  4308              ORRS     r0,r0,r1              ;261
000160  4914              LDR      r1,|L12.436|
000162  60c8              STR      r0,[r1,#0xc]          ;261
000164  4608              MOV      r0,r1                 ;262
000166  68c0              LDR      r0,[r0,#0xc]          ;262
000168  2104              MOVS     r1,#4                 ;262
00016a  4388              BICS     r0,r0,r1              ;262
00016c  7961              LDRB     r1,[r4,#5]            ;262
00016e  0089              LSLS     r1,r1,#2              ;262
000170  2204              MOVS     r2,#4                 ;262
000172  4011              ANDS     r1,r1,r2              ;262
000174  4308              ORRS     r0,r0,r1              ;262
000176  490f              LDR      r1,|L12.436|
000178  60c8              STR      r0,[r1,#0xc]          ;262
00017a  4608              MOV      r0,r1                 ;265
00017c  6a00              LDR      r0,[r0,#0x20]         ;265
00017e  09c0              LSRS     r0,r0,#7              ;265
000180  01c0              LSLS     r0,r0,#7              ;265
000182  7a21              LDRB     r1,[r4,#8]            ;265
000184  0649              LSLS     r1,r1,#25             ;265
000186  0e49              LSRS     r1,r1,#25             ;265
000188  4308              ORRS     r0,r0,r1              ;265
00018a  490a              LDR      r1,|L12.436|
00018c  6208              STR      r0,[r1,#0x20]         ;265
00018e  f7fffffe          BL       DrvUART_GetUartCLk
000192  4606              MOV      r6,r0                 ;268
000194  4a07              LDR      r2,|L12.436|
000196  3224              ADDS     r2,r2,#0x24           ;268
000198  6821              LDR      r1,[r4,#0]            ;268
00019a  f7fffffe          BL       DrvUART_BaudRateCalculator
                  |L12.414|
00019e  2000              MOVS     r0,#0                 ;271
0001a0  e734              B        |L12.12|
;;;273    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L12.420|
                          DCD      0xffff9802
                  |L12.424|
                          DCD      0x50000000
                  |L12.428|
                          DCD      0x00010000
                  |L12.432|
                          DCD      0x50000200
                  |L12.436|
                          DCD      0x40050000

                          AREA ||i.DrvUART_OpenIRCR||, CODE, READONLY, ALIGN=2

                  DrvUART_OpenIRCR PROC
;;;650    /*---------------------------------------------------------------------------------------------------------*/
;;;651    void DrvUART_OpenIRCR(UART_PORT u16Port,STR_IRCR_T str_IRCR )
000000  b503              PUSH     {r0,r1,lr}
;;;652    {
;;;653    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d130              BNE      |L13.104|
;;;654    	{
;;;655    		UART0->FUNSEL.LIN_EN 	= 0;
000006  4919              LDR      r1,|L13.108|
000008  6b09              LDR      r1,[r1,#0x30]
00000a  0849              LSRS     r1,r1,#1
00000c  0049              LSLS     r1,r1,#1
00000e  4a17              LDR      r2,|L13.108|
000010  6311              STR      r1,[r2,#0x30]
;;;656    		UART0->FUNSEL.IrDA_EN 	= 1;
000012  4611              MOV      r1,r2
000014  6b09              LDR      r1,[r1,#0x30]
000016  2202              MOVS     r2,#2
000018  4391              BICS     r1,r1,r2
00001a  1c89              ADDS     r1,r1,#2
00001c  4a13              LDR      r2,|L13.108|
00001e  6311              STR      r1,[r2,#0x30]
;;;657    		//UART0->IRCR.RX_EN 		= str_IRCR.u8cRXSelect ;
;;;658    		UART0->IRCR.TX_SELECT	= str_IRCR.u8cTXSelect ;
000020  4611              MOV      r1,r2
000022  6a89              LDR      r1,[r1,#0x28]
000024  2202              MOVS     r2,#2
000026  4391              BICS     r1,r1,r2
000028  466a              MOV      r2,sp
00002a  7952              LDRB     r2,[r2,#5]
00002c  0052              LSLS     r2,r2,#1
00002e  2302              MOVS     r3,#2
000030  401a              ANDS     r2,r2,r3
000032  4311              ORRS     r1,r1,r2
000034  4a0d              LDR      r2,|L13.108|
000036  6291              STR      r1,[r2,#0x28]
;;;659    		UART0->IRCR.TX_INV_EN	= str_IRCR.u8cInvTX ;
000038  4611              MOV      r1,r2
00003a  6a89              LDR      r1,[r1,#0x28]
00003c  2220              MOVS     r2,#0x20
00003e  4391              BICS     r1,r1,r2
000040  466a              MOV      r2,sp
000042  7992              LDRB     r2,[r2,#6]
000044  0152              LSLS     r2,r2,#5
000046  2320              MOVS     r3,#0x20
000048  401a              ANDS     r2,r2,r3
00004a  4311              ORRS     r1,r1,r2
00004c  4a07              LDR      r2,|L13.108|
00004e  6291              STR      r1,[r2,#0x28]
;;;660    		UART0->IRCR.RX_INV_EN	= str_IRCR.u8cInvRX ;
000050  4611              MOV      r1,r2
000052  6a89              LDR      r1,[r1,#0x28]
000054  2240              MOVS     r2,#0x40
000056  4391              BICS     r1,r1,r2
000058  466a              MOV      r2,sp
00005a  79d2              LDRB     r2,[r2,#7]
00005c  0192              LSLS     r2,r2,#6
00005e  2340              MOVS     r3,#0x40
000060  401a              ANDS     r2,r2,r3
000062  4311              ORRS     r1,r1,r2
000064  4a01              LDR      r2,|L13.108|
000066  6291              STR      r1,[r2,#0x28]
                  |L13.104|
;;;661    
;;;662    	}
;;;663    
;;;664    }
000068  bd0c              POP      {r2,r3,pc}
;;;665    
                          ENDP

00006a  0000              DCW      0x0000
                  |L13.108|
                          DCD      0x40050000

                          AREA ||i.DrvUART_OpenLIN||, CODE, READONLY, ALIGN=2

                  DrvUART_OpenLIN PROC
;;;679    /*---------------------------------------------------------------------------------------------------------*/
;;;680    void DrvUART_OpenLIN(UART_PORT u16Port,uint16_t u16DIRECTION,uint16_t U16BCNT)
000000  b510              PUSH     {r4,lr}
;;;681    {
;;;682    
;;;683    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d132              BNE      |L14.108|
;;;684    	{
;;;685    		UART0->FUNSEL.LIN_EN 	= 1;
000006  4b1a              LDR      r3,|L14.112|
000008  6b1b              LDR      r3,[r3,#0x30]
00000a  085b              LSRS     r3,r3,#1
00000c  005b              LSLS     r3,r3,#1
00000e  1c5b              ADDS     r3,r3,#1
000010  4c17              LDR      r4,|L14.112|
000012  6323              STR      r3,[r4,#0x30]
;;;686    		UART0->FUNSEL.IrDA_EN 	= 0;
000014  4623              MOV      r3,r4
000016  6b1b              LDR      r3,[r3,#0x30]
000018  2402              MOVS     r4,#2
00001a  43a3              BICS     r3,r3,r4
00001c  4c14              LDR      r4,|L14.112|
00001e  6323              STR      r3,[r4,#0x30]
;;;687    		if(u16DIRECTION ==MODE_TX )
000020  2900              CMP      r1,#0
000022  d10d              BNE      |L14.64|
;;;688    		{
;;;689    			UART0->LINCON.LINTX_EN	= 1;
000024  4623              MOV      r3,r4
000026  6adb              LDR      r3,[r3,#0x2c]
000028  2480              MOVS     r4,#0x80
00002a  43a3              BICS     r3,r3,r4
00002c  3380              ADDS     r3,r3,#0x80
00002e  4c10              LDR      r4,|L14.112|
000030  62e3              STR      r3,[r4,#0x2c]
;;;690    			UART0->LINCON.LINRX_EN	= 0;
000032  4623              MOV      r3,r4
000034  6adb              LDR      r3,[r3,#0x2c]
000036  2440              MOVS     r4,#0x40
000038  43a3              BICS     r3,r3,r4
00003a  4c0d              LDR      r4,|L14.112|
00003c  62e3              STR      r3,[r4,#0x2c]
00003e  e00c              B        |L14.90|
                  |L14.64|
;;;691    		}else
;;;692    		{
;;;693    			UART0->LINCON.LINTX_EN	= 0;
000040  4b0b              LDR      r3,|L14.112|
000042  6adb              LDR      r3,[r3,#0x2c]
000044  2480              MOVS     r4,#0x80
000046  43a3              BICS     r3,r3,r4
000048  4c09              LDR      r4,|L14.112|
00004a  62e3              STR      r3,[r4,#0x2c]
;;;694    			UART0->LINCON.LINRX_EN	= 1;
00004c  4623              MOV      r3,r4
00004e  6adb              LDR      r3,[r3,#0x2c]
000050  2440              MOVS     r4,#0x40
000052  43a3              BICS     r3,r3,r4
000054  3340              ADDS     r3,r3,#0x40
000056  4c06              LDR      r4,|L14.112|
000058  62e3              STR      r3,[r4,#0x2c]
                  |L14.90|
;;;695    		}
;;;696    	    UART0->LINCON.LINBCNT = U16BCNT;
00005a  4b05              LDR      r3,|L14.112|
00005c  6adb              LDR      r3,[r3,#0x2c]
00005e  091b              LSRS     r3,r3,#4
000060  011b              LSLS     r3,r3,#4
000062  0714              LSLS     r4,r2,#28
000064  0f24              LSRS     r4,r4,#28
000066  4323              ORRS     r3,r3,r4
000068  4c01              LDR      r4,|L14.112|
00006a  62e3              STR      r3,[r4,#0x2c]
                  |L14.108|
;;;697    	}
;;;698    
;;;699    }
00006c  bd10              POP      {r4,pc}
;;;700    
                          ENDP

00006e  0000              DCW      0x0000
                  |L14.112|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Read||, CODE, READONLY, ALIGN=2

                  DrvUART_Read PROC
;;;566    /*---------------------------------------------------------------------------------------------------------*/
;;;567    int32_t DrvUART_Read(UART_PORT	u16Port,uint8_t	*pu8RxBuf, uint32_t	u32ReadBytes)
000000  b530              PUSH     {r4,r5,lr}
;;;568    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;569        uint32_t  u32Count, u32delayno;
;;;570    
;;;571    	if(u16Port == UART_PORT0)
000006  2b00              CMP      r3,#0
000008  d116              BNE      |L15.56|
;;;572    	{
;;;573    	    for (u32Count=0; u32Count < u32ReadBytes; u32Count++)
00000a  2100              MOVS     r1,#0
00000c  e012              B        |L15.52|
                  |L15.14|
;;;574    	    {
;;;575    	    	 u32delayno = 0;
00000e  2500              MOVS     r5,#0
;;;576    	         while (UART0->FSR.RX_EMPTY ==1)					  /* Check RX empty => failed */
000010  e006              B        |L15.32|
                  |L15.18|
;;;577    	         {
;;;578    	             u32delayno++;
000012  1c6d              ADDS     r5,r5,#1
;;;579    	             if ( u32delayno >= 0x40000000 )
000014  2001              MOVS     r0,#1
000016  0780              LSLS     r0,r0,#30
000018  4285              CMP      r5,r0
00001a  d301              BCC      |L15.32|
;;;580    	                return E_DRVUART_ERR_TIMEOUT;
00001c  4807              LDR      r0,|L15.60|
                  |L15.30|
;;;581    
;;;582    	         }
;;;583    	         pu8RxBuf[u32Count] = UART0->DATA;					  /* Get Data from UART RX  */
;;;584    	    }
;;;585    	}
;;;586    
;;;587        return E_SUCCESS;
;;;588    
;;;589    }
00001e  bd30              POP      {r4,r5,pc}
                  |L15.32|
000020  4807              LDR      r0,|L15.64|
000022  6980              LDR      r0,[r0,#0x18]         ;576
000024  0440              LSLS     r0,r0,#17             ;576
000026  0fc0              LSRS     r0,r0,#31             ;576
000028  2801              CMP      r0,#1                 ;576
00002a  d0f2              BEQ      |L15.18|
00002c  4804              LDR      r0,|L15.64|
00002e  7800              LDRB     r0,[r0,#0]            ;583
000030  5460              STRB     r0,[r4,r1]            ;583
000032  1c49              ADDS     r1,r1,#1              ;573
                  |L15.52|
000034  4291              CMP      r1,r2                 ;573
000036  d3ea              BCC      |L15.14|
                  |L15.56|
000038  2000              MOVS     r0,#0                 ;587
00003a  e7f0              B        |L15.30|
;;;590    
                          ENDP

                  |L15.60|
                          DCD      0xffff9801
                  |L15.64|
                          DCD      0x40050000

                          AREA ||i.DrvUART_SetFIFOTriggerLevel||, CODE, READONLY, ALIGN=2

                  DrvUART_SetFIFOTriggerLevel PROC
;;;499    /*---------------------------------------------------------------------------------------------------------*/
;;;500    void DrvUART_SetFIFOTriggerLevel(UART_PORT	u16Port,uint16_t u16TriggerLevel)
000000  b510              PUSH     {r4,lr}
;;;501    {
;;;502    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d109              BNE      |L16.26|
;;;503    		UART0->FCR.RFITL = u16TriggerLevel;
000006  4a05              LDR      r2,|L16.28|
000008  6892              LDR      r2,[r2,#8]
00000a  23f0              MOVS     r3,#0xf0
00000c  439a              BICS     r2,r2,r3
00000e  010b              LSLS     r3,r1,#4
000010  24f0              MOVS     r4,#0xf0
000012  4023              ANDS     r3,r3,r4
000014  431a              ORRS     r2,r2,r3
000016  4b01              LDR      r3,|L16.28|
000018  609a              STR      r2,[r3,#8]
                  |L16.26|
;;;504    
;;;505    }
00001a  bd10              POP      {r4,pc}
;;;506    
                          ENDP

                  |L16.28|
                          DCD      0x40050000

                          AREA ||i.DrvUART_SetPDMA||, CODE, READONLY, ALIGN=2

                  DrvUART_SetPDMA PROC
;;;734    /*---------------------------------------------------------------------------------------------------------*/
;;;735    void DrvUART_SetPDMA(UART_PORT u16Port,uint16_t u16IsEnable)
000000  b510              PUSH     {r4,lr}
;;;736    {
;;;737    
;;;738    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d120              BNE      |L17.72|
;;;739    	{
;;;740    		UART0->IER.DMA_TX_EN 	= u16IsEnable ?1:0;
000006  4a12              LDR      r2,|L17.80|
000008  6852              LDR      r2,[r2,#4]
00000a  2301              MOVS     r3,#1
00000c  039b              LSLS     r3,r3,#14
00000e  439a              BICS     r2,r2,r3
000010  2900              CMP      r1,#0
000012  d001              BEQ      |L17.24|
000014  2301              MOVS     r3,#1
000016  e000              B        |L17.26|
                  |L17.24|
000018  2300              MOVS     r3,#0
                  |L17.26|
00001a  039b              LSLS     r3,r3,#14
00001c  2401              MOVS     r4,#1
00001e  03a4              LSLS     r4,r4,#14
000020  4023              ANDS     r3,r3,r4
000022  431a              ORRS     r2,r2,r3
000024  4b0a              LDR      r3,|L17.80|
000026  605a              STR      r2,[r3,#4]
;;;741    		UART0->IER.DMA_RX_EN	= u16IsEnable ?1:0;
000028  461a              MOV      r2,r3
00002a  6852              LDR      r2,[r2,#4]
00002c  4b09              LDR      r3,|L17.84|
00002e  439a              BICS     r2,r2,r3
000030  2900              CMP      r1,#0
000032  d001              BEQ      |L17.56|
000034  2301              MOVS     r3,#1
000036  e000              B        |L17.58|
                  |L17.56|
000038  2300              MOVS     r3,#0
                  |L17.58|
00003a  03db              LSLS     r3,r3,#15
00003c  4c05              LDR      r4,|L17.84|
00003e  4023              ANDS     r3,r3,r4
000040  431a              ORRS     r2,r2,r3
000042  4b03              LDR      r3,|L17.80|
000044  605a              STR      r2,[r3,#4]
000046  e000              B        |L17.74|
                  |L17.72|
;;;742    	}
;;;743    	else
;;;744    		return;
;;;745    }
000048  bd10              POP      {r4,pc}
                  |L17.74|
00004a  bf00              NOP      
00004c  e7fc              B        |L17.72|
;;;746    
                          ENDP

00004e  0000              DCW      0x0000
                  |L17.80|
                          DCD      0x40050000
                  |L17.84|
                          DCD      0x00008000

                          AREA ||i.DrvUART_SetRTS||, CODE, READONLY, ALIGN=2

                  DrvUART_SetRTS PROC
;;;132    /*---------------------------------------------------------------------------------------------------------*/
;;;133    void DrvUART_SetRTS(UART_PORT u16Port,uint8_t u8Value)
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135    
;;;136    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d10a              BNE      |L18.28|
;;;137    		UART0->MCR.RTS_SET = u8Value;
000006  4a07              LDR      r2,|L18.36|
000008  6912              LDR      r2,[r2,#0x10]
00000a  2302              MOVS     r3,#2
00000c  439a              BICS     r2,r2,r3
00000e  004b              LSLS     r3,r1,#1
000010  2402              MOVS     r4,#2
000012  4023              ANDS     r3,r3,r4
000014  431a              ORRS     r2,r2,r3
000016  4b03              LDR      r3,|L18.36|
000018  611a              STR      r2,[r3,#0x10]
00001a  e000              B        |L18.30|
                  |L18.28|
;;;138    	else
;;;139    		return;
;;;140    }
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  bf00              NOP      
000020  e7fc              B        |L18.28|
;;;141    
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
                          DCD      0x40050000

                          AREA ||i.DrvUART_SetRxTimeOut||, CODE, READONLY, ALIGN=2

                  DrvUART_SetRxTimeOut PROC
;;;543    /*---------------------------------------------------------------------------------------------------------*/
;;;544    void DrvUART_SetRxTimeOut(UART_PORT	u16Port, uint8_t u8TimeOut)
000000  2800              CMP      r0,#0
;;;545    {
;;;546    	if(u16Port == UART_PORT0)
000002  d10f              BNE      |L19.36|
;;;547    	{
;;;548    		UART0->TOR.TOIC = u8TimeOut;					/* Set Time out value */
000004  4a08              LDR      r2,|L19.40|
000006  6a12              LDR      r2,[r2,#0x20]
000008  09d2              LSRS     r2,r2,#7
00000a  01d2              LSLS     r2,r2,#7
00000c  064b              LSLS     r3,r1,#25
00000e  0e5b              LSRS     r3,r3,#25
000010  431a              ORRS     r2,r2,r3
000012  4b05              LDR      r3,|L19.40|
000014  621a              STR      r2,[r3,#0x20]
;;;549    		UART0->IER.TOC_EN =1;							/* Enable Time-out count  */
000016  461a              MOV      r2,r3
000018  6852              LDR      r2,[r2,#4]
00001a  4b04              LDR      r3,|L19.44|
00001c  439a              BICS     r2,r2,r3
00001e  18d2              ADDS     r2,r2,r3
000020  4b01              LDR      r3,|L19.40|
000022  605a              STR      r2,[r3,#4]
                  |L19.36|
;;;550    	}
;;;551    
;;;552    }
000024  4770              BX       lr
;;;553    
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
                          DCD      0x40050000
                  |L19.44|
                          DCD      0x00000800

                          AREA ||i.DrvUART_Write||, CODE, READONLY, ALIGN=2

                  DrvUART_Write PROC
;;;605    /*---------------------------------------------------------------------------------------------------------*/
;;;606    int32_t DrvUART_Write(UART_PORT	u16Port,uint8_t	*pu8TxBuf, 	uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;607    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;608        uint32_t  u32Count, u32delayno;
;;;609    
;;;610    	if(u16Port == UART_PORT0)
000006  2b00              CMP      r3,#0
000008  d116              BNE      |L20.56|
;;;611    	{
;;;612    	    for (u32Count=0; u32Count<u32WriteBytes; u32Count++)
00000a  2100              MOVS     r1,#0
00000c  e012              B        |L20.52|
                  |L20.14|
;;;613    	    {
;;;614    		   UART0->DATA = pu8TxBuf[u32Count];						/* Send UART Data from buffer */	// 2014-01-030x00
00000e  5c60              LDRB     r0,[r4,r1]
000010  4e0a              LDR      r6,|L20.60|
000012  7030              STRB     r0,[r6,#0]
;;;615    	       u32delayno = 0;
000014  2500              MOVS     r5,#0
;;;616    		   while (UART0->FSR.TX_EMPTY !=1)	// (UART0->ISR.THRE_IF != 1)		// (UART0->FSR.TX_EMPTY !=1)							/* Wait Tx empty and Time-out manner */
000016  e006              B        |L20.38|
                  |L20.24|
;;;617    	       {
;;;618    	       	    u32delayno++;
000018  1c6d              ADDS     r5,r5,#1
;;;619    	       	    if ( u32delayno >= 0x40000000 )
00001a  2001              MOVS     r0,#1
00001c  0780              LSLS     r0,r0,#30
00001e  4285              CMP      r5,r0
000020  d301              BCC      |L20.38|
;;;620    	       	       return E_DRVUART_ERR_TIMEOUT;
000022  4807              LDR      r0,|L20.64|
                  |L20.36|
;;;621    
;;;622    	       }
;;;623    		   //UART0->DATA = pu8TxBuf[u32Count];						/* Send UART Data from buffer */
;;;624    	    }
;;;625    	}
;;;626    
;;;627        return E_SUCCESS;
;;;628    
;;;629    
;;;630    }
000024  bd70              POP      {r4-r6,pc}
                  |L20.38|
000026  4805              LDR      r0,|L20.60|
000028  6980              LDR      r0,[r0,#0x18]         ;616
00002a  0240              LSLS     r0,r0,#9              ;616
00002c  0fc0              LSRS     r0,r0,#31             ;616
00002e  2801              CMP      r0,#1                 ;616
000030  d1f2              BNE      |L20.24|
000032  1c49              ADDS     r1,r1,#1              ;612
                  |L20.52|
000034  4291              CMP      r1,r2                 ;612
000036  d3ea              BCC      |L20.14|
                  |L20.56|
000038  2000              MOVS     r0,#0                 ;627
00003a  e7f3              B        |L20.36|
;;;631    
                          ENDP

                  |L20.60|
                          DCD      0x40050000
                  |L20.64|
                          DCD      0xffff9801

                          AREA ||i.DrvUART_kbhit||, CODE, READONLY, ALIGN=2

                  DrvUART_kbhit PROC
;;;710    /*---------------------------------------------------------------------------------------------------------*/
;;;711    int32_t DrvUART_kbhit(void)
000000  4804              LDR      r0,|L21.20|
;;;712    {
;;;713    
;;;714        if(UART0->ISR.RDA_IF ==1)
000002  69c0              LDR      r0,[r0,#0x1c]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2801              CMP      r0,#1
00000a  d100              BNE      |L21.14|
                  |L21.12|
;;;715        {
;;;716            return TRUE;
;;;717        }
;;;718    
;;;719        return FALSE;
;;;720    }
00000c  4770              BX       lr
                  |L21.14|
00000e  2000              MOVS     r0,#0                 ;719
000010  e7fc              B        |L21.12|
;;;721    
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      0x40050000

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;554     */
;;;555    static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;556    {
;;;557      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L22.16|
00000a  6011              STR      r1,[r2,#0]
;;;558    }
00000c  4770              BX       lr
;;;559    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      0xe000e180

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;31     /*---------------------------------------------------------------------------------------------------------*/
;;;32     void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34         uint32_t u32uart0IntStatus;
;;;35     
;;;36         u32uart0IntStatus = inpw(&UART0->ISR) ;
000002  4805              LDR      r0,|L23.24|
000004  69c4              LDR      r4,[r0,#0x1c]
;;;37     
;;;38         if(g_pfnUART0callback != NULL)
000006  4805              LDR      r0,|L23.28|
000008  6800              LDR      r0,[r0,#0]  ; g_pfnUART0callback
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L23.22|
;;;39     	{
;;;40             g_pfnUART0callback(u32uart0IntStatus);
00000e  4620              MOV      r0,r4
000010  4902              LDR      r1,|L23.28|
000012  6809              LDR      r1,[r1,#0]  ; g_pfnUART0callback
000014  4788              BLX      r1
                  |L23.22|
;;;41         }
;;;42     
;;;43     }
000016  bd10              POP      {r4,pc}
;;;44     
                          ENDP

                  |L23.24|
                          DCD      0x40050000
                  |L23.28|
                          DCD      g_pfnUART0callback

                          AREA ||.data||, DATA, ALIGN=2

                  g_pfnUART0callback
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\ISD91XX_SDK\\NuvotonPlatform_Keil\\Src\\Driver\\DrvUART.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_DrvUART_c_9d14be4d____REV16|
#line 112 "..\\..\\ISD91XX_SDK\\CMSIS\\CM0\\CoreSupport\\core_cmInstr.h"
|__asm___9_DrvUART_c_9d14be4d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_DrvUART_c_9d14be4d____REVSH|
#line 130
|__asm___9_DrvUART_c_9d14be4d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
