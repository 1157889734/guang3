; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\uart.o --asm_dir=..\list\ --list_dir=..\list\ --depend=..\output\uart.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\inc -I..\..\ISD91XX_SDK\CMSIS\CM0\CoreSupport -I..\..\ISD91XX_SDK\CMSIS\CM0\DeviceSupport\Nuvoton\ISD91xx -I..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Include\Driver -I..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Include -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Nuvoton --omf_browse=..\output\uart.crf ..\src\uart.c]
                          THUMB

                          AREA ||i.UART_Configuration||, CODE, READONLY, ALIGN=2

                  UART_Configuration PROC
;;;69     
;;;70     void UART_Configuration(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;71     {
;;;72     	STR_UART_T sParam;
;;;73     	
;;;74     	sParam.u32BaudRate = 9600;
000002  4809              LDR      r0,|L1.40|
000004  9000              STR      r0,[sp,#0]
;;;75     	sParam.u8cDataBits = DRVUART_DATABITS_8;
000006  2103              MOVS     r1,#3
000008  4668              MOV      r0,sp
00000a  7101              STRB     r1,[r0,#4]
;;;76     	sParam.u8cStopBits = DRVUART_STOPBITS_1;
00000c  2100              MOVS     r1,#0
00000e  7141              STRB     r1,[r0,#5]
;;;77     	sParam.u8cParity = DRVUART_PARITY_NONE;
000010  7181              STRB     r1,[r0,#6]
;;;78     	sParam.u8cRxTriggerLevel = DRVUART_FIFO_1BYTES;
000012  71c1              STRB     r1,[r0,#7]
;;;79     	
;;;80     	DrvUART_Open(UART_PORT0, &sParam);
000014  4669              MOV      r1,sp
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       DrvUART_Open
;;;81     	
;;;82     	DrvUART_EnableInt(UART_PORT0, DRVUART_RDAINT, UART_INT_HANDLE); 			
00001c  4a03              LDR      r2,|L1.44|
00001e  2101              MOVS     r1,#1
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       DrvUART_EnableInt
;;;83     }
000026  bd0e              POP      {r1-r3,pc}
                          ENDP

                  |L1.40|
                          DCD      0x00002580
                  |L1.44|
                          DCD      UART_INT_HANDLE

                          AREA ||i.UART_INT_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_INT_HANDLE PROC
;;;49     
;;;50     static void UART_INT_HANDLE(uint32_t u32IntStatus)
000000  b538              PUSH     {r3-r5,lr}
;;;51     {
000002  4604              MOV      r4,r0
;;;52     	uint8_t tmp;
;;;53     
;;;54     	if(u32IntStatus & RDAIE)
000004  07e0              LSLS     r0,r4,#31
000006  0fc0              LSRS     r0,r0,#31
000008  d02c              BEQ      |L2.100|
;;;55     	{
;;;56     		while(UART0->ISR.RDA_IF == 1)
00000a  e025              B        |L2.88|
                  |L2.12|
;;;57     		{
;;;58     			DrvUART_Read(UART_PORT0, &tmp, 1);
00000c  2201              MOVS     r2,#1
00000e  4669              MOV      r1,sp
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DrvUART_Read
;;;59     			uart_rxbuf[uart_rx_wr_index++] = tmp;
000016  4669              MOV      r1,sp
000018  780a              LDRB     r2,[r1,#0]
00001a  4913              LDR      r1,|L2.104|
00001c  8808              LDRH     r0,[r1,#0]  ; uart_rx_wr_index
00001e  1c41              ADDS     r1,r0,#1
000020  4b11              LDR      r3,|L2.104|
000022  8019              STRH     r1,[r3,#0]
000024  4911              LDR      r1,|L2.108|
000026  540a              STRB     r2,[r1,r0]
;;;60     			if(uart_rx_wr_index >= UART_RXBUF_SIZE)
000028  4618              MOV      r0,r3
00002a  8800              LDRH     r0,[r0,#0]  ; uart_rx_wr_index
00002c  2103              MOVS     r1,#3
00002e  0209              LSLS     r1,r1,#8
000030  4288              CMP      r0,r1
000032  db02              BLT      |L2.58|
;;;61     				uart_rx_wr_index = 0;
000034  2000              MOVS     r0,#0
000036  4619              MOV      r1,r3
000038  8008              STRH     r0,[r1,#0]
                  |L2.58|
;;;62     
;;;63     		   	UNLOCKREG();
00003a  2059              MOVS     r0,#0x59
00003c  490c              LDR      r1,|L2.112|
00003e  6008              STR      r0,[r1,#0]
000040  2016              MOVS     r0,#0x16
000042  6008              STR      r0,[r1,#0]
000044  2088              MOVS     r0,#0x88
000046  6008              STR      r0,[r1,#0]
;;;64     			uart_rx_cnt++;
000048  480a              LDR      r0,|L2.116|
00004a  8800              LDRH     r0,[r0,#0]  ; uart_rx_cnt
00004c  1c40              ADDS     r0,r0,#1
00004e  4909              LDR      r1,|L2.116|
000050  8008              STRH     r0,[r1,#0]
;;;65     			LOCKREG();				  
000052  2000              MOVS     r0,#0
000054  4906              LDR      r1,|L2.112|
000056  6008              STR      r0,[r1,#0]
                  |L2.88|
000058  4807              LDR      r0,|L2.120|
00005a  69c0              LDR      r0,[r0,#0x1c]         ;56
00005c  07c0              LSLS     r0,r0,#31             ;56
00005e  0fc0              LSRS     r0,r0,#31             ;56
000060  2801              CMP      r0,#1                 ;56
000062  d0d3              BEQ      |L2.12|
                  |L2.100|
;;;66     		}		
;;;67     	}
;;;68     }
000064  bd38              POP      {r3-r5,pc}
;;;69     
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      uart_rx_wr_index
                  |L2.108|
                          DCD      uart_rxbuf
                  |L2.112|
                          DCD      0x50000100
                  |L2.116|
                          DCD      uart_rx_cnt
                  |L2.120|
                          DCD      0x40050000

                          AREA ||i.get_char||, CODE, READONLY, ALIGN=2

                  get_char PROC
;;;17     
;;;18     uint8_t get_char(uint8_t *pchar)
000000  4601              MOV      r1,r0
;;;19     {
;;;20     	if(0 == uart_rx_cnt)
000002  4813              LDR      r0,|L3.80|
000004  8800              LDRH     r0,[r0,#0]  ; uart_rx_cnt
000006  2800              CMP      r0,#0
000008  d100              BNE      |L3.12|
                  |L3.10|
;;;21     		return(0);
;;;22     
;;;23     	*pchar = uart_rxbuf[uart_rx_rd_index++];
;;;24     	if(uart_rx_rd_index >= UART_RXBUF_SIZE)
;;;25     		uart_rx_rd_index = 0;
;;;26     	
;;;27     	UNLOCKREG();
;;;28     	uart_rx_cnt--;
;;;29     	LOCKREG();
;;;30     
;;;31     	return(1);
;;;32     }
00000a  4770              BX       lr
                  |L3.12|
00000c  4a11              LDR      r2,|L3.84|
00000e  8810              LDRH     r0,[r2,#0]            ;23  ; uart_rx_rd_index
000010  1c42              ADDS     r2,r0,#1              ;23
000012  4b10              LDR      r3,|L3.84|
000014  801a              STRH     r2,[r3,#0]            ;23
000016  4a10              LDR      r2,|L3.88|
000018  5c12              LDRB     r2,[r2,r0]            ;23
00001a  700a              STRB     r2,[r1,#0]            ;23
00001c  4618              MOV      r0,r3                 ;24
00001e  8800              LDRH     r0,[r0,#0]            ;24  ; uart_rx_rd_index
000020  2203              MOVS     r2,#3                 ;24
000022  0212              LSLS     r2,r2,#8              ;24
000024  4290              CMP      r0,r2                 ;24
000026  db02              BLT      |L3.46|
000028  2000              MOVS     r0,#0                 ;25
00002a  461a              MOV      r2,r3                 ;25
00002c  8010              STRH     r0,[r2,#0]            ;25
                  |L3.46|
00002e  2059              MOVS     r0,#0x59              ;27
000030  4a0a              LDR      r2,|L3.92|
000032  6010              STR      r0,[r2,#0]            ;27
000034  2016              MOVS     r0,#0x16              ;27
000036  6010              STR      r0,[r2,#0]            ;27
000038  2088              MOVS     r0,#0x88              ;27
00003a  6010              STR      r0,[r2,#0]            ;27
00003c  4804              LDR      r0,|L3.80|
00003e  8800              LDRH     r0,[r0,#0]            ;28  ; uart_rx_cnt
000040  1e40              SUBS     r0,r0,#1              ;28
000042  4a03              LDR      r2,|L3.80|
000044  8010              STRH     r0,[r2,#0]            ;28
000046  2000              MOVS     r0,#0                 ;29
000048  4a04              LDR      r2,|L3.92|
00004a  6010              STR      r0,[r2,#0]            ;29
00004c  2001              MOVS     r0,#1                 ;31
00004e  e7dc              B        |L3.10|
;;;33     
                          ENDP

                  |L3.80|
                          DCD      uart_rx_cnt
                  |L3.84|
                          DCD      uart_rx_rd_index
                  |L3.88|
                          DCD      uart_rxbuf
                  |L3.92|
                          DCD      0x50000100

                          AREA ||i.put_n_char||, CODE, READONLY, ALIGN=2

                  put_n_char PROC
;;;33     
;;;34     void put_n_char(uint8_t *buf, uint16_t n)
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;36     	EN1483;
000006  2102              MOVS     r1,#2
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       DrvGPIO_SetBit
;;;37     
;;;38     	DrvGPIO_ClrBit(PECU_CTRL_PORT, COM_LED_PIN);	// 点亮通讯指示灯
00000e  2106              MOVS     r1,#6
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       DrvGPIO_ClrBit
;;;39     
;;;40     	DrvUART_Write(UART_PORT0, buf, n);
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       DrvUART_Write
;;;41     
;;;42     	uart_tx_delay_time = 2;					// 此芯片没有移位寄存器空标志，所以需要延时保证最后一个字节通过RS485正确传输
000020  2002              MOVS     r0,#2
000022  4907              LDR      r1,|L4.64|
000024  7008              STRB     r0,[r1,#0]
;;;43     	while(uart_tx_delay_time);
000026  bf00              NOP      
                  |L4.40|
000028  4805              LDR      r0,|L4.64|
00002a  7800              LDRB     r0,[r0,#0]  ; uart_tx_delay_time
00002c  2800              CMP      r0,#0
00002e  d1fb              BNE      |L4.40|
;;;44     
;;;45     	DIS1483;
000030  2102              MOVS     r1,#2
000032  f7fffffe          BL       DrvGPIO_ClrBit
;;;46     
;;;47     	DrvGPIO_SetBit(PECU_CTRL_PORT, COM_LED_PIN);	// 灭掉通讯指示灯
000036  2106              MOVS     r1,#6
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       DrvGPIO_SetBit
;;;48     } 
00003e  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP

                  |L4.64|
                          DCD      uart_tx_delay_time

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  uart_rxbuf
                          %        768

                          AREA ||.data||, DATA, ALIGN=1

                  uart_rx_wr_index
000000  0000              DCW      0x0000
                  uart_rx_rd_index
000002  0000              DCW      0x0000
                  uart_rx_cnt
000004  0000              DCW      0x0000
                  uart_tx_delay_time
000006  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\uart.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c_0532cc9a____REV16|
#line 112 "..\\..\\ISD91XX_SDK\\CMSIS\\CM0\\CoreSupport\\core_cmInstr.h"
|__asm___6_uart_c_0532cc9a____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c_0532cc9a____REVSH|
#line 130
|__asm___6_uart_c_0532cc9a____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
