; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\pecu.o --asm_dir=..\list\ --list_dir=..\list\ --depend=..\output\pecu.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\inc -I..\..\ISD91XX_SDK\CMSIS\CM0\CoreSupport -I..\..\ISD91XX_SDK\CMSIS\CM0\DeviceSupport\Nuvoton\ISD91xx -I..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Include\Driver -I..\..\ISD91XX_SDK\NuvotonPlatform_Keil\Include -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\Nuvoton --omf_browse=..\output\pecu.crf ..\src\pecu.c]
                          THUMB

                          AREA ||i.LM4871_shutdown||, CODE, READONLY, ALIGN=1

                  LM4871_shutdown PROC
;;;555    
;;;556    static void LM4871_shutdown(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;557    {
000002  4604              MOV      r4,r0
;;;558    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d104              BNE      |L1.18|
;;;559    		DrvGPIO_SetBit(PECU_CTRL_PORT, SHUTDOWN_PIN);			// 高电平，shutdown		------	ON
000008  2105              MOVS     r1,#5
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       DrvGPIO_SetBit
000010  e003              B        |L1.26|
                  |L1.18|
;;;560    	else
;;;561    		DrvGPIO_ClrBit(PECU_CTRL_PORT, SHUTDOWN_PIN);			// 低电平，正常工作		------	OFF	
000012  2105              MOVS     r1,#5
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       DrvGPIO_ClrBit
                  |L1.26|
;;;562    }
00001a  bd10              POP      {r4,pc}
;;;563    
                          ENDP


                          AREA ||i.PECU_port_init||, CODE, READONLY, ALIGN=1

                  PECU_port_init PROC
;;;620    
;;;621    void PECU_port_init(void)
000000  b510              PUSH     {r4,lr}
;;;622    {
;;;623    	DrvGPIO_Open(PECU_CTRL_PORT, ALARM_KEY_PIN, IO_INPUT);			// 设置报警按键ALARM_KEY引脚为输入
000002  2200              MOVS     r2,#0
000004  4611              MOV      r1,r2
000006  4610              MOV      r0,r2
000008  f7fffffe          BL       DrvGPIO_Open
;;;624    	DrvGPIO_SetBit(PECU_CTRL_PORT, ALARM_KEY_PIN);					// 设置报警按键ALARM_KEY引脚电平为高
00000c  2100              MOVS     r1,#0
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       DrvGPIO_SetBit
;;;625    
;;;626    	DrvGPIO_Open(PECU_CTRL_PORT, PTT_CHK_PIN, IO_INPUT);			// 设置报警按键PTT_CHK引脚为输入
000014  2200              MOVS     r2,#0
000016  2101              MOVS     r1,#1
000018  4610              MOV      r0,r2
00001a  f7fffffe          BL       DrvGPIO_Open
;;;627    	DrvGPIO_SetBit(PECU_CTRL_PORT, PTT_CHK_PIN);					// 设置报警按键PTT_CHK引脚电平为高
00001e  2101              MOVS     r1,#1
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       DrvGPIO_SetBit
;;;628    
;;;629    //	DrvGPIO_Open(PECU_CTRL_PORT, RESET_KEY_PIN, IO_INPUT);			// 设置报警按键PTT_CHK引脚为输入					// 2014-09-18修改，for南宁地铁1号线项目
;;;630    //	DrvGPIO_SetBit(PECU_CTRL_PORT, RESET_KEY_PIN);					// 设置报警按键PTT_CHK引脚电平为高					// 2014-09-18修改，for南宁地铁1号线项目
;;;631    
;;;632    	DrvGPIO_Open(PECU_CTRL_PORT, NOISE_CTRL_PIN, IO_OUTPUT);			// 设置噪检控制引脚NOISE_CTRL_PIN引脚为输输出		// 2014-09-18修改，for南宁地铁1号线项目
000026  2201              MOVS     r2,#1
000028  2107              MOVS     r1,#7
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DrvGPIO_Open
;;;633    	DrvGPIO_SetBit(PECU_CTRL_PORT, NOISE_CTRL_PIN);					// 设置噪检控制引脚NOISE_CTRL_PIN引脚电平为高		// 2014-09-18修改，for南宁地铁1号线项目，缺省状态为噪检输出
000030  2107              MOVS     r1,#7
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       DrvGPIO_SetBit
;;;634    
;;;635    
;;;636    	DrvGPIO_Open(PECU_CTRL_PORT, MIC_CTRL_PIN, IO_OUTPUT);			// 设置MIC音频输出控制引脚MIC_CTRL_PIN为输出
000038  2201              MOVS     r2,#1
00003a  2103              MOVS     r1,#3
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       DrvGPIO_Open
;;;637    	DrvGPIO_SetBit(PECU_CTRL_PORT, MIC_CTRL_PIN);				 	// 设置MIC音频输出控制引脚MIC_CTRL_PIN电平为高
000042  2103              MOVS     r1,#3
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       DrvGPIO_SetBit
;;;638    
;;;639    	DrvGPIO_Open(PECU_CTRL_PORT, SPK_CTRL_PIN, IO_OUTPUT);			// 设置SPK音频输入控制引脚SPK_CTRL_PIN为输出
00004a  2201              MOVS     r2,#1
00004c  2104              MOVS     r1,#4
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       DrvGPIO_Open
;;;640    	DrvGPIO_SetBit(PECU_CTRL_PORT, SPK_CTRL_PIN);				 	// 设置SPK音频输入控制引脚SPK_CTRL_PIN电平为高
000054  2104              MOVS     r1,#4
000056  2000              MOVS     r0,#0
000058  f7fffffe          BL       DrvGPIO_SetBit
;;;641    //	DrvGPIO_ClrBit(PECU_CTRL_PORT, SPK_CTRL_PIN);
;;;642    
;;;643    	DrvGPIO_Open(PECU_CTRL_PORT, SHUTDOWN_PIN, IO_OUTPUT);			// 设置功放静音控制引脚SHUTDOWN_PIN为输出
00005c  2201              MOVS     r2,#1
00005e  2105              MOVS     r1,#5
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       DrvGPIO_Open
;;;644    	DrvGPIO_SetBit(PECU_CTRL_PORT, SHUTDOWN_PIN);				 	// 设置功放静音控制引脚SHUTDOWN_PIN电平为高
000066  2105              MOVS     r1,#5
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       DrvGPIO_SetBit
;;;645    
;;;646    	DrvGPIO_Open(PECU_CTRL_PORT, COM_LED_PIN, IO_OUTPUT);			// 设置RS485 通信指示灯引脚COM_LED_PIN为输出
00006e  2201              MOVS     r2,#1
000070  2106              MOVS     r1,#6
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       DrvGPIO_Open
;;;647    	DrvGPIO_ClrBit(PECU_CTRL_PORT, COM_LED_PIN);				 	// 设置RS485 通信指示灯引脚COM_LED_PIN电平为低
000078  2106              MOVS     r1,#6
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       DrvGPIO_ClrBit
;;;648    
;;;649    	DrvGPIO_Open(PECU_ADDR_PORT, ADDR0_PIN, IO_INPUT);				// 设置地址ADDR0引脚为输入
000080  2200              MOVS     r2,#0
000082  2104              MOVS     r1,#4
000084  2001              MOVS     r0,#1
000086  f7fffffe          BL       DrvGPIO_Open
;;;650    	DrvGPIO_SetBit(PECU_ADDR_PORT, ADDR0_PIN);						// 设置报地址ADDR0引脚电平为高
00008a  2104              MOVS     r1,#4
00008c  2001              MOVS     r0,#1
00008e  f7fffffe          BL       DrvGPIO_SetBit
;;;651    
;;;652    	DrvGPIO_Open(PECU_ADDR_PORT, ADDR1_PIN, IO_INPUT);				// 设置地址ADDR1引脚为输入
000092  2200              MOVS     r2,#0
000094  2105              MOVS     r1,#5
000096  2001              MOVS     r0,#1
000098  f7fffffe          BL       DrvGPIO_Open
;;;653    	DrvGPIO_SetBit(PECU_ADDR_PORT, ADDR1_PIN);						// 设置报地址ADDR1引脚电平为高
00009c  2105              MOVS     r1,#5
00009e  2001              MOVS     r0,#1
0000a0  f7fffffe          BL       DrvGPIO_SetBit
;;;654    
;;;655    	DrvGPIO_Open(PECU_ADDR_PORT, ADDR2_PIN, IO_INPUT);				// 设置地址ADDR2引脚为输入
0000a4  2200              MOVS     r2,#0
0000a6  2106              MOVS     r1,#6
0000a8  2001              MOVS     r0,#1
0000aa  f7fffffe          BL       DrvGPIO_Open
;;;656    	DrvGPIO_SetBit(PECU_ADDR_PORT, ADDR2_PIN);						// 设置报地址ADDR2引脚电平为高
0000ae  2106              MOVS     r1,#6
0000b0  2001              MOVS     r0,#1
0000b2  f7fffffe          BL       DrvGPIO_SetBit
;;;657    
;;;658    	DrvGPIO_Open(PECU_ADDR_PORT, ADDR3_PIN, IO_INPUT);				// 设置地址ADDR3引脚为输入
0000b6  2200              MOVS     r2,#0
0000b8  2107              MOVS     r1,#7
0000ba  2001              MOVS     r0,#1
0000bc  f7fffffe          BL       DrvGPIO_Open
;;;659    	DrvGPIO_SetBit(PECU_ADDR_PORT, ADDR3_PIN);						// 设置报地址ADDR3引脚电平为高
0000c0  2107              MOVS     r1,#7
0000c2  2001              MOVS     r0,#1
0000c4  f7fffffe          BL       DrvGPIO_SetBit
;;;660    
;;;661    	DrvGPIO_Open(PECU_LED_PORT, ALARM_LED_PIN, IO_OUTPUT);			// 设置报警指示灯引脚ALARM_LED_PIN为输出
0000c8  2201              MOVS     r2,#1
0000ca  2100              MOVS     r1,#0
0000cc  4610              MOV      r0,r2
0000ce  f7fffffe          BL       DrvGPIO_Open
;;;662    //	DrvGPIO_ClrBit(PECU_LED_PORT, ALARM_LED_PIN);					// 2014-09-18修改，for南宁地铁1号线项目	// 设置报警指示灯引脚ALARM_LED_PIN电平为低
;;;663    	DrvGPIO_SetBit(PECU_LED_PORT, ALARM_LED_PIN);					// 2014-09-18修改，for南宁地铁1号线项目
0000d2  2100              MOVS     r1,#0
0000d4  2001              MOVS     r0,#1
0000d6  f7fffffe          BL       DrvGPIO_SetBit
;;;664    
;;;665    	DrvGPIO_Open(PECU_LED_PORT, LISTEN_LED_PIN, IO_OUTPUT);			// 设置报警指示灯引脚LISTEN_LED_PIN为输出
0000da  2201              MOVS     r2,#1
0000dc  4611              MOV      r1,r2
0000de  4610              MOV      r0,r2
0000e0  f7fffffe          BL       DrvGPIO_Open
;;;666    //	DrvGPIO_ClrBit(PECU_LED_PORT, LISTEN_LED_PIN);					// 2014-04-09修改		// 设置报警指示灯引脚LISTEN_LED_PIN电平为低		
;;;667    	DrvGPIO_SetBit(PECU_LED_PORT, LISTEN_LED_PIN);					// 2014-04-09修改
0000e4  2101              MOVS     r1,#1
0000e6  4608              MOV      r0,r1
0000e8  f7fffffe          BL       DrvGPIO_SetBit
;;;668     	
;;;669    	DrvGPIO_Open(PECU_LED_PORT, SPEAK_LED_PIN, IO_OUTPUT);			// 设置报警指示灯引脚SPEAK_LED_PIN为输出
0000ec  2201              MOVS     r2,#1
0000ee  2102              MOVS     r1,#2
0000f0  4610              MOV      r0,r2
0000f2  f7fffffe          BL       DrvGPIO_Open
;;;670    //	DrvGPIO_ClrBit(PECU_LED_PORT, SPEAK_LED_PIN);					// 2014-04-09修改		// 设置报警指示灯引脚SPEAK_LED_PIN电平为低
;;;671    	DrvGPIO_SetBit(PECU_LED_PORT, SPEAK_LED_PIN);					// 2014-04-09修改
0000f6  2102              MOVS     r1,#2
0000f8  2001              MOVS     r0,#1
0000fa  f7fffffe          BL       DrvGPIO_SetBit
;;;672    
;;;673    	DrvGPIO_Open(PECU_LED_PORT, BUSY_LED_PIN, IO_OUTPUT);			// 设置报警指示灯引脚BUSY_LED_PIN为输出
0000fe  2201              MOVS     r2,#1
000100  2103              MOVS     r1,#3
000102  4610              MOV      r0,r2
000104  f7fffffe          BL       DrvGPIO_Open
;;;674    //	DrvGPIO_ClrBit(PECU_LED_PORT, BUSY_LED_PIN);					// 2014-04-09修改		// 设置报警指示灯引脚BUSY_LED_PIN电平为低
;;;675    	DrvGPIO_SetBit(PECU_LED_PORT, BUSY_LED_PIN);					// 2014-04-09修改
000108  2103              MOVS     r1,#3
00010a  2001              MOVS     r0,#1
00010c  f7fffffe          BL       DrvGPIO_SetBit
;;;676    
;;;677    	mic_output(OFF);												// mic输出音频关掉
000110  2000              MOVS     r0,#0
000112  f7fffffe          BL       mic_output
;;;678    	spk_input(OFF);													// spk输入音频关掉
000116  2000              MOVS     r0,#0
000118  f7fffffe          BL       spk_input
;;;679    	LM4871_shutdown(ON);											// 功放静音，shutdown
00011c  2001              MOVS     r0,#1
00011e  f7fffffe          BL       LM4871_shutdown
;;;680    }
000122  bd10              POP      {r4,pc}
;;;681    
                          ENDP


                          AREA ||i.PECU_run||, CODE, READONLY, ALIGN=2

                  PECU_run PROC
;;;60     
;;;61     void PECU_run(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63     	if(pecu_com_timeout >= PECU_COM_TIMEOUT)
000002  4807              LDR      r0,|L3.32|
000004  8800              LDRH     r0,[r0,#0]  ; pecu_com_timeout
000006  21ff              MOVS     r1,#0xff
000008  31f5              ADDS     r1,r1,#0xf5
00000a  4288              CMP      r0,r1
00000c  db02              BLT      |L3.20|
;;;64     		com_led_flash(100);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       com_led_flash
                  |L3.20|
;;;65     
;;;66     	prc_rx_data(); 	
000014  f7fffffe          BL       prc_rx_data
;;;67     
;;;68     	pecu_run_status();
000018  f7fffffe          BL       pecu_run_status
;;;69     }
00001c  bd10              POP      {r4,pc}
;;;70     
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      pecu_com_timeout

                          AREA ||i.alarm_led||, CODE, READONLY, ALIGN=1

                  alarm_led PROC
;;;609    
;;;610    static void alarm_led(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;611    {
000002  4604              MOV      r4,r0
;;;612    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d103              BNE      |L4.16|
;;;613    		//DrvGPIO_SetBit(PECU_LED_PORT, ALARM_LED_PIN);			// 2014-09-18修改，for南宁地铁1号线项目
;;;614    		DrvGPIO_ClrBit(PECU_LED_PORT, ALARM_LED_PIN);
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       DrvGPIO_ClrBit
00000e  e003              B        |L4.24|
                  |L4.16|
;;;615    	else
;;;616    		//DrvGPIO_ClrBit(PECU_LED_PORT, ALARM_LED_PIN);			// 2014-09-18修改，for南宁地铁1号线项目
;;;617    		DrvGPIO_SetBit(PECU_LED_PORT, ALARM_LED_PIN);
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       DrvGPIO_SetBit
                  |L4.24|
;;;618    }
000018  bd10              POP      {r4,pc}
;;;619    
                          ENDP


                          AREA ||i.alarm_led_flash||, CODE, READONLY, ALIGN=2

                  alarm_led_flash PROC
;;;512    
;;;513    static void alarm_led_flash(uint16_t flash_interval)
000000  b510              PUSH     {r4,lr}
;;;514    {
000002  4604              MOV      r4,r0
;;;515    	if(alarm_led_flash_interval < flash_interval) 
000004  480f              LDR      r0,|L5.68|
000006  8800              LDRH     r0,[r0,#0]  ; alarm_led_flash_interval
000008  42a0              CMP      r0,r4
00000a  da04              BGE      |L5.22|
;;;516    		DrvGPIO_SetBit(PECU_LED_PORT, ALARM_LED_PIN);
00000c  2100              MOVS     r1,#0
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       DrvGPIO_SetBit
000014  e015              B        |L5.66|
                  |L5.22|
;;;517    	else if((alarm_led_flash_interval >= flash_interval) && (alarm_led_flash_interval < (flash_interval * 2)))
000016  480b              LDR      r0,|L5.68|
000018  8800              LDRH     r0,[r0,#0]  ; alarm_led_flash_interval
00001a  42a0              CMP      r0,r4
00001c  db09              BLT      |L5.50|
00001e  0060              LSLS     r0,r4,#1
000020  4908              LDR      r1,|L5.68|
000022  8809              LDRH     r1,[r1,#0]  ; alarm_led_flash_interval
000024  4288              CMP      r0,r1
000026  dd04              BLE      |L5.50|
;;;518    		DrvGPIO_ClrBit(PECU_LED_PORT, ALARM_LED_PIN);
000028  2100              MOVS     r1,#0
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       DrvGPIO_ClrBit
000030  e007              B        |L5.66|
                  |L5.50|
;;;519    	else if(alarm_led_flash_interval >= (flash_interval * 2))
000032  0060              LSLS     r0,r4,#1
000034  4903              LDR      r1,|L5.68|
000036  8809              LDRH     r1,[r1,#0]  ; alarm_led_flash_interval
000038  4288              CMP      r0,r1
00003a  dc02              BGT      |L5.66|
;;;520    		alarm_led_flash_interval = 0;	
00003c  2000              MOVS     r0,#0
00003e  4901              LDR      r1,|L5.68|
000040  8008              STRH     r0,[r1,#0]
                  |L5.66|
;;;521    }
000042  bd10              POP      {r4,pc}
;;;522    
                          ENDP

                  |L5.68|
                          DCD      alarm_led_flash_interval

                          AREA ||i.busy_led||, CODE, READONLY, ALIGN=1

                  busy_led PROC
;;;579    
;;;580    static void busy_led(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;581    {
000002  4604              MOV      r4,r0
;;;582    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d103              BNE      |L6.16|
;;;583    		//DrvGPIO_SetBit(PECU_LED_PORT, BUSY_LED_PIN);			// 2014-04-09修改
;;;584    		DrvGPIO_ClrBit(PECU_LED_PORT, BUSY_LED_PIN);
000008  2103              MOVS     r1,#3
00000a  f7fffffe          BL       DrvGPIO_ClrBit
00000e  e003              B        |L6.24|
                  |L6.16|
;;;585    	else
;;;586    		//DrvGPIO_ClrBit(PECU_LED_PORT, BUSY_LED_PIN);			// 2014-04-09修改
;;;587    		DrvGPIO_SetBit(PECU_LED_PORT, BUSY_LED_PIN);
000010  2103              MOVS     r1,#3
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       DrvGPIO_SetBit
                  |L6.24|
;;;588    }
000018  bd10              POP      {r4,pc}
;;;589    
                          ENDP


                          AREA ||i.busy_led_flash||, CODE, READONLY, ALIGN=2

                  busy_led_flash PROC
;;;522    
;;;523    static void busy_led_flash(uint16_t flash_interval)
000000  b510              PUSH     {r4,lr}
;;;524    {
000002  4604              MOV      r4,r0
;;;525    	if(busy_led_flash_interval < flash_interval) 
000004  480f              LDR      r0,|L7.68|
000006  8800              LDRH     r0,[r0,#0]  ; busy_led_flash_interval
000008  42a0              CMP      r0,r4
00000a  da04              BGE      |L7.22|
;;;526    		DrvGPIO_SetBit(PECU_LED_PORT, BUSY_LED_PIN);
00000c  2103              MOVS     r1,#3
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       DrvGPIO_SetBit
000014  e015              B        |L7.66|
                  |L7.22|
;;;527    	else if((busy_led_flash_interval >= flash_interval) && (busy_led_flash_interval < (flash_interval * 2)))
000016  480b              LDR      r0,|L7.68|
000018  8800              LDRH     r0,[r0,#0]  ; busy_led_flash_interval
00001a  42a0              CMP      r0,r4
00001c  db09              BLT      |L7.50|
00001e  0060              LSLS     r0,r4,#1
000020  4908              LDR      r1,|L7.68|
000022  8809              LDRH     r1,[r1,#0]  ; busy_led_flash_interval
000024  4288              CMP      r0,r1
000026  dd04              BLE      |L7.50|
;;;528    		DrvGPIO_ClrBit(PECU_LED_PORT, BUSY_LED_PIN);
000028  2103              MOVS     r1,#3
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       DrvGPIO_ClrBit
000030  e007              B        |L7.66|
                  |L7.50|
;;;529    	else if(busy_led_flash_interval >= (flash_interval * 2))
000032  0060              LSLS     r0,r4,#1
000034  4903              LDR      r1,|L7.68|
000036  8809              LDRH     r1,[r1,#0]  ; busy_led_flash_interval
000038  4288              CMP      r0,r1
00003a  dc02              BGT      |L7.66|
;;;530    		busy_led_flash_interval = 0;
00003c  2000              MOVS     r0,#0
00003e  4901              LDR      r1,|L7.68|
000040  8008              STRH     r0,[r1,#0]
                  |L7.66|
;;;531    }
000042  bd10              POP      {r4,pc}
;;;532    
                          ENDP

                  |L7.68|
                          DCD      busy_led_flash_interval

                          AREA ||i.chk_alarm_key||, CODE, READONLY, ALIGN=2

                  chk_alarm_key PROC
;;;241    
;;;242    static uint8_t chk_alarm_key(void)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244    	static uint8_t old_alarm_key = 1;	// 紧急报警器报警按键原状态为1
;;;245    	uint8_t now_alarm_key;
;;;246    	uint8_t tmp_alarm_key;
;;;247    	uint16_t i;
;;;248    
;;;249    	tmp_alarm_key = DrvGPIO_GetBit(PECU_CTRL_PORT, ALARM_KEY_PIN);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       DrvGPIO_GetBit
00000a  b2c6              UXTB     r6,r0
;;;250    	for(i = 0; i < 2000; i++);			// 延时去抖动
00000c  2500              MOVS     r5,#0
00000e  e001              B        |L8.20|
                  |L8.16|
000010  1c68              ADDS     r0,r5,#1
000012  b285              UXTH     r5,r0
                  |L8.20|
000014  207d              MOVS     r0,#0x7d
000016  0100              LSLS     r0,r0,#4
000018  4285              CMP      r5,r0
00001a  dbf9              BLT      |L8.16|
;;;251    	now_alarm_key = DrvGPIO_GetBit(PECU_CTRL_PORT, ALARM_KEY_PIN);
00001c  2100              MOVS     r1,#0
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       DrvGPIO_GetBit
000024  b2c4              UXTB     r4,r0
;;;252    	if(tmp_alarm_key != now_alarm_key)
000026  42a6              CMP      r6,r4
000028  d001              BEQ      |L8.46|
;;;253    		return(0);						// 读取报警按键引脚2次，如果不认为是干扰，无效退出
00002a  2000              MOVS     r0,#0
                  |L8.44|
;;;254    
;;;255    	if((1 == old_alarm_key) && (0 == now_alarm_key))	// 检测报警按键下跳沿产生报警触发
;;;256    	{
;;;257    		old_alarm_key = now_alarm_key;
;;;258    		return(1);
;;;259    	}
;;;260    	
;;;261    	old_alarm_key = now_alarm_key;
;;;262    	return(0);		
;;;263    }
00002c  bd70              POP      {r4-r6,pc}
                  |L8.46|
00002e  4807              LDR      r0,|L8.76|
000030  7800              LDRB     r0,[r0,#0]            ;255  ; old_alarm_key
000032  2801              CMP      r0,#1                 ;255
000034  d105              BNE      |L8.66|
000036  2c00              CMP      r4,#0                 ;255
000038  d103              BNE      |L8.66|
00003a  4804              LDR      r0,|L8.76|
00003c  7004              STRB     r4,[r0,#0]            ;257
00003e  2001              MOVS     r0,#1                 ;258
000040  e7f4              B        |L8.44|
                  |L8.66|
000042  4802              LDR      r0,|L8.76|
000044  7004              STRB     r4,[r0,#0]            ;261
000046  2000              MOVS     r0,#0                 ;262
000048  e7f0              B        |L8.44|
;;;264    
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      old_alarm_key

                          AREA ||i.chk_ptt_key||, CODE, READONLY, ALIGN=1

                  chk_ptt_key PROC
;;;264    
;;;265    static uint8_t chk_ptt_key(void)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
;;;267    	uint8_t now_ptt_key;
;;;268    	uint8_t tmp_ptt_key;
;;;269    	uint16_t i;
;;;270    
;;;271    	tmp_ptt_key = DrvGPIO_GetBit(PECU_CTRL_PORT, PTT_CHK_PIN);
000002  2101              MOVS     r1,#1
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       DrvGPIO_GetBit
00000a  b2c6              UXTB     r6,r0
;;;272    	for(i = 0; i < 2000; i++);			// 延时去抖动
00000c  2500              MOVS     r5,#0
00000e  e001              B        |L9.20|
                  |L9.16|
000010  1c68              ADDS     r0,r5,#1
000012  b285              UXTH     r5,r0
                  |L9.20|
000014  207d              MOVS     r0,#0x7d
000016  0100              LSLS     r0,r0,#4
000018  4285              CMP      r5,r0
00001a  dbf9              BLT      |L9.16|
;;;273    	now_ptt_key = DrvGPIO_GetBit(PECU_CTRL_PORT, PTT_CHK_PIN);
00001c  2101              MOVS     r1,#1
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       DrvGPIO_GetBit
000024  b2c4              UXTB     r4,r0
;;;274    	if(tmp_ptt_key != now_ptt_key)		// 读取PTT按键引脚2次，如果不认为是干扰，无效退出
000026  42a6              CMP      r6,r4
000028  d001              BEQ      |L9.46|
;;;275    		return(0xff);
00002a  20ff              MOVS     r0,#0xff
                  |L9.44|
;;;276    
;;;277    	if(0 == now_ptt_key)				// PTT键按下
;;;278    		return(1);
;;;279    	else if(1 == now_ptt_key)			// PTT键抬起
;;;280    		return(0);
;;;281    
;;;282    	return(0xff);
;;;283    }
00002c  bd70              POP      {r4-r6,pc}
                  |L9.46|
00002e  2c00              CMP      r4,#0                 ;277
000030  d101              BNE      |L9.54|
000032  2001              MOVS     r0,#1                 ;278
000034  e7fa              B        |L9.44|
                  |L9.54|
000036  2c01              CMP      r4,#1                 ;279
000038  d101              BNE      |L9.62|
00003a  2000              MOVS     r0,#0                 ;280
00003c  e7f6              B        |L9.44|
                  |L9.62|
00003e  20ff              MOVS     r0,#0xff              ;282
000040  e7f4              B        |L9.44|
;;;284    
                          ENDP


                          AREA ||i.chksum||, CODE, READONLY, ALIGN=1

                  chksum PROC
;;;681    
;;;682    uint8_t chksum(uint8_t *buf, uint16_t n)
000000  b510              PUSH     {r4,lr}
;;;683    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;684    	uint16_t i;
;;;685    	uint8_t tmp = 0;
000006  2400              MOVS     r4,#0
;;;686    
;;;687    	for(i = 0; i < n; i++)
000008  2100              MOVS     r1,#0
00000a  e004              B        |L10.22|
                  |L10.12|
;;;688    		tmp += buf[i];
00000c  5c50              LDRB     r0,[r2,r1]
00000e  1900              ADDS     r0,r0,r4
000010  b2c4              UXTB     r4,r0
000012  1c48              ADDS     r0,r1,#1              ;687
000014  b281              UXTH     r1,r0                 ;687
                  |L10.22|
000016  4299              CMP      r1,r3                 ;687
000018  dbf8              BLT      |L10.12|
;;;689    
;;;690    	return((0x55 - tmp));	
00001a  2055              MOVS     r0,#0x55
00001c  1b00              SUBS     r0,r0,r4
00001e  b2c0              UXTB     r0,r0
;;;691    }
000020  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.com_led_flash||, CODE, READONLY, ALIGN=2

                  com_led_flash PROC
;;;532    
;;;533    static void com_led_flash(uint16_t flash_interval)
000000  b510              PUSH     {r4,lr}
;;;534    {
000002  4604              MOV      r4,r0
;;;535    	if(com_led_flash_interval < flash_interval)
000004  480f              LDR      r0,|L11.68|
000006  8800              LDRH     r0,[r0,#0]  ; com_led_flash_interval
000008  42a0              CMP      r0,r4
00000a  da04              BGE      |L11.22|
;;;536    		DrvGPIO_ClrBit(PECU_CTRL_PORT, COM_LED_PIN); 
00000c  2106              MOVS     r1,#6
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       DrvGPIO_ClrBit
000014  e015              B        |L11.66|
                  |L11.22|
;;;537    		//DrvGPIO_SetBit(PECU_CTRL_PORT, COM_LED_PIN);
;;;538    	else if((com_led_flash_interval >= flash_interval) && (com_led_flash_interval < (flash_interval * 2)))
000016  480b              LDR      r0,|L11.68|
000018  8800              LDRH     r0,[r0,#0]  ; com_led_flash_interval
00001a  42a0              CMP      r0,r4
00001c  db09              BLT      |L11.50|
00001e  0060              LSLS     r0,r4,#1
000020  4908              LDR      r1,|L11.68|
000022  8809              LDRH     r1,[r1,#0]  ; com_led_flash_interval
000024  4288              CMP      r0,r1
000026  dd04              BLE      |L11.50|
;;;539    		DrvGPIO_SetBit(PECU_CTRL_PORT, COM_LED_PIN);
000028  2106              MOVS     r1,#6
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       DrvGPIO_SetBit
000030  e007              B        |L11.66|
                  |L11.50|
;;;540    		//DrvGPIO_ClrBit(PECU_CTRL_PORT, COM_LED_PIN);		
;;;541    	else if(com_led_flash_interval >= (flash_interval * 2))
000032  0060              LSLS     r0,r4,#1
000034  4903              LDR      r1,|L11.68|
000036  8809              LDRH     r1,[r1,#0]  ; com_led_flash_interval
000038  4288              CMP      r0,r1
00003a  dc02              BGT      |L11.66|
;;;542    		com_led_flash_interval = 0;	
00003c  2000              MOVS     r0,#0
00003e  4901              LDR      r1,|L11.68|
000040  8008              STRH     r0,[r1,#0]
                  |L11.66|
;;;543    }
000042  bd10              POP      {r4,pc}
;;;544    
                          ENDP

                  |L11.68|
                          DCD      com_led_flash_interval

                          AREA ||i.get_addr||, CODE, READONLY, ALIGN=2

                  get_addr PROC
;;;309    
;;;310    uint8_t get_addr(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;311    {
;;;312    	uint16_t i, j;
;;;313    	uint8_t tmpaddr = 0x00;			// 0xf8;								// 2014-10-23修改
000002  2400              MOVS     r4,#0
;;;314    	uint8_t dev_addr = 7; 
000004  2707              MOVS     r7,#7
;;;315    	
;;;316    	for(i = 0; i < 0xffff; i++)
000006  2500              MOVS     r5,#0
000008  e007              B        |L12.26|
                  |L12.10|
;;;317    		for(j = 0; j < 0xff; j++);
00000a  2600              MOVS     r6,#0
00000c  e001              B        |L12.18|
                  |L12.14|
00000e  1c70              ADDS     r0,r6,#1
000010  b286              UXTH     r6,r0
                  |L12.18|
000012  2eff              CMP      r6,#0xff
000014  dbfb              BLT      |L12.14|
000016  1c68              ADDS     r0,r5,#1              ;316
000018  b285              UXTH     r5,r0                 ;316
                  |L12.26|
00001a  4812              LDR      r0,|L12.100|
00001c  4285              CMP      r5,r0                 ;316
00001e  dbf4              BLT      |L12.10|
;;;318    	
;;;319    
;;;320    	tmpaddr |= (DrvGPIO_GetBit(PECU_ADDR_PORT, ADDR0_PIN) & 0x07);					
000020  2104              MOVS     r1,#4
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       DrvGPIO_GetBit
000028  0740              LSLS     r0,r0,#29
00002a  0f40              LSRS     r0,r0,#29
00002c  4304              ORRS     r4,r4,r0
;;;321    	tmpaddr |= ((DrvGPIO_GetBit(PECU_ADDR_PORT, ADDR1_PIN) << 1) & 0x07);
00002e  2105              MOVS     r1,#5
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       DrvGPIO_GetBit
000036  0780              LSLS     r0,r0,#30
000038  0f40              LSRS     r0,r0,#29
00003a  4304              ORRS     r4,r4,r0
;;;322    	tmpaddr |= ((DrvGPIO_GetBit(PECU_ADDR_PORT, ADDR2_PIN) << 2) & 0x07);
00003c  2106              MOVS     r1,#6
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       DrvGPIO_GetBit
000044  07c0              LSLS     r0,r0,#31
000046  0f40              LSRS     r0,r0,#29
000048  4304              ORRS     r4,r4,r0
;;;323    	//tmpaddr |= (DrvGPIO_GetBit(PECU_ADDR_PORT, ADDR3_PIN) << 3);
;;;324    
;;;325    	// 2014-11-02修改，1、6短接为110，地址为1；2、7短接为101，地址为2；3、8短接为011，地址为3
;;;326    	if(6 == tmpaddr)
00004a  2c06              CMP      r4,#6
00004c  d101              BNE      |L12.82|
;;;327    		dev_addr = 1;
00004e  2701              MOVS     r7,#1
000050  e006              B        |L12.96|
                  |L12.82|
;;;328    	else if(5 == tmpaddr)
000052  2c05              CMP      r4,#5
000054  d101              BNE      |L12.90|
;;;329    		dev_addr = 2;
000056  2702              MOVS     r7,#2
000058  e002              B        |L12.96|
                  |L12.90|
;;;330    	else if(3 == tmpaddr)
00005a  2c03              CMP      r4,#3
00005c  d100              BNE      |L12.96|
;;;331    		dev_addr = 3;
00005e  2703              MOVS     r7,#3
                  |L12.96|
;;;332    	
;;;333     	return(dev_addr);  
000060  4638              MOV      r0,r7
;;;334    	
;;;335    	// return(tmpaddr + 1);			// 2014-11-02修改		// return((~tmpaddr) + 1);					// 2014-10-23修改
;;;336    	
;;;337    	//return(1);	
;;;338    }
000062  bdf8              POP      {r3-r7,pc}
;;;339    
                          ENDP

                  |L12.100|
                          DCD      0x0000ffff

                          AREA ||i.listen_led||, CODE, READONLY, ALIGN=1

                  listen_led PROC
;;;599    
;;;600    static void listen_led(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;601    {
000002  4604              MOV      r4,r0
;;;602    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d104              BNE      |L13.18|
;;;603    		//DrvGPIO_SetBit(PECU_LED_PORT, LISTEN_LED_PIN);		// 2014-04-09修改
;;;604    		DrvGPIO_ClrBit(PECU_LED_PORT, LISTEN_LED_PIN);
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       DrvGPIO_ClrBit
000010  e003              B        |L13.26|
                  |L13.18|
;;;605    	else
;;;606    		//DrvGPIO_ClrBit(PECU_LED_PORT, LISTEN_LED_PIN);		// 2014-04-09修改
;;;607    		DrvGPIO_SetBit(PECU_LED_PORT, LISTEN_LED_PIN);
000012  2101              MOVS     r1,#1
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       DrvGPIO_SetBit
                  |L13.26|
;;;608    }
00001a  bd10              POP      {r4,pc}
;;;609    
                          ENDP


                          AREA ||i.mic_output||, CODE, READONLY, ALIGN=1

                  mic_output PROC
;;;571    
;;;572    static void mic_output(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;573    {
000002  4604              MOV      r4,r0
;;;574    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d104              BNE      |L14.18|
;;;575    		DrvGPIO_ClrBit(PECU_CTRL_PORT, MIC_CTRL_PIN);			// 低电平，继电器吸合，MIC音频输出
000008  2103              MOVS     r1,#3
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       DrvGPIO_ClrBit
000010  e003              B        |L14.26|
                  |L14.18|
;;;576    	else
;;;577    		DrvGPIO_SetBit(PECU_CTRL_PORT, MIC_CTRL_PIN);			// 高电平，继电器断开	
000012  2103              MOVS     r1,#3
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       DrvGPIO_SetBit
                  |L14.26|
;;;578    }
00001a  bd10              POP      {r4,pc}
;;;579    
                          ENDP


                          AREA ||i.noise_ctrl_sel||, CODE, READONLY, ALIGN=1

                  noise_ctrl_sel PROC
;;;547    */
;;;548    static void noise_ctrl_sel(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;549    {
000002  4604              MOV      r4,r0
;;;550    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d104              BNE      |L15.18|
;;;551    		DrvGPIO_SetBit(PECU_CTRL_PORT, NOISE_CTRL_PIN);			// NOISE_CTRL引脚为高电平，噪检功能被选择，报警开关量断开
000008  2107              MOVS     r1,#7
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       DrvGPIO_SetBit
000010  e003              B        |L15.26|
                  |L15.18|
;;;552    	else
;;;553    		DrvGPIO_ClrBit(PECU_CTRL_PORT, NOISE_CTRL_PIN);			// NOISE_CTRL引脚为低电平，噪检功能被关闭，报警开关量闭合
000012  2107              MOVS     r1,#7
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       DrvGPIO_ClrBit
                  |L15.26|
;;;554    }		 
00001a  bd10              POP      {r4,pc}
;;;555    
                          ENDP


                          AREA ||i.pecu_run_status||, CODE, READONLY, ALIGN=2

                  pecu_run_status PROC
;;;70     
;;;71     static void pecu_run_status(void)
000000  b510              PUSH     {r4,lr}
;;;72     {
;;;73     	switch(pecu_status)
000002  487f              LDR      r0,|L16.512|
000004  7800              LDRB     r0,[r0,#0]  ; pecu_status
000006  2800              CMP      r0,#0
000008  d006              BEQ      |L16.24|
00000a  2801              CMP      r0,#1
00000c  d02d              BEQ      |L16.106|
00000e  2802              CMP      r0,#2
000010  d06a              BEQ      |L16.232|
000012  2803              CMP      r0,#3
000014  d128              BNE      |L16.104|
000016  e0b8              B        |L16.394|
                  |L16.24|
;;;74     	{
;;;75     	case PECU_IDLE:							// 空闲状态
;;;76     		mic_output(OFF);				    // 关闭MIC音频输出
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       mic_output
;;;77     		spk_input(OFF);						// 关闭SPK音频输入
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       spk_input
;;;78     		LM4871_shutdown(ON);				// 静音
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       LM4871_shutdown
;;;79     
;;;80     		noise_ctrl_sel(ON);					// 空闲时即报警键没有被按下，选择噪检功能，报警开关量断开；2014-09-18修改，for南宁地铁1号线
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       noise_ctrl_sel
;;;81     
;;;82     		alarm_led(OFF);						// 关闭所有对讲状态指示灯
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       alarm_led
;;;83     		busy_led(OFF);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       busy_led
;;;84     		listen_led(OFF);
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       listen_led
;;;85     		speak_led(OFF);		
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       speak_led
;;;86     
;;;87     		if(chk_alarm_key())
000048  f7fffffe          BL       chk_alarm_key
00004c  2800              CMP      r0,#0
00004e  d008              BEQ      |L16.98|
;;;88     		{
;;;89     			noise_ctrl_sel(OFF);					// 报警键被按下，选择噪检关闭，报警开关量闭合；2014-09-18修改，for南宁地铁1号线
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       noise_ctrl_sel
;;;90     
;;;91     			pecu_status = PECU_ALARM;		// 检测报警按键按下，状态切换为报警状态
000056  2001              MOVS     r0,#1
000058  4969              LDR      r1,|L16.512|
00005a  7008              STRB     r0,[r1,#0]
;;;92     			alarm_timeout = 0;				// 初始化报警超时计时器	
00005c  2000              MOVS     r0,#0
00005e  4969              LDR      r1,|L16.516|
000060  8008              STRH     r0,[r1,#0]
                  |L16.98|
;;;93     		}
;;;94     		
;;;95     		process_pecu_status = IDLE;			// 紧急报警器工作于IDLE状态，过程数据process_pecu_status为IDLE = 0x00		
000062  2000              MOVS     r0,#0
000064  4968              LDR      r1,|L16.520|
000066  7008              STRB     r0,[r1,#0]
                  |L16.104|
;;;96     		
;;;97     		break;
000068  e0c7              B        |L16.506|
                  |L16.106|
;;;98     
;;;99     	case PECU_ALARM:
;;;100    		alarm_led_flash(50);				// 报警状态，报警指示灯间隔1s闪亮
00006a  2032              MOVS     r0,#0x32
00006c  f7fffffe          BL       alarm_led_flash
;;;101    		busy_led_flash(50);					// 2014-09-18修改，for南宁地铁1号线，原占线指示灯变更为呼叫指示灯，与alarm_led_flash同步
000070  2032              MOVS     r0,#0x32
000072  f7fffffe          BL       busy_led_flash
;;;102    
;;;103    		//noise_ctrl_sel(OFF);					// 报警键被按下，选择噪检关闭，报警开关量闭合；2014-09-18修改，for南宁地铁1号线
;;;104    
;;;105    		if(LCU_CMD_BUSY == lcu_cmd_type)	// 收到占线状态，占线指示灯间隔1s闪亮
000076  4865              LDR      r0,|L16.524|
000078  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
00007a  2801              CMP      r0,#1
00007c  d10d              BNE      |L16.154|
;;;106    		{
;;;107    			LM4871_shutdown(OFF);			// 功放打开
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       LM4871_shutdown
;;;108    			playback_start();				// 播放占线提示音
000084  f7fffffe          BL       playback_start
;;;109    
;;;110    			playback_over_flag = 0;			// “忙”提示语音循环播放完毕标志清0
000088  2000              MOVS     r0,#0
00008a  4961              LDR      r1,|L16.528|
00008c  7008              STRB     r0,[r1,#0]
;;;111    			playback_time = 0;				// “忙”提示语音循环播放间隔清0			
00008e  4961              LDR      r1,|L16.532|
000090  8008              STRH     r0,[r1,#0]
;;;112    
;;;113    			pecu_status = PECU_BUSY;
000092  2002              MOVS     r0,#2
000094  495a              LDR      r1,|L16.512|
000096  7008              STRB     r0,[r1,#0]
000098  e01a              B        |L16.208|
                  |L16.154|
;;;114    		}
;;;115    		else if(LCU_CMD_ACTIVE == lcu_cmd_type)	// 接通命令，紧急报警器进入接通状态
00009a  485c              LDR      r0,|L16.524|
00009c  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
00009e  2802              CMP      r0,#2
0000a0  d10f              BNE      |L16.194|
;;;116    		{
;;;117    			alarm_led(ON);
0000a2  2001              MOVS     r0,#1
0000a4  f7fffffe          BL       alarm_led
;;;118    			// busy_led(OFF);					// 2014-09-18修改，for南宁地铁1号线，原占线指示灯变更为呼叫指示灯，与alarm_led_flash同步
;;;119    			busy_led(ON);
0000a8  2001              MOVS     r0,#1
0000aa  f7fffffe          BL       busy_led
;;;120    
;;;121    			speak_led(ON);
0000ae  2001              MOVS     r0,#1
0000b0  f7fffffe          BL       speak_led
;;;122    
;;;123    			ptt_timeout = 0;				// PTT按键按下，PTT超时计时器清零
0000b4  2000              MOVS     r0,#0
0000b6  4958              LDR      r1,|L16.536|
0000b8  8008              STRH     r0,[r1,#0]
;;;124    
;;;125    			pecu_status = PECU_ACTIVED;	
0000ba  2003              MOVS     r0,#3
0000bc  4950              LDR      r1,|L16.512|
0000be  7008              STRB     r0,[r1,#0]
0000c0  e006              B        |L16.208|
                  |L16.194|
;;;126    		}
;;;127    		else if(LCU_CMD_HANGUP == lcu_cmd_type)	// 挂断命令
0000c2  4852              LDR      r0,|L16.524|
0000c4  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
0000c6  2803              CMP      r0,#3
0000c8  d102              BNE      |L16.208|
;;;128    			pecu_status = PECU_IDLE;
0000ca  2000              MOVS     r0,#0
0000cc  494c              LDR      r1,|L16.512|
0000ce  7008              STRB     r0,[r1,#0]
                  |L16.208|
;;;129    		
;;;130    			
;;;131    		if(alarm_timeout >= ALARM_TIMEOUT)		// 报警按键按下后3分钟没有接通，则自动进入IDLE状态
0000d0  484c              LDR      r0,|L16.516|
0000d2  8800              LDRH     r0,[r0,#0]  ; alarm_timeout
0000d4  4951              LDR      r1,|L16.540|
0000d6  4288              CMP      r0,r1
0000d8  db02              BLT      |L16.224|
;;;132    			pecu_status = PECU_IDLE;
0000da  2000              MOVS     r0,#0
0000dc  4948              LDR      r1,|L16.512|
0000de  7008              STRB     r0,[r1,#0]
                  |L16.224|
;;;133    
;;;134    	//	if(chk_reset_key() == 1) 				// 报警器复位按键按下进入空闲状态
;;;135    	//		pecu_status = PECU_IDLE;
;;;136    
;;;137    		process_pecu_status = ALARM;			// 紧急报警器工作于ALARM状态，过程数据process_pecu_status为ALARM = 0x01
0000e0  2001              MOVS     r0,#1
0000e2  4949              LDR      r1,|L16.520|
0000e4  7008              STRB     r0,[r1,#0]
;;;138    		
;;;139    		break;
0000e6  e088              B        |L16.506|
                  |L16.232|
;;;140    
;;;141    	case PECU_BUSY:							// 其他报警器占线
;;;142    		alarm_led_flash(50);				// 报警状态，报警指示灯间隔0.5s闪亮
0000e8  2032              MOVS     r0,#0x32
0000ea  f7fffffe          BL       alarm_led_flash
;;;143    		// busy_led_flash(100);				// 占线指示灯间隔1s闪亮				// 2014-09-18修改，for南宁地铁1号线，原占线指示灯变更为呼叫指示灯，与alarm_led_flash同步
;;;144    		busy_led_flash(50);				// 占线指示灯间隔1s闪亮
0000ee  2032              MOVS     r0,#0x32
0000f0  f7fffffe          BL       busy_led_flash
;;;145    
;;;146    		if((1 == playback_over_flag) &&	(playback_time >= 1000))		// 如果循环播放一次完毕，将下一次播放间隔清0
0000f4  4846              LDR      r0,|L16.528|
0000f6  7800              LDRB     r0,[r0,#0]  ; playback_over_flag
0000f8  2801              CMP      r0,#1
0000fa  d10c              BNE      |L16.278|
0000fc  4845              LDR      r0,|L16.532|
0000fe  8800              LDRH     r0,[r0,#0]  ; playback_time
000100  217d              MOVS     r1,#0x7d
000102  00c9              LSLS     r1,r1,#3
000104  4288              CMP      r0,r1
000106  db06              BLT      |L16.278|
;;;147    		{
;;;148    			playback_over_flag = 0;			// 循环播放一次完毕标志清0
000108  2000              MOVS     r0,#0
00010a  4941              LDR      r1,|L16.528|
00010c  7008              STRB     r0,[r1,#0]
;;;149    			playback_time = 0;
00010e  4941              LDR      r1,|L16.532|
000110  8008              STRH     r0,[r1,#0]
;;;150    
;;;151    			playback_start();
000112  f7fffffe          BL       playback_start
                  |L16.278|
;;;152    		}
;;;153    		
;;;154    		if(LCU_CMD_ACTIVE == lcu_cmd_type)	// 接通命令，紧急报警器进入接通状态
000116  483d              LDR      r0,|L16.524|
000118  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
00011a  2802              CMP      r0,#2
00011c  d111              BNE      |L16.322|
;;;155    		{
;;;156    			alarm_led(ON);
00011e  2001              MOVS     r0,#1
000120  f7fffffe          BL       alarm_led
;;;157    			// busy_led(OFF);				// 2014-09-18修改，for南宁地铁1号线，原占线指示灯变更为呼叫指示灯，与alarm_led_flash同步
;;;158    			busy_led(ON);
000124  2001              MOVS     r0,#1
000126  f7fffffe          BL       busy_led
;;;159    
;;;160    			speak_led(ON);
00012a  2001              MOVS     r0,#1
00012c  f7fffffe          BL       speak_led
;;;161    
;;;162    			playback_stop();				// 关闭占线提示音
000130  f7fffffe          BL       playback_stop
;;;163    			
;;;164    			ptt_timeout = 0;				// PTT按键按下，PTT超时计时器清零
000134  2000              MOVS     r0,#0
000136  4938              LDR      r1,|L16.536|
000138  8008              STRH     r0,[r1,#0]
;;;165    			
;;;166    			pecu_status = PECU_ACTIVED;	
00013a  2003              MOVS     r0,#3
00013c  4930              LDR      r1,|L16.512|
00013e  7008              STRB     r0,[r1,#0]
000140  e015              B        |L16.366|
                  |L16.322|
;;;167    		}
;;;168    		else if(LCU_CMD_HANGUP == lcu_cmd_type)	// 挂断命令
000142  4832              LDR      r0,|L16.524|
000144  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
000146  2803              CMP      r0,#3
000148  d105              BNE      |L16.342|
;;;169    		{
;;;170    			playback_stop();				// 关闭占线提示音
00014a  f7fffffe          BL       playback_stop
;;;171    
;;;172    			pecu_status = PECU_IDLE;
00014e  2000              MOVS     r0,#0
000150  492b              LDR      r1,|L16.512|
000152  7008              STRB     r0,[r1,#0]
000154  e00b              B        |L16.366|
                  |L16.342|
;;;173    		}
;;;174    		else if(LCU_CMD_IDLE == lcu_cmd_type)	// 报警器处于忙状态，此时收到空闲命令，则进入报警状态
000156  482d              LDR      r0,|L16.524|
000158  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
00015a  2800              CMP      r0,#0
00015c  d107              BNE      |L16.366|
;;;175    		{
;;;176    			playback_stop();
00015e  f7fffffe          BL       playback_stop
;;;177    			// busy_led(OFF);				// 2014-09-18修改，for南宁地铁1号线，原占线指示灯变更为呼叫指示灯，与alarm_led_flash同步
;;;178    			LM4871_shutdown(ON);
000162  2001              MOVS     r0,#1
000164  f7fffffe          BL       LM4871_shutdown
;;;179    
;;;180    			pecu_status = PECU_ALARM;
000168  2001              MOVS     r0,#1
00016a  4925              LDR      r1,|L16.512|
00016c  7008              STRB     r0,[r1,#0]
                  |L16.366|
;;;181    		}
;;;182    			
;;;183    		if(alarm_timeout >= ALARM_TIMEOUT)		// 报警按键按下后3分钟没有接通，则自动进入IDLE状态
00016e  4825              LDR      r0,|L16.516|
000170  8800              LDRH     r0,[r0,#0]  ; alarm_timeout
000172  492a              LDR      r1,|L16.540|
000174  4288              CMP      r0,r1
000176  db04              BLT      |L16.386|
;;;184    		{
;;;185    			playback_stop();				// 关闭占线提示音
000178  f7fffffe          BL       playback_stop
;;;186    
;;;187    			pecu_status = PECU_IDLE;
00017c  2000              MOVS     r0,#0
00017e  4920              LDR      r1,|L16.512|
000180  7008              STRB     r0,[r1,#0]
                  |L16.386|
;;;188    		}
;;;189    		
;;;190    		//if(chk_reset_key() == 1) 				// 报警器复位按键按下进入空闲状态
;;;191    		//{
;;;192    		//	playback_stop();				// 关闭占线提示音
;;;193    
;;;194    		//	pecu_status = PECU_IDLE;
;;;195    		//}	
;;;196    		
;;;197    		process_pecu_status = ALARM;			// 紧急报警器工作于BUSY状态，过程数据process_pecu_status应该仍为ALARM = 0x01			
000182  2001              MOVS     r0,#1
000184  4920              LDR      r1,|L16.520|
000186  7008              STRB     r0,[r1,#0]
;;;198    			
;;;199    		break; 
000188  e037              B        |L16.506|
                  |L16.394|
;;;200    
;;;201    	case PECU_ACTIVED:
;;;202    		mic_output(ON);				    // 打开MIC音频输出
00018a  2001              MOVS     r0,#1
00018c  f7fffffe          BL       mic_output
;;;203    		//spk_input(ON);					// 打开SPK音频输入
;;;204    		//LM4871_shutdown(OFF);			// 2014-10-08修改			// 功放进入工作状态					
;;;205    
;;;206    		if(chk_ptt_key() == 1)				// 检测PTT按键是否按下
000190  f7fffffe          BL       chk_ptt_key
000194  2801              CMP      r0,#1
000196  d10e              BNE      |L16.438|
;;;207    		{
;;;208    			listen_led(ON);
000198  f7fffffe          BL       listen_led
;;;209    			speak_led(OFF);
00019c  2000              MOVS     r0,#0
00019e  f7fffffe          BL       speak_led
;;;210    
;;;211    		//	mic_output(OFF);				    // 关闭MIC音频输出
;;;212    			LM4871_shutdown(OFF);			// 2014-10-08修改			// 功放进入工作状态
0001a2  2000              MOVS     r0,#0
0001a4  f7fffffe          BL       LM4871_shutdown
;;;213    			spk_input(ON);
0001a8  2001              MOVS     r0,#1
0001aa  f7fffffe          BL       spk_input
;;;214    
;;;215    			ptt_timeout = 0;				// PTT按键按下，PTT超时计时器清零
0001ae  2000              MOVS     r0,#0
0001b0  4919              LDR      r1,|L16.536|
0001b2  8008              STRH     r0,[r1,#0]
0001b4  e00e              B        |L16.468|
                  |L16.438|
;;;216    		}
;;;217    		else if(chk_ptt_key() == 0)			// 检测PTT按键是否抬起			
0001b6  f7fffffe          BL       chk_ptt_key
0001ba  2800              CMP      r0,#0
0001bc  d10a              BNE      |L16.468|
;;;218    		{
;;;219    			listen_led(OFF);
0001be  f7fffffe          BL       listen_led
;;;220    			speak_led(ON);
0001c2  2001              MOVS     r0,#1
0001c4  f7fffffe          BL       speak_led
;;;221    
;;;222    		//	mic_output(ON);				    // 关闭MIC音频输出
;;;223    			LM4871_shutdown(ON);			// 2014-10-08修改			// 功放进入静音状态
0001c8  2001              MOVS     r0,#1
0001ca  f7fffffe          BL       LM4871_shutdown
;;;224    			spk_input(OFF);
0001ce  2000              MOVS     r0,#0
0001d0  f7fffffe          BL       spk_input
                  |L16.468|
;;;225    		}
;;;226    
;;;227    		if(LCU_CMD_HANGUP == lcu_cmd_type)
0001d4  480d              LDR      r0,|L16.524|
0001d6  7800              LDRB     r0,[r0,#0]  ; lcu_cmd_type
0001d8  2803              CMP      r0,#3
0001da  d102              BNE      |L16.482|
;;;228    			pecu_status = PECU_IDLE;
0001dc  2000              MOVS     r0,#0
0001de  4908              LDR      r1,|L16.512|
0001e0  7008              STRB     r0,[r1,#0]
                  |L16.482|
;;;229    			
;;;230    		if(ptt_timeout >= PTT_TIMEOUT)		// 报警接通后3分钟没有PTT按下，则自动进入IDLE状态
0001e2  480d              LDR      r0,|L16.536|
0001e4  8800              LDRH     r0,[r0,#0]  ; ptt_timeout
0001e6  490d              LDR      r1,|L16.540|
0001e8  4288              CMP      r0,r1
0001ea  db02              BLT      |L16.498|
;;;231    			pecu_status = PECU_IDLE;
0001ec  2000              MOVS     r0,#0
0001ee  4904              LDR      r1,|L16.512|
0001f0  7008              STRB     r0,[r1,#0]
                  |L16.498|
;;;232    
;;;233    		//if(chk_reset_key() == 1) 				// 报警器复位按键按下进入空闲状态
;;;234    		//	pecu_status = PECU_IDLE;
;;;235    		
;;;236    		process_pecu_status = ACTIVE;			// 紧急报警器工作于ACTIVE状态，过程数据process_pecu_status应该仍为ACTIVE = 0x02 
0001f2  2002              MOVS     r0,#2
0001f4  4904              LDR      r1,|L16.520|
0001f6  7008              STRB     r0,[r1,#0]
;;;237    			
;;;238    		break;
0001f8  bf00              NOP      
                  |L16.506|
0001fa  bf00              NOP                            ;97
;;;239    	}
;;;240    }
0001fc  bd10              POP      {r4,pc}
;;;241    
                          ENDP

0001fe  0000              DCW      0x0000
                  |L16.512|
                          DCD      pecu_status
                  |L16.516|
                          DCD      alarm_timeout
                  |L16.520|
                          DCD      process_pecu_status
                  |L16.524|
                          DCD      lcu_cmd_type
                  |L16.528|
                          DCD      playback_over_flag
                  |L16.532|
                          DCD      playback_time
                  |L16.536|
                          DCD      ptt_timeout
                  |L16.540|
                          DCD      0x00004650

                          AREA ||i.prase_rx_data||, CODE, READONLY, ALIGN=2

                  prase_rx_data PROC
;;;389    
;;;390    static uint8_t prase_rx_data(uint16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;391    {
000002  4605              MOV      r5,r0
;;;392    	FRAME_HEADER *ptr_frame_header;
;;;393    
;;;394    	ptr_frame_header = (FRAME_HEADER *)rx_buffer;
000004  4c28              LDR      r4,|L17.168|
;;;395    
;;;396    	if(len < 7)
000006  2d07              CMP      r5,#7
000008  da01              BGE      |L17.14|
;;;397    		return(0);
00000a  2000              MOVS     r0,#0
                  |L17.12|
;;;398    
;;;399    	switch(ptr_frame_header->cmd.bits.packet_type)
;;;400    	{
;;;401    	case PROCESS_PACKET:
;;;402    		break;
;;;403    
;;;404    	case P2P_PACKET:
;;;405    		break;
;;;406    
;;;407    	case TOKEN_PACKET:
;;;408    		if(ptr_frame_header->dest_netnum != 0x00)			// 是否本网
;;;409    			return(0);
;;;410    		if(ptr_frame_header->dest_eqnum.eq_type != PECU)	// 是否PECU
;;;411    			return(0);
;;;412    		if(ptr_frame_header->dest_eqnum.eq_num != pecu_eqnum)
;;;413    			return(0);
;;;414    		if(ptr_frame_header->src_netnum != 0x00)			// 是否本网
;;;415    			return(0);
;;;416    		if(ptr_frame_header->src_eqnum.eq_type != LCU)		// 是否LCU
;;;417    			return(0);
;;;418    
;;;419    		if(ptr_frame_header->len != 1)
;;;420    			return(0);
;;;421    
;;;422    		lcu_eqnum = ptr_frame_header->src_eqnum.eq_num;		// 获取本地控制单元设备号
;;;423    
;;;424    		pecu_com_timeout = 0;
;;;425    
;;;426    		lcu_cmd_type = rx_buffer[6];
;;;427    
;;;428    		com_delay_time = 2;									// 收到一包数据，延时10ms应答
;;;429    		while(com_delay_time !=0);
;;;430    
;;;431    		send_process_packet();
;;;432    
;;;433    		break;
;;;434    
;;;435    	case DOWNLOAD_PACKET:
;;;436    		break;
;;;437    	}
;;;438    
;;;439    	return(0xff);
;;;440    }
00000c  bd70              POP      {r4-r6,pc}
                  |L17.14|
00000e  7920              LDRB     r0,[r4,#4]            ;399
000010  0700              LSLS     r0,r0,#28             ;399
000012  0f00              LSRS     r0,r0,#28             ;399
000014  d006              BEQ      |L17.36|
000016  2801              CMP      r0,#1                 ;399
000018  d005              BEQ      |L17.38|
00001a  2802              CMP      r0,#2                 ;399
00001c  d004              BEQ      |L17.40|
00001e  2804              CMP      r0,#4                 ;399
000020  d13e              BNE      |L17.160|
000022  e03c              B        |L17.158|
                  |L17.36|
000024  e03c              B        |L17.160|
                  |L17.38|
000026  e03b              B        |L17.160|
                  |L17.40|
000028  7820              LDRB     r0,[r4,#0]            ;408
00002a  2800              CMP      r0,#0                 ;408
00002c  d001              BEQ      |L17.50|
00002e  2000              MOVS     r0,#0                 ;409
000030  e7ec              B        |L17.12|
                  |L17.50|
000032  7860              LDRB     r0,[r4,#1]            ;410
000034  0700              LSLS     r0,r0,#28             ;410
000036  0f00              LSRS     r0,r0,#28             ;410
000038  2805              CMP      r0,#5                 ;410
00003a  d001              BEQ      |L17.64|
00003c  2000              MOVS     r0,#0                 ;411
00003e  e7e5              B        |L17.12|
                  |L17.64|
000040  7860              LDRB     r0,[r4,#1]            ;412
000042  0900              LSRS     r0,r0,#4              ;412
000044  4919              LDR      r1,|L17.172|
000046  7809              LDRB     r1,[r1,#0]            ;412  ; pecu_eqnum
000048  4288              CMP      r0,r1                 ;412
00004a  d001              BEQ      |L17.80|
00004c  2000              MOVS     r0,#0                 ;413
00004e  e7dd              B        |L17.12|
                  |L17.80|
000050  78a0              LDRB     r0,[r4,#2]            ;414
000052  2800              CMP      r0,#0                 ;414
000054  d001              BEQ      |L17.90|
000056  2000              MOVS     r0,#0                 ;415
000058  e7d8              B        |L17.12|
                  |L17.90|
00005a  78e0              LDRB     r0,[r4,#3]            ;416
00005c  0700              LSLS     r0,r0,#28             ;416
00005e  0f00              LSRS     r0,r0,#28             ;416
000060  2803              CMP      r0,#3                 ;416
000062  d001              BEQ      |L17.104|
000064  2000              MOVS     r0,#0                 ;417
000066  e7d1              B        |L17.12|
                  |L17.104|
000068  7960              LDRB     r0,[r4,#5]            ;419
00006a  2801              CMP      r0,#1                 ;419
00006c  d001              BEQ      |L17.114|
00006e  2000              MOVS     r0,#0                 ;420
000070  e7cc              B        |L17.12|
                  |L17.114|
000072  78e0              LDRB     r0,[r4,#3]            ;422
000074  0900              LSRS     r0,r0,#4              ;422
000076  490e              LDR      r1,|L17.176|
000078  7008              STRB     r0,[r1,#0]            ;422
00007a  2000              MOVS     r0,#0                 ;424
00007c  490d              LDR      r1,|L17.180|
00007e  8008              STRH     r0,[r1,#0]            ;424
000080  4809              LDR      r0,|L17.168|
000082  7980              LDRB     r0,[r0,#6]            ;426  ; rx_buffer
000084  490c              LDR      r1,|L17.184|
000086  7008              STRB     r0,[r1,#0]            ;426
000088  2002              MOVS     r0,#2                 ;428
00008a  490c              LDR      r1,|L17.188|
00008c  7008              STRB     r0,[r1,#0]            ;428
00008e  bf00              NOP                            ;429
                  |L17.144|
000090  480a              LDR      r0,|L17.188|
000092  7800              LDRB     r0,[r0,#0]            ;429  ; com_delay_time
000094  2800              CMP      r0,#0                 ;429
000096  d1fb              BNE      |L17.144|
000098  f7fffffe          BL       send_process_packet
00009c  e000              B        |L17.160|
                  |L17.158|
00009e  bf00              NOP                            ;436
                  |L17.160|
0000a0  bf00              NOP                            ;402
0000a2  20ff              MOVS     r0,#0xff              ;439
0000a4  e7b2              B        |L17.12|
;;;441    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L17.168|
                          DCD      rx_buffer
                  |L17.172|
                          DCD      pecu_eqnum
                  |L17.176|
                          DCD      lcu_eqnum
                  |L17.180|
                          DCD      pecu_com_timeout
                  |L17.184|
                          DCD      lcu_cmd_type
                  |L17.188|
                          DCD      com_delay_time

                          AREA ||i.prc_rx_data||, CODE, READONLY, ALIGN=2

                  prc_rx_data PROC
;;;441    
;;;442    static void prc_rx_data(void)
000000  b508              PUSH     {r3,lr}
;;;443    {
;;;444    	uint8_t tmp;
;;;445    	static uint16_t rx_data_len = 0;
;;;446    	static uint8_t tmp_rx_chksum;
;;;447    	static uint8_t rx_chksum;
;;;448    
;;;449    	while(get_char(&tmp))
000002  e08c              B        |L18.286|
                  |L18.4|
;;;450    	{
;;;451    		switch(rx_status)
000004  4849              LDR      r0,|L18.300|
000006  7800              LDRB     r0,[r0,#0]  ; rx_status
000008  2801              CMP      r0,#1
00000a  d004              BEQ      |L18.22|
00000c  2802              CMP      r0,#2
00000e  d013              BEQ      |L18.56|
000010  2803              CMP      r0,#3
000012  d110              BNE      |L18.54|
000014  e04f              B        |L18.182|
                  |L18.22|
;;;452    		{
;;;453    		case COM_RX_HEAD:
;;;454    			if(0x7e == tmp)
000016  4668              MOV      r0,sp
000018  7800              LDRB     r0,[r0,#0]
00001a  287e              CMP      r0,#0x7e
00001c  d108              BNE      |L18.48|
;;;455    			{
;;;456    				rx_status = COM_RX_DATA;
00001e  2002              MOVS     r0,#2
000020  4942              LDR      r1,|L18.300|
000022  7008              STRB     r0,[r1,#0]
;;;457    				rx_data_len = 0;
000024  2000              MOVS     r0,#0
000026  4942              LDR      r1,|L18.304|
000028  8008              STRH     r0,[r1,#0]
;;;458    				tmp_rx_chksum = 0;
00002a  4942              LDR      r1,|L18.308|
00002c  7008              STRB     r0,[r1,#0]
00002e  e002              B        |L18.54|
                  |L18.48|
;;;459    			}
;;;460    			else
;;;461    				rx_status = COM_RX_HEAD;
000030  2001              MOVS     r0,#1
000032  493e              LDR      r1,|L18.300|
000034  7008              STRB     r0,[r1,#0]
                  |L18.54|
;;;462    			break;
000036  e071              B        |L18.284|
                  |L18.56|
;;;463    
;;;464    		case COM_RX_DATA:
;;;465    			if(0x7e == tmp)
000038  4668              MOV      r0,sp
00003a  7800              LDRB     r0,[r0,#0]
00003c  287e              CMP      r0,#0x7e
00003e  d119              BNE      |L18.116|
;;;466    			{
;;;467    				if(rx_data_len > 0)
000040  483b              LDR      r0,|L18.304|
000042  8800              LDRH     r0,[r0,#0]  ; rx_data_len
000044  2800              CMP      r0,#0
000046  dd11              BLE      |L18.108|
;;;468    				{
;;;469    					rx_status = COM_RX_HEAD;
000048  2001              MOVS     r0,#1
00004a  4938              LDR      r1,|L18.300|
00004c  7008              STRB     r0,[r1,#0]
;;;470    					tmp_rx_chksum -= rx_chksum;
00004e  4839              LDR      r0,|L18.308|
000050  7800              LDRB     r0,[r0,#0]  ; tmp_rx_chksum
000052  4939              LDR      r1,|L18.312|
000054  7809              LDRB     r1,[r1,#0]  ; rx_chksum
000056  1a40              SUBS     r0,r0,r1
000058  4936              LDR      r1,|L18.308|
00005a  7008              STRB     r0,[r1,#0]
;;;471    					//if(rx_chksum != (0x55 - tmp_rx_chksum))
;;;472    					//	break;
;;;473    					prase_rx_data(rx_data_len);
00005c  4834              LDR      r0,|L18.304|
00005e  8800              LDRH     r0,[r0,#0]  ; rx_data_len
000060  f7fffffe          BL       prase_rx_data
;;;474    					
;;;475    					rx_data_len = 0;
000064  2000              MOVS     r0,#0
000066  4932              LDR      r1,|L18.304|
000068  8008              STRH     r0,[r1,#0]
00006a  e023              B        |L18.180|
                  |L18.108|
;;;476    				}
;;;477    				else
;;;478    					rx_status = COM_RX_DATA;
00006c  2002              MOVS     r0,#2
00006e  492f              LDR      r1,|L18.300|
000070  7008              STRB     r0,[r1,#0]
000072  e01f              B        |L18.180|
                  |L18.116|
;;;479    			}
;;;480    			else if(0x7f == tmp)
000074  4668              MOV      r0,sp
000076  7800              LDRB     r0,[r0,#0]
000078  287f              CMP      r0,#0x7f
00007a  d103              BNE      |L18.132|
;;;481    				rx_status = COM_RX_DLE;
00007c  2003              MOVS     r0,#3
00007e  492b              LDR      r1,|L18.300|
000080  7008              STRB     r0,[r1,#0]
000082  e017              B        |L18.180|
                  |L18.132|
;;;482    			else
;;;483    			{
;;;484    				rx_buffer[rx_data_len++] = tmp;
000084  4668              MOV      r0,sp
000086  7801              LDRB     r1,[r0,#0]
000088  4829              LDR      r0,|L18.304|
00008a  8802              LDRH     r2,[r0,#0]  ; rx_data_len
00008c  8800              LDRH     r0,[r0,#0]  ; rx_data_len
00008e  1c40              ADDS     r0,r0,#1
000090  4b27              LDR      r3,|L18.304|
000092  8018              STRH     r0,[r3,#0]
000094  4829              LDR      r0,|L18.316|
000096  5481              STRB     r1,[r0,r2]
;;;485    				tmp_rx_chksum += tmp;
000098  4826              LDR      r0,|L18.308|
00009a  7801              LDRB     r1,[r0,#0]  ; tmp_rx_chksum
00009c  4668              MOV      r0,sp
00009e  7800              LDRB     r0,[r0,#0]
0000a0  1808              ADDS     r0,r1,r0
0000a2  4924              LDR      r1,|L18.308|
0000a4  7008              STRB     r0,[r1,#0]
;;;486    				rx_chksum = tmp;
0000a6  4668              MOV      r0,sp
0000a8  7800              LDRB     r0,[r0,#0]
0000aa  4923              LDR      r1,|L18.312|
0000ac  7008              STRB     r0,[r1,#0]
;;;487    
;;;488    				rx_status = COM_RX_DATA;
0000ae  2002              MOVS     r0,#2
0000b0  491e              LDR      r1,|L18.300|
0000b2  7008              STRB     r0,[r1,#0]
                  |L18.180|
;;;489    			}
;;;490    			break;
0000b4  e032              B        |L18.284|
                  |L18.182|
;;;491    
;;;492    		case COM_RX_DLE:
;;;493    			rx_status = COM_RX_DATA;
0000b6  2002              MOVS     r0,#2
0000b8  491c              LDR      r1,|L18.300|
0000ba  7008              STRB     r0,[r1,#0]
;;;494    			if(0x80 == tmp)
0000bc  4668              MOV      r0,sp
0000be  7800              LDRB     r0,[r0,#0]
0000c0  2880              CMP      r0,#0x80
0000c2  d111              BNE      |L18.232|
;;;495    			{
;;;496    				rx_buffer[rx_data_len++] = 0x7e;
0000c4  217e              MOVS     r1,#0x7e
0000c6  481a              LDR      r0,|L18.304|
0000c8  8802              LDRH     r2,[r0,#0]  ; rx_data_len
0000ca  8800              LDRH     r0,[r0,#0]  ; rx_data_len
0000cc  1c40              ADDS     r0,r0,#1
0000ce  4b18              LDR      r3,|L18.304|
0000d0  8018              STRH     r0,[r3,#0]
0000d2  481a              LDR      r0,|L18.316|
0000d4  5481              STRB     r1,[r0,r2]
;;;497    				tmp_rx_chksum += 0x7e;
0000d6  4817              LDR      r0,|L18.308|
0000d8  7800              LDRB     r0,[r0,#0]  ; tmp_rx_chksum
0000da  307e              ADDS     r0,r0,#0x7e
0000dc  4915              LDR      r1,|L18.308|
0000de  7008              STRB     r0,[r1,#0]
;;;498    				rx_chksum = 0x7e;
0000e0  207e              MOVS     r0,#0x7e
0000e2  4915              LDR      r1,|L18.312|
0000e4  7008              STRB     r0,[r1,#0]
0000e6  e018              B        |L18.282|
                  |L18.232|
;;;499    			}
;;;500    			else if(0x81 == tmp)
0000e8  4668              MOV      r0,sp
0000ea  7800              LDRB     r0,[r0,#0]
0000ec  2881              CMP      r0,#0x81
0000ee  d111              BNE      |L18.276|
;;;501    			{
;;;502    				rx_buffer[rx_data_len++] = 0x7f;
0000f0  227f              MOVS     r2,#0x7f
0000f2  480f              LDR      r0,|L18.304|
0000f4  8801              LDRH     r1,[r0,#0]  ; rx_data_len
0000f6  8800              LDRH     r0,[r0,#0]  ; rx_data_len
0000f8  1c40              ADDS     r0,r0,#1
0000fa  4b0d              LDR      r3,|L18.304|
0000fc  8018              STRH     r0,[r3,#0]
0000fe  480f              LDR      r0,|L18.316|
000100  5442              STRB     r2,[r0,r1]
;;;503    				tmp_rx_chksum += 0x7f;
000102  480c              LDR      r0,|L18.308|
000104  7800              LDRB     r0,[r0,#0]  ; tmp_rx_chksum
000106  307f              ADDS     r0,r0,#0x7f
000108  490a              LDR      r1,|L18.308|
00010a  7008              STRB     r0,[r1,#0]
;;;504    				rx_chksum = 0x7f;
00010c  207f              MOVS     r0,#0x7f
00010e  490a              LDR      r1,|L18.312|
000110  7008              STRB     r0,[r1,#0]
000112  e002              B        |L18.282|
                  |L18.276|
;;;505    			}
;;;506    			else
;;;507    				rx_status = COM_RX_HEAD;
000114  2001              MOVS     r0,#1
000116  4905              LDR      r1,|L18.300|
000118  7008              STRB     r0,[r1,#0]
                  |L18.282|
;;;508    			break;
00011a  bf00              NOP      
                  |L18.284|
00011c  bf00              NOP                            ;462
                  |L18.286|
00011e  4668              MOV      r0,sp                 ;449
000120  f7fffffe          BL       get_char
000124  2800              CMP      r0,#0                 ;449
000126  d000              BEQ      |L18.298|
000128  e76c              B        |L18.4|
                  |L18.298|
;;;509    		}
;;;510    	}
;;;511    }
00012a  bd08              POP      {r3,pc}
;;;512    
                          ENDP

                  |L18.300|
                          DCD      rx_status
                  |L18.304|
                          DCD      rx_data_len
                  |L18.308|
                          DCD      tmp_rx_chksum
                  |L18.312|
                          DCD      rx_chksum
                  |L18.316|
                          DCD      rx_buffer

                          AREA ||i.send_data||, CODE, READONLY, ALIGN=2

                  send_data PROC
;;;363    
;;;364    static void send_data(uint8_t *buf, uint8_t n)
000000  b5f8              PUSH     {r3-r7,lr}
;;;365    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;366    	uint8_t i, j = 0;
000006  2400              MOVS     r4,#0
;;;367    	
;;;368    	tx_buffer[j++] = 0x7e;
000008  227e              MOVS     r2,#0x7e
00000a  4621              MOV      r1,r4
00000c  1c64              ADDS     r4,r4,#1
00000e  481c              LDR      r0,|L19.128|
000010  5442              STRB     r2,[r0,r1]
;;;369    	
;;;370    	for(i = 0; i < n; i++)
000012  2500              MOVS     r5,#0
000014  e027              B        |L19.102|
                  |L19.22|
;;;371    	{
;;;372    		if(0x7e == buf[i])
000016  5d70              LDRB     r0,[r6,r5]
000018  287e              CMP      r0,#0x7e
00001a  d10c              BNE      |L19.54|
;;;373    		{
;;;374    			tx_buffer[j++] = 0x7f;
00001c  227f              MOVS     r2,#0x7f
00001e  4620              MOV      r0,r4
000020  1c61              ADDS     r1,r4,#1
000022  b2cc              UXTB     r4,r1
000024  4916              LDR      r1,|L19.128|
000026  540a              STRB     r2,[r1,r0]
;;;375    			tx_buffer[j++] = 0x80;
000028  2280              MOVS     r2,#0x80
00002a  4620              MOV      r0,r4
00002c  1c61              ADDS     r1,r4,#1
00002e  b2cc              UXTB     r4,r1
000030  4913              LDR      r1,|L19.128|
000032  540a              STRB     r2,[r1,r0]
000034  e015              B        |L19.98|
                  |L19.54|
;;;376    		}
;;;377    		else if(0x7f == buf[i])
000036  5d70              LDRB     r0,[r6,r5]
000038  287f              CMP      r0,#0x7f
00003a  d10c              BNE      |L19.86|
;;;378    		{
;;;379    			tx_buffer[j++] = 0x7f;
00003c  227f              MOVS     r2,#0x7f
00003e  4620              MOV      r0,r4
000040  1c61              ADDS     r1,r4,#1
000042  b2cc              UXTB     r4,r1
000044  490e              LDR      r1,|L19.128|
000046  540a              STRB     r2,[r1,r0]
;;;380    			tx_buffer[j++] = 0x81;
000048  2281              MOVS     r2,#0x81
00004a  4620              MOV      r0,r4
00004c  1c61              ADDS     r1,r4,#1
00004e  b2cc              UXTB     r4,r1
000050  490b              LDR      r1,|L19.128|
000052  540a              STRB     r2,[r1,r0]
000054  e005              B        |L19.98|
                  |L19.86|
;;;381    		}
;;;382    		else
;;;383    			tx_buffer[j++] = buf[i];	
000056  5d72              LDRB     r2,[r6,r5]
000058  4620              MOV      r0,r4
00005a  1c61              ADDS     r1,r4,#1
00005c  b2cc              UXTB     r4,r1
00005e  4908              LDR      r1,|L19.128|
000060  540a              STRB     r2,[r1,r0]
                  |L19.98|
000062  1c68              ADDS     r0,r5,#1              ;370
000064  b2c5              UXTB     r5,r0                 ;370
                  |L19.102|
000066  42bd              CMP      r5,r7                 ;370
000068  dbd5              BLT      |L19.22|
;;;384    	}
;;;385    	tx_buffer[j++] = 0x7e;
00006a  227e              MOVS     r2,#0x7e
00006c  4620              MOV      r0,r4
00006e  1c61              ADDS     r1,r4,#1
000070  b2cc              UXTB     r4,r1
000072  4903              LDR      r1,|L19.128|
000074  540a              STRB     r2,[r1,r0]
;;;386    	
;;;387    	put_n_char(tx_buffer, j);	
000076  4621              MOV      r1,r4
000078  4801              LDR      r0,|L19.128|
00007a  f7fffffe          BL       put_n_char
;;;388    }
00007e  bdf8              POP      {r3-r7,pc}
;;;389    
                          ENDP

                  |L19.128|
                          DCD      tx_buffer

                          AREA ||i.send_process_packet||, CODE, READONLY, ALIGN=2

                  send_process_packet PROC
;;;339    
;;;340    static void send_process_packet(void)
000000  b510              PUSH     {r4,lr}
;;;341    {
;;;342    	FRAME_HEADER *ptr_frame_header;
;;;343    	
;;;344    	ptr_frame_header = (FRAME_HEADER *)process_data_buffer;
000002  4c25              LDR      r4,|L20.152|
;;;345    	
;;;346    	ptr_frame_header->dest_netnum = 0x00;
000004  2000              MOVS     r0,#0
000006  7020              STRB     r0,[r4,#0]
;;;347    	ptr_frame_header->dest_eqnum.eq_type = LCU;					// 本地控制器类别
000008  7860              LDRB     r0,[r4,#1]
00000a  0900              LSRS     r0,r0,#4
00000c  0100              LSLS     r0,r0,#4
00000e  1cc0              ADDS     r0,r0,#3
000010  7060              STRB     r0,[r4,#1]
;;;348    	ptr_frame_header->dest_eqnum.eq_num = lcu_eqnum;			// 本地控制器设备号
000012  7860              LDRB     r0,[r4,#1]
000014  21f0              MOVS     r1,#0xf0
000016  4388              BICS     r0,r0,r1
000018  4920              LDR      r1,|L20.156|
00001a  7809              LDRB     r1,[r1,#0]  ; lcu_eqnum
00001c  0109              LSLS     r1,r1,#4
00001e  22f0              MOVS     r2,#0xf0
000020  4011              ANDS     r1,r1,r2
000022  4308              ORRS     r0,r0,r1
000024  7060              STRB     r0,[r4,#1]
;;;349    	ptr_frame_header->src_netnum = 0x00;
000026  2000              MOVS     r0,#0
000028  70a0              STRB     r0,[r4,#2]
;;;350    	ptr_frame_header->src_eqnum.eq_type = PECU;					// 紧急报警器类别
00002a  78e0              LDRB     r0,[r4,#3]
00002c  0900              LSRS     r0,r0,#4
00002e  0100              LSLS     r0,r0,#4
000030  1d40              ADDS     r0,r0,#5
000032  70e0              STRB     r0,[r4,#3]
;;;351    	ptr_frame_header->src_eqnum.eq_num = pecu_eqnum;			// 紧急报警器设备号
000034  78e0              LDRB     r0,[r4,#3]
000036  21f0              MOVS     r1,#0xf0
000038  4388              BICS     r0,r0,r1
00003a  4919              LDR      r1,|L20.160|
00003c  7809              LDRB     r1,[r1,#0]  ; pecu_eqnum
00003e  0109              LSLS     r1,r1,#4
000040  4011              ANDS     r1,r1,r2
000042  4308              ORRS     r0,r0,r1
000044  70e0              STRB     r0,[r4,#3]
;;;352    	ptr_frame_header->cmd.bits.m_include = 0;
000046  7920              LDRB     r0,[r4,#4]
000048  2180              MOVS     r1,#0x80
00004a  4388              BICS     r0,r0,r1
00004c  7120              STRB     r0,[r4,#4]
;;;353    	ptr_frame_header->cmd.bits.m_error = 0;
00004e  7920              LDRB     r0,[r4,#4]
000050  2140              MOVS     r1,#0x40
000052  4388              BICS     r0,r0,r1
000054  7120              STRB     r0,[r4,#4]
;;;354    	ptr_frame_header->cmd.bits.m_active = 0;
000056  7920              LDRB     r0,[r4,#4]
000058  2120              MOVS     r1,#0x20
00005a  4388              BICS     r0,r0,r1
00005c  7120              STRB     r0,[r4,#4]
;;;355    	ptr_frame_header->cmd.bits.token_return = 1;
00005e  7920              LDRB     r0,[r4,#4]
000060  2110              MOVS     r1,#0x10
000062  4388              BICS     r0,r0,r1
000064  3010              ADDS     r0,r0,#0x10
000066  7120              STRB     r0,[r4,#4]
;;;356    	ptr_frame_header->cmd.bits.packet_type = PROCESS_PACKET;
000068  7920              LDRB     r0,[r4,#4]
00006a  0900              LSRS     r0,r0,#4
00006c  0100              LSLS     r0,r0,#4
00006e  7120              STRB     r0,[r4,#4]
;;;357    	ptr_frame_header->len = 1;
000070  2001              MOVS     r0,#1
000072  7160              STRB     r0,[r4,#5]
;;;358    	process_data_buffer[6] = process_pecu_status;		// pecu_status;							// 将紧急报警器工作状态写入过程数据
000074  480b              LDR      r0,|L20.164|
000076  7800              LDRB     r0,[r0,#0]  ; process_pecu_status
000078  4621              MOV      r1,r4
00007a  7188              STRB     r0,[r1,#6]
;;;359    	process_data_buffer[7] = chksum(process_data_buffer, (ptr_frame_header->len + 6));
00007c  7960              LDRB     r0,[r4,#5]
00007e  1d81              ADDS     r1,r0,#6
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       chksum
000086  4621              MOV      r1,r4
000088  71c8              STRB     r0,[r1,#7]
;;;360    
;;;361    	send_data(process_data_buffer, (ptr_frame_header->len + 7));	 	
00008a  7960              LDRB     r0,[r4,#5]
00008c  1dc0              ADDS     r0,r0,#7
00008e  b2c1              UXTB     r1,r0
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       send_data
;;;362    }
000096  bd10              POP      {r4,pc}
;;;363    
                          ENDP

                  |L20.152|
                          DCD      process_data_buffer
                  |L20.156|
                          DCD      lcu_eqnum
                  |L20.160|
                          DCD      pecu_eqnum
                  |L20.164|
                          DCD      process_pecu_status

                          AREA ||i.speak_led||, CODE, READONLY, ALIGN=1

                  speak_led PROC
;;;589    
;;;590    static void speak_led(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;591    {
000002  4604              MOV      r4,r0
;;;592    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d103              BNE      |L21.16|
;;;593    		//DrvGPIO_SetBit(PECU_LED_PORT, SPEAK_LED_PIN);			// 2014-04-09修改
;;;594    		DrvGPIO_ClrBit(PECU_LED_PORT, SPEAK_LED_PIN);
000008  2102              MOVS     r1,#2
00000a  f7fffffe          BL       DrvGPIO_ClrBit
00000e  e003              B        |L21.24|
                  |L21.16|
;;;595    	else
;;;596    		//DrvGPIO_ClrBit(PECU_LED_PORT, SPEAK_LED_PIN);			// 2014-04-09修改
;;;597    		DrvGPIO_SetBit(PECU_LED_PORT, SPEAK_LED_PIN);
000010  2102              MOVS     r1,#2
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       DrvGPIO_SetBit
                  |L21.24|
;;;598    }
000018  bd10              POP      {r4,pc}
;;;599    
                          ENDP


                          AREA ||i.spk_input||, CODE, READONLY, ALIGN=1

                  spk_input PROC
;;;563    
;;;564    static void spk_input(uint8_t on_off)
000000  b510              PUSH     {r4,lr}
;;;565    {
000002  4604              MOV      r4,r0
;;;566    	if(on_off == ON)
000004  2c01              CMP      r4,#1
000006  d104              BNE      |L22.18|
;;;567    		DrvGPIO_ClrBit(PECU_CTRL_PORT, SPK_CTRL_PIN);			// 低电平，继电器吸合，扬声器音频输入
000008  2104              MOVS     r1,#4
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       DrvGPIO_ClrBit
000010  e003              B        |L22.26|
                  |L22.18|
;;;568    	else
;;;569    		DrvGPIO_SetBit(PECU_CTRL_PORT, SPK_CTRL_PIN);			// 高电平，继电器断开
000012  2104              MOVS     r1,#4
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       DrvGPIO_SetBit
                  |L22.26|
;;;570    }
00001a  bd10              POP      {r4,pc}
;;;571    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rx_buffer
                          %        270
                  tx_buffer
                          %        64
                  process_data_buffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=1

                  alarm_led_flash_interval
000000  0000              DCW      0x0000
                  busy_led_flash_interval
000002  0000              DCW      0x0000
                  com_led_flash_interval
000004  0000              DCW      0x0000
                  com_delay_time
000006  00                DCB      0x00
                  rx_status
000007  01                DCB      0x01
                  process_pecu_status
000008  00                DCB      0x00
                  pecu_status
000009  00                DCB      0x00
                  lcu_cmd_type
00000a  0000              DCB      0x00,0x00
                  pecu_com_timeout
00000c  0000              DCW      0x0000
                  alarm_timeout
00000e  0000              DCW      0x0000
                  ptt_timeout
000010  0000              DCW      0x0000
                  playback_over_flag
000012  0000              DCB      0x00,0x00
                  playback_time
000014  0000              DCW      0x0000
                  old_alarm_key
000016  0100              DCB      0x01,0x00
                  rx_data_len
000018  0000              DCW      0x0000
                  tmp_rx_chksum
00001a  00                DCB      0x00
                  rx_chksum
00001b  00                DCB      0x00
                  pecu_eqnum
00001c  00                DCB      0x00
                  lcu_eqnum
00001d  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\pecu.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_pecu_c_8c12e0ac____REV16|
#line 112 "..\\..\\ISD91XX_SDK\\CMSIS\\CM0\\CoreSupport\\core_cmInstr.h"
|__asm___6_pecu_c_8c12e0ac____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_pecu_c_8c12e0ac____REVSH|
#line 130
|__asm___6_pecu_c_8c12e0ac____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
