; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\drvgpio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\drvgpio.d --cpu=Cortex-M0 --apcs=interwork -I.\ -I..\..\..\..\HW -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD91xx -I..\..\..\Include -I..\..\..\Include\Driver -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\?ST\STM32F10x --omf_browse=.\obj\drvgpio.crf ..\..\..\Src\Driver\DrvGPIO.c]
                          THUMB

                          AREA ||i.DrvGPIO_Close||, CODE, READONLY, ALIGN=2

                  DrvGPIO_Close PROC
;;;374    /*---------------------------------------------------------------------------------------------------------*/
;;;375    int32_t DrvGPIO_Close(DRVGPIO_PORT port,int32_t i32Bit)
000000  2911              CMP      r1,#0x11
;;;376    {
;;;377        if((i32Bit < 0) || (i32Bit > 16))
000002  d301              BCC      |L1.8|
;;;378        {
;;;379            return E_DRVGPIO_ARGUMENT;
000004  4808              LDR      r0,|L1.40|
;;;380        }
;;;381        // &GPIOA->PMD: 0x5000_4000[31:0]
;;;382        outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, (inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) & (~(3 << (i32Bit*2)))));
;;;383    	
;;;384    	GPIO_DBNCECON->ICLK_ON = 0; // 0x5000_4180[5]
;;;385    
;;;386        return E_SUCCESS;
;;;387    }	
000006  4770              BX       lr
                  |L1.8|
000008  0182              LSLS     r2,r0,#6              ;382
00000a  4808              LDR      r0,|L1.44|
00000c  1810              ADDS     r0,r2,r0              ;382
00000e  6802              LDR      r2,[r0,#0]            ;382
000010  004b              LSLS     r3,r1,#1              ;382
000012  2103              MOVS     r1,#3                 ;382
000014  4099              LSLS     r1,r1,r3              ;382
000016  438a              BICS     r2,r2,r1              ;382
000018  6002              STR      r2,[r0,#0]            ;382
00001a  4805              LDR      r0,|L1.48|
00001c  6801              LDR      r1,[r0,#0]            ;384
00001e  2220              MOVS     r2,#0x20              ;384
000020  4391              BICS     r1,r1,r2              ;384
000022  6001              STR      r1,[r0,#0]            ;384
000024  2000              MOVS     r0,#0                 ;386
000026  4770              BX       lr
;;;388    
                          ENDP

                  |L1.40|
                          DCD      0xffff8901
                  |L1.44|
                          DCD      0x50004000
                  |L1.48|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_ClrBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_ClrBit PROC
;;;582    
;;;583    int32_t DrvGPIO_ClrBit(DRVGPIO_PORT port,int32_t i32Bit)
000000  4a08              LDR      r2,|L2.36|
;;;584    {
;;;585        uint32_t u32PortAddr;
;;;586        
;;;587        if(port > GPB)
000002  2801              CMP      r0,#1
000004  d801              BHI      |L2.10|
;;;588        {
;;;589            return E_DRVGPIO_ARGUMENT;
;;;590        }
;;;591        
;;;592        if((i32Bit < 0) || (i32Bit > 16))
000006  2911              CMP      r1,#0x11
000008  d301              BCC      |L2.14|
                  |L2.10|
;;;593        {
;;;594            return E_DRVGPIO_ARGUMENT;
00000a  4610              MOV      r0,r2
;;;595        }
;;;596    
;;;597    	u32PortAddr = (uint32_t)&GPIOA->DOUT  + port * PORT_OFFSET;
;;;598       	
;;;599    	outpw(u32PortAddr, inpw(u32PortAddr) & (~(1 << i32Bit)));
;;;600       
;;;601        return E_SUCCESS;
;;;602    }
00000c  4770              BX       lr
                  |L2.14|
00000e  4a06              LDR      r2,|L2.40|
000010  0180              LSLS     r0,r0,#6              ;597
000012  1880              ADDS     r0,r0,r2              ;597
000014  6802              LDR      r2,[r0,#0]            ;599
000016  2301              MOVS     r3,#1                 ;599
000018  408b              LSLS     r3,r3,r1              ;599
00001a  439a              BICS     r2,r2,r3              ;599
00001c  6002              STR      r2,[r0,#0]            ;599
00001e  2000              MOVS     r0,#0                 ;601
000020  4770              BX       lr
;;;603    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0xffff8901
                  |L2.40|
                          DCD      0x50004008

                          AREA ||i.DrvGPIO_ClrBitMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_ClrBitMask PROC
;;;817    
;;;818    int32_t DrvGPIO_ClrBitMask(DRVGPIO_PORT port, uint32_t u32Bit)
000000  0182              LSLS     r2,r0,#6
;;;819    {
;;;820    
;;;821    	outpw((uint32_t)&GPIOA->DMASK+ port*PORT_OFFSET,inpw((uint32_t)&GPIOA->DMASK+ port*PORT_OFFSET) &(~(1<<u32Bit)));
000002  4804              LDR      r0,|L3.20|
000004  1810              ADDS     r0,r2,r0
000006  68c2              LDR      r2,[r0,#0xc]
000008  2301              MOVS     r3,#1
00000a  408b              LSLS     r3,r3,r1
00000c  439a              BICS     r2,r2,r3
00000e  60c2              STR      r2,[r0,#0xc]
;;;822    	
;;;823    	return E_SUCCESS;
000010  2000              MOVS     r0,#0
;;;824    }
000012  4770              BX       lr
;;;825    
                          ENDP

                  |L3.20|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_DisableDebounce||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableDebounce PROC
;;;744    /*---------------------------------------------------------------------------------------------------------*/
;;;745    int32_t DrvGPIO_DisableDebounce(DRVGPIO_PORT port, uint32_t u32Bit)
000000  2801              CMP      r0,#1
;;;746    {
;;;747        if(port > GPB)
000002  d901              BLS      |L4.8|
;;;748            return E_DRVGPIO_ARGUMENT;
000004  4805              LDR      r0,|L4.28|
;;;749    
;;;750    	// GPIOA->DBEN: (0x5000_4000 + 5 << 2)[31:0] = 0x5000_4014[31:0]
;;;751        outpw((uint32_t)&GPIOA->DBEN + port * PORT_OFFSET , inpw((uint32_t)&GPIOA->DBEN + port * PORT_OFFSET) &(~(1<<u32Bit)));
;;;752    
;;;753        
;;;754    	return E_SUCCESS;
;;;755    }
000006  4770              BX       lr
                  |L4.8|
000008  0182              LSLS     r2,r0,#6              ;751
00000a  4805              LDR      r0,|L4.32|
00000c  1810              ADDS     r0,r2,r0              ;751
00000e  6942              LDR      r2,[r0,#0x14]         ;751
000010  2301              MOVS     r3,#1                 ;751
000012  408b              LSLS     r3,r3,r1              ;751
000014  439a              BICS     r2,r2,r3              ;751
000016  6142              STR      r2,[r0,#0x14]         ;751
000018  2000              MOVS     r0,#0                 ;754
00001a  4770              BX       lr
;;;756    
                          ENDP

                  |L4.28|
                          DCD      0xffff8901
                  |L4.32|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_DisableEINT0||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableEINT0 PROC
;;;989    /*---------------------------------------------------------------------------------------------------------*/
;;;990    void DrvGPIO_DisableEINT0(void)
000000  4904              LDR      r1,|L5.20|
;;;991    {
;;;992        uint32_t u32Reg;
;;;993        u32Reg = inpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET);
000002  69c8              LDR      r0,[r1,#0x1c]
;;;994        u32Reg = u32Reg & (~((1UL << 0) | (1UL << (0 + 16))));
000004  4a04              LDR      r2,|L5.24|
000006  4010              ANDS     r0,r0,r2
;;;995        outpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET , u32Reg);	 
000008  61c8              STR      r0,[r1,#0x1c]
00000a  4904              LDR      r1,|L5.28|
00000c  2004              MOVS     r0,#4
00000e  6008              STR      r0,[r1,#0]
;;;996        NVIC_DisableIRQ(EINT0_IRQn);
;;;997    }
000010  4770              BX       lr
;;;998    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x50004040
                  |L5.24|
                          DCD      0xfffefffe
                  |L5.28|
                          DCD      0xe000e180

                          AREA ||i.DrvGPIO_DisableEINT1||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableEINT1 PROC
;;;1054   /*---------------------------------------------------------------------------------------------------------*/
;;;1055   void DrvGPIO_DisableEINT1(void)
000000  4904              LDR      r1,|L6.20|
;;;1056   {
;;;1057       uint32_t u32Reg;
;;;1058       u32Reg = inpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET);
000002  69c8              LDR      r0,[r1,#0x1c]
;;;1059       u32Reg = u32Reg & (~((1UL << 1) | (1UL << (1 + 16))));
000004  4a04              LDR      r2,|L6.24|
000006  4010              ANDS     r0,r0,r2
;;;1060       outpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET , u32Reg);	 
000008  61c8              STR      r0,[r1,#0x1c]
00000a  4904              LDR      r1,|L6.28|
00000c  2008              MOVS     r0,#8
00000e  6008              STR      r0,[r1,#0]
;;;1061       NVIC_DisableIRQ(EINT1_IRQn);
;;;1062   }
000010  4770              BX       lr
;;;1063   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x50004040
                  |L6.24|
                          DCD      0xfffdfffd
                  |L6.28|
                          DCD      0xe000e180

                          AREA ||i.DrvGPIO_DisableInt||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableInt PROC
;;;920    /*---------------------------------------------------------------------------------------------------------*/
;;;921    int32_t DrvGPIO_DisableInt(DRVGPIO_PORT port,uint32_t u32Bit)
000000  2800              CMP      r0,#0
;;;922    {
;;;923        uint32_t u32Reg;
;;;924    
;;;925        if((port == GPA && u32Bit > 15) || (port == GPB && u32Bit > 7))
000002  d002              BEQ      |L7.10|
000004  2801              CMP      r0,#1
000006  d003              BEQ      |L7.16|
000008  e006              B        |L7.24|
                  |L7.10|
00000a  290f              CMP      r1,#0xf
00000c  d802              BHI      |L7.20|
00000e  e003              B        |L7.24|
                  |L7.16|
000010  2907              CMP      r1,#7
000012  d901              BLS      |L7.24|
                  |L7.20|
;;;926            return E_DRVGPIO_ARGUMENT;
000014  4807              LDR      r0,|L7.52|
;;;927        
;;;928        /* Disable both rising/falling or both high level/low level interrupts */
;;;929        u32Reg = (1 << u32Bit) | (1 << (u32Bit + 16));
;;;930        outpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET , inpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET) & (~u32Reg));	 
;;;931    
;;;932        return E_SUCCESS;
;;;933    }
000016  4770              BX       lr
                  |L7.24|
000018  2301              MOVS     r3,#1                 ;929
00001a  461a              MOV      r2,r3                 ;929
00001c  408a              LSLS     r2,r2,r1              ;929
00001e  3110              ADDS     r1,r1,#0x10           ;929
000020  408b              LSLS     r3,r3,r1              ;929
000022  0181              LSLS     r1,r0,#6              ;930
000024  4804              LDR      r0,|L7.56|
000026  431a              ORRS     r2,r2,r3              ;929
000028  1808              ADDS     r0,r1,r0              ;930
00002a  69c1              LDR      r1,[r0,#0x1c]         ;930
00002c  4391              BICS     r1,r1,r2              ;930
00002e  61c1              STR      r1,[r0,#0x1c]         ;930
000030  2000              MOVS     r0,#0                 ;932
000032  4770              BX       lr
;;;934    
                          ENDP

                  |L7.52|
                          DCD      0xffff8901
                  |L7.56|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_EnableDebounce||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableDebounce PROC
;;;718    /*---------------------------------------------------------------------------------------------------------*/
;;;719    int32_t DrvGPIO_EnableDebounce(DRVGPIO_PORT port,uint32_t u32Bit)
000000  290f              CMP      r1,#0xf
;;;720    {
;;;721        if(u32Bit > 15)
000002  d901              BLS      |L8.8|
;;;722            return E_DRVGPIO_ARGUMENT;
000004  4805              LDR      r0,|L8.28|
;;;723    
;;;724    	// GPIOA->DBEN: (0x5000_4000 + 5 << 2)[31:0] = 0x5000_4014[31:0]
;;;725        outpw((uint32_t)&GPIOA->DBEN + port * PORT_OFFSET, inpw((uint32_t)&GPIOA->DBEN + port * PORT_OFFSET) | (1 << u32Bit));
;;;726    
;;;727    	//GPIO_DBNCECON->ICLK_ON = 1;
;;;728    
;;;729        return E_SUCCESS;
;;;730    }
000006  4770              BX       lr
                  |L8.8|
000008  0182              LSLS     r2,r0,#6              ;725
00000a  4805              LDR      r0,|L8.32|
00000c  1810              ADDS     r0,r2,r0              ;725
00000e  6942              LDR      r2,[r0,#0x14]         ;725
000010  2301              MOVS     r3,#1                 ;725
000012  408b              LSLS     r3,r3,r1              ;725
000014  431a              ORRS     r2,r2,r3              ;725
000016  6142              STR      r2,[r0,#0x14]         ;725
000018  2000              MOVS     r0,#0                 ;729
00001a  4770              BX       lr
;;;731    
                          ENDP

                  |L8.28|
                          DCD      0xffff8901
                  |L8.32|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_EnableEINT0||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableEINT0 PROC
;;;947    /*---------------------------------------------------------------------------------------------------------*/
;;;948    void DrvGPIO_EnableEINT0(DRVGPIO_INT_TYPE tiggerType, DRVGPIO_INT_MODE mode, GPIO_EINT0_CALLBACK pfEINT0Callback)
000000  b530              PUSH     {r4,r5,lr}
;;;949    {
;;;950        uint32_t u32Reg;
;;;951    
;;;952        /* Configure the interrupt to be rising/falling when edge trigger or high/low level when level trigger */
;;;953        u32Reg = inpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET);
000002  4c12              LDR      r4,|L9.76|
000004  69e3              LDR      r3,[r4,#0x1c]
000006  2501              MOVS     r5,#1                 ;949
;;;954    	if(tiggerType ==IO_RISING)
000008  2800              CMP      r0,#0
00000a  d004              BEQ      |L9.22|
;;;955        {
;;;956            u32Reg = u32Reg | (1 << (0 + 16)); 
;;;957    	}
;;;958        else if(tiggerType == IO_FALLING)
00000c  2801              CMP      r0,#1
00000e  d005              BEQ      |L9.28|
;;;959    	{
;;;960            u32Reg = u32Reg | (1 << 0);  
;;;961    	}
;;;962        else if(tiggerType == IO_BOTH_EDGE)
000010  2802              CMP      r0,#2
000012  d005              BEQ      |L9.32|
000014  e006              B        |L9.36|
                  |L9.22|
000016  2001              MOVS     r0,#1                 ;956
000018  0400              LSLS     r0,r0,#16             ;956
00001a  e002              B        |L9.34|
                  |L9.28|
00001c  432b              ORRS     r3,r3,r5              ;960
00001e  e001              B        |L9.36|
                  |L9.32|
;;;963        {  
;;;964            u32Reg = u32Reg | (1 << 0) | (1 << (0 + 16));    
000020  480b              LDR      r0,|L9.80|
                  |L9.34|
000022  4303              ORRS     r3,r3,r0
                  |L9.36|
;;;965    	}
;;;966    		outpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET , u32Reg);	 
000024  61e3              STR      r3,[r4,#0x1c]
;;;967    
;;;968        /* Configure to be level trigger or edge trigger: '1': level trigger; '0': edge trigger */
;;;969    	if(mode ==MODE_EDGE)
000026  2900              CMP      r1,#0
000028  d002              BEQ      |L9.48|
;;;970    		outpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET,inpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET)&(~(1<<0)));
;;;971    
;;;972    	else if(mode ==MODE_LEVEL)
00002a  2901              CMP      r1,#1
00002c  d004              BEQ      |L9.56|
00002e  e006              B        |L9.62|
                  |L9.48|
000030  69a0              LDR      r0,[r4,#0x18]         ;970
000032  0840              LSRS     r0,r0,#1              ;970
000034  0040              LSLS     r0,r0,#1              ;970
000036  e001              B        |L9.60|
                  |L9.56|
;;;973    		outpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET,inpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET)|(1<<0));
000038  69a0              LDR      r0,[r4,#0x18]
00003a  4328              ORRS     r0,r0,r5
                  |L9.60|
00003c  61a0              STR      r0,[r4,#0x18]
                  |L9.62|
;;;974    
;;;975        _pfEINT0Callback = pfEINT0Callback;
00003e  4805              LDR      r0,|L9.84|
000040  4905              LDR      r1,|L9.88|
000042  6042              STR      r2,[r0,#4]  ; _pfEINT0Callback
000044  2004              MOVS     r0,#4
000046  6008              STR      r0,[r1,#0]
;;;976        NVIC_EnableIRQ(EINT0_IRQn);
;;;977    }
000048  bd30              POP      {r4,r5,pc}
;;;978    
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      0x50004040
                  |L9.80|
                          DCD      0x00010001
                  |L9.84|
                          DCD      ||.data||
                  |L9.88|
                          DCD      0xe000e100

                          AREA ||i.DrvGPIO_EnableEINT1||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableEINT1 PROC
;;;1011   /*---------------------------------------------------------------------------------------------------------*/
;;;1012   void DrvGPIO_EnableEINT1(DRVGPIO_INT_TYPE tiggerType, DRVGPIO_INT_MODE mode, GPIO_EINT1_CALLBACK pfEINT1Callback)
000000  b530              PUSH     {r4,r5,lr}
;;;1013   {
;;;1014       uint32_t u32Reg;
;;;1015   
;;;1016       u32Reg = inpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET);
000002  4c11              LDR      r4,|L10.72|
000004  69e3              LDR      r3,[r4,#0x1c]
;;;1017   	if(tiggerType ==IO_RISING)
;;;1018       {
;;;1019           u32Reg = u32Reg | (1UL << (1 + 16));    
;;;1020   	}
;;;1021       else if(tiggerType == IO_FALLING)
;;;1022   	{
;;;1023           u32Reg = u32Reg | (1UL << 1);  
000006  2502              MOVS     r5,#2
000008  2800              CMP      r0,#0                 ;1017
00000a  d004              BEQ      |L10.22|
00000c  2801              CMP      r0,#1                 ;1021
00000e  d005              BEQ      |L10.28|
;;;1024   	}
;;;1025       else if(tiggerType == IO_BOTH_EDGE)
000010  2802              CMP      r0,#2
000012  d005              BEQ      |L10.32|
000014  e006              B        |L10.36|
                  |L10.22|
000016  2001              MOVS     r0,#1                 ;1019
000018  0440              LSLS     r0,r0,#17             ;1019
00001a  e002              B        |L10.34|
                  |L10.28|
00001c  432b              ORRS     r3,r3,r5              ;1023
00001e  e001              B        |L10.36|
                  |L10.32|
;;;1026       {  
;;;1027           u32Reg = u32Reg | (1UL << 1) | (1UL << (1 + 16)); 
000020  480a              LDR      r0,|L10.76|
                  |L10.34|
000022  4303              ORRS     r3,r3,r0
                  |L10.36|
;;;1028   	}
;;;1029       outpw((uint32_t)&GPIOA->IEN + GPB * PORT_OFFSET , u32Reg);	 
000024  61e3              STR      r3,[r4,#0x1c]
;;;1030   
;;;1031   
;;;1032       /* Configure to be level trigger or edge trigger: '1': level trigger; '0': edge trigger */
;;;1033   	if(mode ==MODE_EDGE)
000026  2900              CMP      r1,#0
000028  d002              BEQ      |L10.48|
;;;1034   		outpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET,inpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET)&(~(1<<1)));
;;;1035   
;;;1036   	else if(mode ==MODE_LEVEL)
00002a  2901              CMP      r1,#1
00002c  d003              BEQ      |L10.54|
00002e  e005              B        |L10.60|
                  |L10.48|
000030  69a0              LDR      r0,[r4,#0x18]         ;1034
000032  43a8              BICS     r0,r0,r5              ;1034
000034  e001              B        |L10.58|
                  |L10.54|
;;;1037   		outpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET,inpw((uint32_t)&GPIOA->IMD + GPB*PORT_OFFSET)|(1<<1));
000036  69a0              LDR      r0,[r4,#0x18]
000038  4328              ORRS     r0,r0,r5
                  |L10.58|
00003a  61a0              STR      r0,[r4,#0x18]
                  |L10.60|
;;;1038   
;;;1039       
;;;1040       _pfEINT1Callback = pfEINT1Callback;
00003c  4804              LDR      r0,|L10.80|
00003e  4905              LDR      r1,|L10.84|
000040  6082              STR      r2,[r0,#8]  ; _pfEINT1Callback
000042  2008              MOVS     r0,#8
000044  6008              STR      r0,[r1,#0]
;;;1041       NVIC_EnableIRQ(EINT1_IRQn);
;;;1042   }
000046  bd30              POP      {r4,r5,pc}
;;;1043   
                          ENDP

                  |L10.72|
                          DCD      0x50004040
                  |L10.76|
                          DCD      0x00020002
                  |L10.80|
                          DCD      ||.data||
                  |L10.84|
                          DCD      0xe000e100

                          AREA ||i.DrvGPIO_EnableInt||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableInt PROC
;;;859    /*---------------------------------------------------------------------------------------------------------*/
;;;860    int32_t DrvGPIO_EnableInt(DRVGPIO_PORT port, uint32_t u32Bit, DRVGPIO_INT_TYPE tiggerType, DRVGPIO_INT_MODE mode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;861    {
;;;862        if((port == GPB) && ((u32Bit == 0) || (u32Bit == 1)))
;;;863        {
;;;864            // GPB0 is EINT0, GPB1 is EINT1. Both of them can't be assigned to GPAB interrupt
;;;865            return E_DRVGPIO_ARGUMENT;    
000002  4e20              LDR      r6,|L11.132|
000004  2801              CMP      r0,#1                 ;862
000006  d014              BEQ      |L11.50|
;;;866        }
;;;867    
;;;868    	if((port == GPA && u32Bit > 16 	) || 
000008  2800              CMP      r0,#0
00000a  d019              BEQ      |L11.64|
;;;869    	   (port == GPB && u32Bit > 8  	) ||
00000c  2801              CMP      r0,#1
00000e  d014              BEQ      |L11.58|
;;;870           (port  > GPB                 ) 
000010  d827              BHI      |L11.98|
                  |L11.18|
;;;871    	  )
;;;872        {
;;;873            return E_DRVGPIO_ARGUMENT;
;;;874        }
;;;875        
;;;876        /* Configure the interrupt to be rising/falling when edge trigger or high/low level when level trigger */
;;;877    	if(tiggerType ==IO_RISING)//'1': rising edge or high level
;;;878    		outpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET , inpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET) | (1<<(u32Bit+16)));	 
000012  460f              MOV      r7,r1
000014  2401              MOVS     r4,#1                 ;861
000016  3710              ADDS     r7,r7,#0x10
000018  4625              MOV      r5,r4                 ;861
00001a  40bd              LSLS     r5,r5,r7
00001c  4f1a              LDR      r7,|L11.136|
;;;879    
;;;880    	else if(tiggerType == IO_FALLING)//'1': falling edge or low level
;;;881    		outpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET , inpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET) | (1<<u32Bit));	 
00001e  408c              LSLS     r4,r4,r1
000020  0181              LSLS     r1,r0,#6              ;878
000022  19c9              ADDS     r1,r1,r7              ;878
000024  2a00              CMP      r2,#0                 ;877
000026  d00e              BEQ      |L11.70|
000028  2a01              CMP      r2,#1                 ;880
00002a  d00e              BEQ      |L11.74|
;;;882    
;;;883    	else if(tiggerType == IO_BOTH_EDGE) //'1': (rising edge + falling edge) or [(high level + low level) = no action] 
00002c  2a02              CMP      r2,#2
00002e  d00f              BEQ      |L11.80|
000030  e017              B        |L11.98|
                  |L11.50|
000032  2900              CMP      r1,#0                 ;862
000034  d015              BEQ      |L11.98|
000036  2901              CMP      r1,#1                 ;862
000038  d013              BEQ      |L11.98|
                  |L11.58|
00003a  2908              CMP      r1,#8                 ;869
00003c  d811              BHI      |L11.98|
00003e  e7e8              B        |L11.18|
                  |L11.64|
000040  2910              CMP      r1,#0x10              ;868
000042  d80e              BHI      |L11.98|
000044  e7e5              B        |L11.18|
                  |L11.70|
000046  69ca              LDR      r2,[r1,#0x1c]         ;878
000048  e005              B        |L11.86|
                  |L11.74|
00004a  69ca              LDR      r2,[r1,#0x1c]         ;881
00004c  4322              ORRS     r2,r2,r4              ;881
00004e  e003              B        |L11.88|
                  |L11.80|
000050  4622              MOV      r2,r4                 ;881
;;;884    		outpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET , inpw((uint32_t)&GPIOA->IEN + port * PORT_OFFSET) | (1<<u32Bit)| (1<<(u32Bit+16)));	 
000052  432a              ORRS     r2,r2,r5
000054  69cd              LDR      r5,[r1,#0x1c]
                  |L11.86|
000056  432a              ORRS     r2,r2,r5              ;878
                  |L11.88|
000058  61ca              STR      r2,[r1,#0x1c]
;;;885    	else
;;;886    		return E_DRVGPIO_ARGUMENT;
;;;887    
;;;888        /* Configure to be level trigger or edge trigger: '1': level trigger; '0': edge trigger */
;;;889    	if(mode ==MODE_EDGE)
00005a  2b00              CMP      r3,#0
00005c  d003              BEQ      |L11.102|
;;;890    		outpw((uint32_t)&GPIOA->IMD + port*PORT_OFFSET,inpw((uint32_t)&GPIOA->IMD + port*PORT_OFFSET)&(~(1<<u32Bit)));
;;;891    
;;;892    	else if(mode ==MODE_LEVEL)
00005e  2b01              CMP      r3,#1
000060  d004              BEQ      |L11.108|
                  |L11.98|
;;;893    		outpw((uint32_t)&GPIOA->IMD + port*PORT_OFFSET,inpw((uint32_t)&GPIOA->IMD + port*PORT_OFFSET)|(1<<u32Bit));
;;;894    
;;;895    	else
;;;896    		return E_DRVGPIO_ARGUMENT;
000062  4630              MOV      r0,r6
;;;897        
;;;898        /* Enable the relative interrupt of M0 */
;;;899        if(port == GPA || port == GPB)
;;;900        {
;;;901            //NVIC_SetPriority (GPAB_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
;;;902            NVIC_EnableIRQ(GPAB_IRQn);
;;;903        }
;;;904    
;;;905       return E_SUCCESS;
;;;906    }
000064  bdf0              POP      {r4-r7,pc}
                  |L11.102|
000066  698a              LDR      r2,[r1,#0x18]         ;890
000068  43a2              BICS     r2,r2,r4              ;890
00006a  e001              B        |L11.112|
                  |L11.108|
00006c  698a              LDR      r2,[r1,#0x18]         ;893
00006e  4322              ORRS     r2,r2,r4              ;893
                  |L11.112|
000070  618a              STR      r2,[r1,#0x18]         ;893
000072  2800              CMP      r0,#0                 ;899
000074  d001              BEQ      |L11.122|
000076  2801              CMP      r0,#1                 ;899
000078  d102              BNE      |L11.128|
                  |L11.122|
00007a  4904              LDR      r1,|L11.140|
00007c  2010              MOVS     r0,#0x10              ;899
00007e  6008              STR      r0,[r1,#0]            ;899
                  |L11.128|
000080  2000              MOVS     r0,#0                 ;905
000082  bdf0              POP      {r4-r7,pc}
;;;907    
                          ENDP

                  |L11.132|
                          DCD      0xffff8901
                  |L11.136|
                          DCD      0x50004000
                  |L11.140|
                          DCD      0xe000e100

                          AREA ||i.DrvGPIO_GetBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetBit PROC
;;;511    /*---------------------------------------------------------------------------------------------------------*/
;;;512    int32_t DrvGPIO_GetBit(DRVGPIO_PORT port, int32_t i32Bit)
000000  2801              CMP      r0,#1
;;;513    {
;;;514        uint32_t u32PortAddr;
;;;515        
;;;516        if(port > GPB)
000002  d901              BLS      |L12.8|
;;;517        {
;;;518            return E_DRVGPIO_ARGUMENT;
000004  4806              LDR      r0,|L12.32|
;;;519        }
;;;520        
;;;521        if((i32Bit < 0) || (i32Bit > 16))
;;;522        {
;;;523            return 0;
;;;524        }
;;;525    
;;;526        u32PortAddr = (uint32_t)&GPIOA->PIN + port * PORT_OFFSET;
;;;527       	   
;;;528    
;;;529        return ((inpw(u32PortAddr) >> i32Bit) & 1);
;;;530    }
000006  4770              BX       lr
                  |L12.8|
000008  2911              CMP      r1,#0x11              ;521
00000a  d301              BCC      |L12.16|
00000c  2000              MOVS     r0,#0                 ;523
00000e  4770              BX       lr
                  |L12.16|
000010  4a04              LDR      r2,|L12.36|
000012  0180              LSLS     r0,r0,#6              ;526
000014  1880              ADDS     r0,r0,r2              ;526
000016  6800              LDR      r0,[r0,#0]            ;529
000018  40c8              LSRS     r0,r0,r1              ;529
00001a  07c0              LSLS     r0,r0,#31             ;529
00001c  0fc0              LSRS     r0,r0,#31             ;529
00001e  4770              BX       lr
;;;531    
                          ENDP

                  |L12.32|
                          DCD      0xffff8901
                  |L12.36|
                          DCD      0x50004010

                          AREA ||i.DrvGPIO_GetDebounceTime||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetDebounceTime PROC
;;;695    
;;;696    int32_t DrvGPIO_GetDebounceTime(void)
000000  4802              LDR      r0,|L13.12|
;;;697    {
;;;698        volatile int32_t i32Reg;
;;;699    
;;;700        i32Reg = 	GPIO_DBNCECON->DBCLKSEL;//0x5000_4180[3:0]
000002  6800              LDR      r0,[r0,#0]
000004  0700              LSLS     r0,r0,#28
000006  0f00              LSRS     r0,r0,#28
;;;701       
;;;702        return i32Reg;
;;;703    }
000008  4770              BX       lr
;;;704    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_GetDoutBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetDoutBit PROC
;;;617    
;;;618    int32_t DrvGPIO_GetDoutBit(DRVGPIO_PORT port, int32_t i32Bit)
000000  4a07              LDR      r2,|L14.32|
;;;619    {
;;;620    	if(port > GPB)
000002  2801              CMP      r0,#1
000004  d801              BHI      |L14.10|
;;;621        {
;;;622            return E_DRVGPIO_ARGUMENT;
;;;623        }
;;;624        
;;;625        if((i32Bit < 0) || (i32Bit >= 15))
000006  290f              CMP      r1,#0xf
000008  d301              BCC      |L14.14|
                  |L14.10|
;;;626        {
;;;627            return E_DRVGPIO_ARGUMENT;
00000a  4610              MOV      r0,r2
;;;628        }
;;;629     
;;;630        return ((inpw((uint32_t)&GPIOA->DOUT + port * PORT_OFFSET) >> i32Bit) & 1);
;;;631    }
00000c  4770              BX       lr
                  |L14.14|
00000e  4a05              LDR      r2,|L14.36|
000010  0180              LSLS     r0,r0,#6              ;630
000012  1880              ADDS     r0,r0,r2              ;630
000014  6880              LDR      r0,[r0,#8]            ;630
000016  40c8              LSRS     r0,r0,r1              ;630
000018  07c0              LSLS     r0,r0,#31             ;630
00001a  0fc0              LSRS     r0,r0,#31             ;630
00001c  4770              BX       lr
;;;632    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0xffff8901
                  |L14.36|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetIntStatus||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetIntStatus PROC
;;;1074   /*---------------------------------------------------------------------------------------------------------*/
;;;1075   uint32_t DrvGPIO_GetIntStatus(DRVGPIO_PORT port)
000000  2800              CMP      r0,#0
;;;1076   {
;;;1077       uint32_t u32Reg;
;;;1078   	
;;;1079   	if(port == GPA)
000002  d003              BEQ      |L15.12|
;;;1080   		u32Reg = GPIOA->ISRC;
;;;1081   	else if(port == GPB)
000004  2801              CMP      r0,#1
000006  d003              BEQ      |L15.16|
;;;1082   		u32Reg = GPIOB->ISRC;
;;;1083   	else
;;;1084   		return E_DRVGPIO_ARGUMENT;
000008  4803              LDR      r0,|L15.24|
;;;1085   	return u32Reg;
;;;1086   }
00000a  4770              BX       lr
                  |L15.12|
00000c  4803              LDR      r0,|L15.28|
00000e  e001              B        |L15.20|
                  |L15.16|
000010  4802              LDR      r0,|L15.28|
000012  3040              ADDS     r0,r0,#0x40           ;1082
                  |L15.20|
000014  6a00              LDR      r0,[r0,#0x20]         ;1080
000016  4770              BX       lr
;;;1087   
                          ENDP

                  |L15.24|
                          DCD      0xffff8901
                  |L15.28|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetPortBits||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetPortBits PROC
;;;484    /*---------------------------------------------------------------------------------------------------------*/
;;;485    int32_t DrvGPIO_GetPortBits(DRVGPIO_PORT port)
000000  2801              CMP      r0,#1
;;;486    {
;;;487     
;;;488        uint32_t u32PortAddr;
;;;489        
;;;490        if(port > GPB)
000002  d901              BLS      |L16.8|
;;;491        {
;;;492            return E_DRVGPIO_ARGUMENT;
000004  4803              LDR      r0,|L16.20|
;;;493        }
;;;494        
;;;495        u32PortAddr = (uint32_t)&GPIOA->PIN + port * PORT_OFFSET;
;;;496       	
;;;497        return inpw(u32PortAddr);
;;;498    }
000006  4770              BX       lr
                  |L16.8|
000008  4903              LDR      r1,|L16.24|
00000a  0180              LSLS     r0,r0,#6              ;495
00000c  1840              ADDS     r0,r0,r1              ;495
00000e  6800              LDR      r0,[r0,#0]            ;497
000010  4770              BX       lr
;;;499    
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      0xffff8901
                  |L16.24|
                          DCD      0x50004010

                          AREA ||i.DrvGPIO_GetPortDoutBits||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetPortDoutBits PROC
;;;645    
;;;646    int32_t DrvGPIO_GetPortDoutBits(DRVGPIO_PORT port)
000000  2801              CMP      r0,#1
;;;647    {
;;;648        if(port > GPB)
000002  d901              BLS      |L17.8|
;;;649        {
;;;650            return E_DRVGPIO_ARGUMENT;
000004  4803              LDR      r0,|L17.20|
;;;651        }
;;;652    
;;;653        return inpw((uint32_t)&GPIOA->DOUT + port *PORT_OFFSET);
;;;654    }
000006  4770              BX       lr
                  |L17.8|
000008  4903              LDR      r1,|L17.24|
00000a  0180              LSLS     r0,r0,#6              ;653
00000c  1840              ADDS     r0,r0,r1              ;653
00000e  6880              LDR      r0,[r0,#8]            ;653
000010  4770              BX       lr
;;;655    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0xffff8901
                  |L17.24|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetPortMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetPortMask PROC
;;;837    
;;;838    int32_t DrvGPIO_GetPortMask(DRVGPIO_PORT port)
000000  4902              LDR      r1,|L18.12|
;;;839    {
;;;840    	return inpw((uint32_t)&GPIOA->DMASK + port * PORT_OFFSET); 
000002  0180              LSLS     r0,r0,#6
000004  1840              ADDS     r0,r0,r1
000006  68c0              LDR      r0,[r0,#0xc]
;;;841    }
000008  4770              BX       lr
;;;842    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetVersion||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetVersion PROC
;;;1098   /*---------------------------------------------------------------------------------------------------------*/
;;;1099   int32_t DrvGPIO_GetVersion (void)
000000  4800              LDR      r0,|L19.4|
;;;1100   {
;;;1101      return DRVGPIO_VERSION_NUM;
;;;1102   }
000002  4770              BX       lr
;;;1103   
                          ENDP

                  |L19.4|
                          DCD      0x00010001

                          AREA ||i.DrvGPIO_InitFunction||, CODE, READONLY, ALIGN=2

                  DrvGPIO_InitFunction PROC
;;;161    /*---------------------------------------------------------------------------------------------------------*/
;;;162    int32_t DrvGPIO_InitFunction(DRVGPIO_FUNC function)
000000  b5f0              PUSH     {r4-r7,lr}
;;;163    {
000002  240c              MOVS     r4,#0xc
;;;164      
;;;165    	switch(function)
;;;166    	{
;;;167    		/*---------------------------------------------------------------------------------------------------------*/
;;;168    		/* GPIO                                                                                                    */
;;;169    		/*---------------------------------------------------------------------------------------------------------*/
;;;170    		case FUNC_GPIO:
;;;171    		{
;;;172    		  	outpw(&SYS->GPA_ALT,0); //(0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[31:0]
000004  2105              MOVS     r1,#5
;;;173    			outpw(&SYS->GPB_ALT,0); //(0x5000_0000 + 15<<2)[31:0]= 0x5000_003C[31:0]
;;;174    	
;;;175    		  	
;;;176    		}break;
;;;177    
;;;178    		/*---------------------------------------------------------------------------------------------------------*/
;;;179    		/* PWM                                                                                                     */
;;;180    		/*---------------------------------------------------------------------------------------------------------*/
;;;181    		case FUNC_PWM01:
;;;182    		{
;;;183    		  	SYS->GPA_ALT.GPA12 		=1;	 // PWM0
;;;184    		  	SYS->GPA_ALT.GPA13 		=1;	 // PWM1
;;;185    
;;;186    		}break;
;;;187    
;;;188    		case FUNC_PWM01B:
;;;189    		{
;;;190    		  	SYS->GPB_ALT.GPB4 		=1;	 // PWM0B
;;;191    		  	SYS->GPB_ALT.GPB5 		=1;	 // PWM1B
;;;192    
;;;193    		}break;
;;;194    
;;;195    		/*---------------------------------------------------------------------------------------------------------*/
;;;196    		/* I2C                                                                                                     */
;;;197    		/*---------------------------------------------------------------------------------------------------------*/
;;;198    		case FUNC_I2C0:
;;;199    		{
;;;200    		  	SYS->GPA_ALT.GPA10 	=1;	// SDA // SYS->GPAALT.GPA10: (0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[21:20]
;;;201    			SYS->GPA_ALT.GPA11 	=1;	// SCL // SYS->GPAALT.GPA11: (0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[23:22]
;;;202    		}break;		
;;;203    
;;;204    		case FUNC_I2C1:
;;;205    		{
;;;206    		  	SYS->GPA_ALT.GPA1 	=2;	// SCL
;;;207    			SYS->GPA_ALT.GPA3 	=2;	// SDA
000006  22c0              MOVS     r2,#0xc0
000008  0709              LSLS     r1,r1,#28             ;172
00000a  01a6              LSLS     r6,r4,#6              ;190
;;;208    		}break;		
;;;209    
;;;210    		case FUNC_I2C2:
;;;211    		{
;;;212    		  	SYS->GPB_ALT.GPB2 	=1;	// SCL
00000c  2530              MOVS     r5,#0x30
;;;213    			SYS->GPB_ALT.GPB3 	=1;	// SDA
;;;214    		}break;		
;;;215    	
;;;216    		/*---------------------------------------------------------------------------------------------------------*/
;;;217    		/* I2S                                                                                                     */
;;;218    		/*---------------------------------------------------------------------------------------------------------*/
;;;219    		case FUNC_I2S0:	
;;;220    		{
;;;221    			SYS->GPA_ALT.GPA4 	=1; // I2S_FS
;;;222    			SYS->GPA_ALT.GPA5	=1;	// I2S_BCLK	
;;;223    			SYS->GPA_ALT.GPA6 	=1; // I2S_SDI		 
;;;224    			SYS->GPA_ALT.GPA7	=1;	// I2S_SDO	
;;;225    		}break;
;;;226    
;;;227    		case FUNC_I2S1:	
;;;228    		{
;;;229    			SYS->GPA_ALT.GPA8 	=2; // I2S_FS
00000e  0297              LSLS     r7,r2,#10
000010  0003              MOVS     r3,r0                 ;165
000012  f7fffffe          BL       __ARM_common_switch8
000016  160c              DCB      0x16,0x0c
000018  0f1e2c3e          DCB      0x0f,0x1e,0x2c,0x3e
00001c  464e6a87          DCB      0x46,0x4e,0x6a,0x87
000020  98a5ccdc          DCB      0x98,0xa5,0xcc,0xdc
000024  f2f0efee          DCB      0xf2,0xf0,0xef,0xee
000028  edecebea          DCB      0xed,0xec,0xeb,0xea
00002c  3ce9              DCB      0x3c,0xe9
00002e  2000              MOVS     r0,#0                 ;172
000030  6388              STR      r0,[r1,#0x38]         ;172
000032  e01a              B        |L20.106|
000034  6b8a              LDR      r2,[r1,#0x38]         ;183
000036  2003              MOVS     r0,#3                 ;183
000038  0600              LSLS     r0,r0,#24             ;183
00003a  4382              BICS     r2,r2,r0              ;183
00003c  2001              MOVS     r0,#1                 ;183
00003e  0600              LSLS     r0,r0,#24             ;183
000040  1810              ADDS     r0,r2,r0              ;183
000042  6388              STR      r0,[r1,#0x38]         ;183
000044  6b8a              LDR      r2,[r1,#0x38]         ;184
000046  2003              MOVS     r0,#3                 ;184
000048  0680              LSLS     r0,r0,#26             ;184
00004a  4382              BICS     r2,r2,r0              ;184
00004c  2001              MOVS     r0,#1                 ;184
00004e  0680              LSLS     r0,r0,#26             ;184
000050  e122              B        |L20.664|
000052  6bc8              LDR      r0,[r1,#0x3c]         ;190
000054  43b0              BICS     r0,r0,r6              ;190
000056  30ff              ADDS     r0,r0,#0xff           ;190
000058  3001              ADDS     r0,#1                 ;190
00005a  63c8              STR      r0,[r1,#0x3c]         ;190
00005c  6bc8              LDR      r0,[r1,#0x3c]         ;191
00005e  2203              MOVS     r2,#3                 ;191
000060  0292              LSLS     r2,r2,#10             ;191
000062  4390              BICS     r0,r0,r2              ;191
000064  2201              MOVS     r2,#1                 ;191
000066  0292              LSLS     r2,r2,#10             ;191
000068  1880              ADDS     r0,r0,r2              ;191
                  |L20.106|
00006a  63c8              STR      r0,[r1,#0x3c]         ;173
00006c  e00f              B        |L20.142|
00006e  6b8a              LDR      r2,[r1,#0x38]         ;200
000070  2003              MOVS     r0,#3                 ;200
000072  0500              LSLS     r0,r0,#20             ;200
000074  4382              BICS     r2,r2,r0              ;200
000076  2001              MOVS     r0,#1                 ;200
000078  0500              LSLS     r0,r0,#20             ;200
00007a  1810              ADDS     r0,r2,r0              ;200
00007c  6388              STR      r0,[r1,#0x38]         ;200
00007e  6b8a              LDR      r2,[r1,#0x38]         ;201
000080  2003              MOVS     r0,#3                 ;201
000082  0580              LSLS     r0,r0,#22             ;201
000084  4382              BICS     r2,r2,r0              ;201
000086  2001              MOVS     r0,#1                 ;201
000088  0580              LSLS     r0,r0,#22             ;201
00008a  e105              B        |L20.664|
                  |L20.140|
00008c  6388              STR      r0,[r1,#0x38]         ;184
                  |L20.142|
;;;230    			SYS->GPA_ALT.GPA9	=2;	// I2S_BCLK	
;;;231    			SYS->GPA_ALT.GPA10 	=2; // I2S_SDI		 
;;;232    			SYS->GPA_ALT.GPA11	=2;	// I2S_SDO	
;;;233    		}break;	
;;;234    	
;;;235    		/*---------------------------------------------------------------------------------------------------------*/
;;;236    		/* SPI                                                                                                     */
;;;237    		/*---------------------------------------------------------------------------------------------------------*/
;;;238    		case FUNC_SPI0:	
;;;239    		{
;;;240    			SYS->GPA_ALT.GPA0 	=1; // SPI_MOSI0
;;;241    			SYS->GPA_ALT.GPA1	=1;	// SPI_SCLK	
;;;242    			SYS->GPA_ALT.GPA2 	=1; // SPI_SSB0		 
;;;243    			SYS->GPA_ALT.GPA3	=1;	// SPI_MISO0	
;;;244    		}break;
;;;245    
;;;246    		case FUNC_SPI1:	
;;;247    		{
;;;248    			SYS->GPB_ALT.GPB0 	=3; // SPI_SSB0		 
;;;249    			SYS->GPB_ALT.GPB2	=3;	// SPI_SCLK	
;;;250    			SYS->GPB_ALT.GPB3	=3;	// SPI_MISO0	
;;;251    			SYS->GPB_ALT.GPB4 	=3; // SPI_MOSI0
;;;252    		}break;
;;;253    
;;;254    		/*---------------------------------------------------------------------------------------------------------*/
;;;255    		/* ACMP0   ACMP1                                                                                           */
;;;256    		/*---------------------------------------------------------------------------------------------------------*/
;;;257    		case FUNC_ACMP0:	
;;;258    		{
;;;259    			SYS->GPB_ALT.GPB0 	=2;
;;;260    			SYS->GPB_ALT.GPB1 	=2;
;;;261    			SYS->GPB_ALT.GPB2 	=2;
;;;262    			SYS->GPB_ALT.GPB3 	=2;
;;;263    			SYS->GPB_ALT.GPB4 	=2;
;;;264    			SYS->GPB_ALT.GPB5 	=2;
;;;265    			SYS->GPB_ALT.GPB6 	=2;
;;;266    			SYS->GPB_ALT.GPB7 	=2;
;;;267    		}break;
;;;268    
;;;269    		case FUNC_ACMP1:	
;;;270    		{
;;;271    			SYS->GPB_ALT.GPB6 	=2;
;;;272    			SYS->GPB_ALT.GPB7 	=2;
;;;273    		}break;
;;;274    
;;;275    		/*---------------------------------------------------------------------------------------------------------*/
;;;276    		/* UART                                                                                                    */
;;;277    		/*---------------------------------------------------------------------------------------------------------*/
;;;278    		case FUNC_UART0:
;;;279    		{
;;;280    			SYS->GPA_ALT.GPA8	=1;		// UART_TX: (0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[17:16] 
;;;281    			SYS->GPA_ALT.GPA9 	=1;		// UART_RX: (0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[19:18]
;;;282    		}break;
;;;283    		
;;;284    		case FUNC_UART0_FLOW:
;;;285    		{
;;;286    			SYS->GPA_ALT.GPA8	=1;		// UART_TX: (0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[17:16] 
;;;287    			SYS->GPA_ALT.GPA9 	=1;		// UART_RX: (0x5000_0000 + 14<<2)[31:0]= 0x5000_0038[19:18]
;;;288    			SYS->GPA_ALT.GPA10 	=3;		// UART_RTSn
;;;289    			SYS->GPA_ALT.GPA11	=3;		// UART_CTSn
;;;290    		}break;
;;;291    
;;;292    		/*---------------------------------------------------------------------------------------------------------*/
;;;293    		/* TIMER                                                                                                   */
;;;294    		/*---------------------------------------------------------------------------------------------------------*/
;;;295    		case FUNC_TMR0:
;;;296    		{
;;;297    			SYS->GPA_ALT.GPA14 		=1;	   // TM0
;;;298    		}break;
;;;299    	
;;;300    		case FUNC_TMR1:
;;;301    		{
;;;302    			SYS->GPA_ALT.GPA15 		=1;	   // TM1
;;;303    		}break;
;;;304    
;;;305    		/*---------------------------------------------------------------------------------------------------------*/
;;;306    		/* MCLK                                                                                                    */
;;;307    		/*---------------------------------------------------------------------------------------------------------*/
;;;308    		case FUNC_MCLK0:
;;;309    		{
;;;310    			SYS->GPA_ALT.GPA0 		=2;	   
;;;311    		}break;
;;;312    
;;;313    		case FUNC_MCLK1:
;;;314    		{
;;;315    			SYS->GPB_ALT.GPB1 		=1;	   
;;;316    		}break;
;;;317    
;;;318      		/*---------------------------------------------------------------------------------------------------------*/
;;;319    		/* DMIC                                                 				                                   */
;;;320    		/*---------------------------------------------------------------------------------------------------------*/
;;;321    	  	case FUNC_DMIC0:
;;;322    		{
;;;323    			SYS->GPA_ALT.GPA14 		=2;		//SDCLK
;;;324    			SYS->GPA_ALT.GPA15 		=2;	    //SDIN
;;;325    		}break;
;;;326    
;;;327    	  	case FUNC_DMIC1:
;;;328    		{
;;;329    			SYS->GPA_ALT.GPA14 		=3;		//!SDCLK
;;;330    			SYS->GPA_ALT.GPA15 		=2;	    //SDIN
;;;331    		}break;
;;;332    
;;;333    		/*---------------------------------------------------------------------------------------------------------*/
;;;334    		/* SPK   									                                                               */
;;;335    		/*---------------------------------------------------------------------------------------------------------*/
;;;336    		case FUNC_SPK:
;;;337    		{
;;;338    			SYS->GPA_ALT.GPA12 		=2;		//SPKP
;;;339    			SYS->GPA_ALT.GPA13		=2;		//SPKM
;;;340    		}break;
;;;341    
;;;342    		/*---------------------------------------------------------------------------------------------------------*/
;;;343    		/* NONE: user will configure GPIO manually	                                                               */
;;;344    		/*---------------------------------------------------------------------------------------------------------*/
;;;345    		case FUNC_NONE:
;;;346    		{
;;;347    		}break;
;;;348    
;;;349    		default:
;;;350    			return E_DRVGPIO_ARGUMENT;
;;;351    	}
;;;352    
;;;353    	return E_SUCCESS;
00008e  2000              MOVS     r0,#0
;;;354    }
000090  bdf0              POP      {r4-r7,pc}
000092  6b88              LDR      r0,[r1,#0x38]         ;206
000094  43a0              BICS     r0,r0,r4              ;206
000096  3008              ADDS     r0,r0,#8              ;206
000098  6388              STR      r0,[r1,#0x38]         ;206
00009a  6b88              LDR      r0,[r1,#0x38]         ;207
00009c  4390              BICS     r0,r0,r2              ;207
00009e  3080              ADDS     r0,r0,#0x80           ;207
0000a0  e7f4              B        |L20.140|
0000a2  6bc8              LDR      r0,[r1,#0x3c]         ;212
0000a4  43a8              BICS     r0,r0,r5              ;212
0000a6  3010              ADDS     r0,r0,#0x10           ;212
0000a8  63c8              STR      r0,[r1,#0x3c]         ;212
0000aa  6bc8              LDR      r0,[r1,#0x3c]         ;213
0000ac  4390              BICS     r0,r0,r2              ;213
0000ae  3040              ADDS     r0,r0,#0x40           ;213
0000b0  e7db              B        |L20.106|
0000b2  6b88              LDR      r0,[r1,#0x38]         ;221
0000b4  43b0              BICS     r0,r0,r6              ;221
0000b6  30ff              ADDS     r0,r0,#0xff           ;221
0000b8  3001              ADDS     r0,#1                 ;221
0000ba  6388              STR      r0,[r1,#0x38]         ;221
0000bc  6b8a              LDR      r2,[r1,#0x38]         ;222
0000be  2003              MOVS     r0,#3                 ;222
0000c0  0280              LSLS     r0,r0,#10             ;222
0000c2  4382              BICS     r2,r2,r0              ;222
0000c4  2001              MOVS     r0,#1                 ;222
0000c6  0280              LSLS     r0,r0,#10             ;222
0000c8  1810              ADDS     r0,r2,r0              ;222
0000ca  6388              STR      r0,[r1,#0x38]         ;222
0000cc  6b88              LDR      r0,[r1,#0x38]         ;223
0000ce  2203              MOVS     r2,#3                 ;223
0000d0  0312              LSLS     r2,r2,#12             ;223
0000d2  4390              BICS     r0,r0,r2              ;223
0000d4  2201              MOVS     r2,#1                 ;223
0000d6  0312              LSLS     r2,r2,#12             ;223
0000d8  1880              ADDS     r0,r0,r2              ;223
0000da  6388              STR      r0,[r1,#0x38]         ;223
0000dc  6b8a              LDR      r2,[r1,#0x38]         ;224
0000de  2003              MOVS     r0,#3                 ;224
0000e0  0380              LSLS     r0,r0,#14             ;224
0000e2  4382              BICS     r2,r2,r0              ;224
0000e4  2001              MOVS     r0,#1                 ;224
0000e6  0380              LSLS     r0,r0,#14             ;224
0000e8  e0d6              B        |L20.664|
0000ea  6b88              LDR      r0,[r1,#0x38]         ;229
0000ec  2201              MOVS     r2,#1                 ;229
0000ee  43b8              BICS     r0,r0,r7              ;229
0000f0  0452              LSLS     r2,r2,#17             ;229
0000f2  1880              ADDS     r0,r0,r2              ;229
0000f4  6388              STR      r0,[r1,#0x38]         ;229
0000f6  6b8a              LDR      r2,[r1,#0x38]         ;230
0000f8  2003              MOVS     r0,#3                 ;230
0000fa  0480              LSLS     r0,r0,#18             ;230
0000fc  4382              BICS     r2,r2,r0              ;230
0000fe  2001              MOVS     r0,#1                 ;230
000100  04c0              LSLS     r0,r0,#19             ;230
000102  1810              ADDS     r0,r2,r0              ;230
000104  6388              STR      r0,[r1,#0x38]         ;230
000106  6b8a              LDR      r2,[r1,#0x38]         ;231
000108  2003              MOVS     r0,#3                 ;231
00010a  0500              LSLS     r0,r0,#20             ;231
00010c  4382              BICS     r2,r2,r0              ;231
00010e  2001              MOVS     r0,#1                 ;231
000110  0540              LSLS     r0,r0,#21             ;231
000112  1810              ADDS     r0,r2,r0              ;231
000114  6388              STR      r0,[r1,#0x38]         ;231
000116  6b8a              LDR      r2,[r1,#0x38]         ;232
000118  2003              MOVS     r0,#3                 ;232
00011a  0580              LSLS     r0,r0,#22             ;232
00011c  4382              BICS     r2,r2,r0              ;232
00011e  2001              MOVS     r0,#1                 ;232
000120  05c0              LSLS     r0,r0,#23             ;232
000122  e0b9              B        |L20.664|
000124  6b88              LDR      r0,[r1,#0x38]         ;240
000126  0880              LSRS     r0,r0,#2              ;240
000128  0080              LSLS     r0,r0,#2              ;240
00012a  1c40              ADDS     r0,r0,#1              ;240
00012c  6388              STR      r0,[r1,#0x38]         ;240
00012e  6b88              LDR      r0,[r1,#0x38]         ;241
000130  43a0              BICS     r0,r0,r4              ;241
000132  1d00              ADDS     r0,r0,#4              ;241
000134  6388              STR      r0,[r1,#0x38]         ;241
000136  6b88              LDR      r0,[r1,#0x38]         ;242
000138  43a8              BICS     r0,r0,r5              ;242
00013a  3010              ADDS     r0,r0,#0x10           ;242
00013c  6388              STR      r0,[r1,#0x38]         ;242
00013e  6b88              LDR      r0,[r1,#0x38]         ;243
000140  4390              BICS     r0,r0,r2              ;243
000142  3040              ADDS     r0,r0,#0x40           ;243
000144  e7a2              B        |L20.140|
000146  6bc8              LDR      r0,[r1,#0x3c]         ;248
000148  2303              MOVS     r3,#3                 ;248
00014a  4318              ORRS     r0,r0,r3              ;248
00014c  63c8              STR      r0,[r1,#0x3c]         ;248
00014e  6bc8              LDR      r0,[r1,#0x3c]         ;249
000150  4328              ORRS     r0,r0,r5              ;249
000152  63c8              STR      r0,[r1,#0x3c]         ;249
000154  6bc8              LDR      r0,[r1,#0x3c]         ;250
000156  4310              ORRS     r0,r0,r2              ;250
000158  63c8              STR      r0,[r1,#0x3c]         ;250
00015a  6bc8              LDR      r0,[r1,#0x3c]         ;251
00015c  4330              ORRS     r0,r0,r6              ;251
00015e  e784              B        |L20.106|
000160  6bc8              LDR      r0,[r1,#0x3c]         ;259
000162  0880              LSRS     r0,r0,#2              ;259
000164  0080              LSLS     r0,r0,#2              ;259
000166  1c80              ADDS     r0,r0,#2              ;259
000168  63c8              STR      r0,[r1,#0x3c]         ;259
00016a  6bc8              LDR      r0,[r1,#0x3c]         ;260
00016c  43a0              BICS     r0,r0,r4              ;260
00016e  3008              ADDS     r0,r0,#8              ;260
000170  63c8              STR      r0,[r1,#0x3c]         ;260
000172  6bc8              LDR      r0,[r1,#0x3c]         ;261
000174  43a8              BICS     r0,r0,r5              ;261
000176  3020              ADDS     r0,r0,#0x20           ;261
000178  63c8              STR      r0,[r1,#0x3c]         ;261
00017a  6bc8              LDR      r0,[r1,#0x3c]         ;262
00017c  4390              BICS     r0,r0,r2              ;262
00017e  3080              ADDS     r0,r0,#0x80           ;262
000180  63c8              STR      r0,[r1,#0x3c]         ;262
000182  6bc8              LDR      r0,[r1,#0x3c]         ;263
000184  43b0              BICS     r0,r0,r6              ;263
000186  30ff              ADDS     r0,r0,#0xff           ;263
000188  30ff              ADDS     r0,r0,#0xff           ;263
00018a  3002              ADDS     r0,#2                 ;263
00018c  63c8              STR      r0,[r1,#0x3c]         ;263
00018e  6bca              LDR      r2,[r1,#0x3c]         ;264
000190  2003              MOVS     r0,#3                 ;264
000192  0280              LSLS     r0,r0,#10             ;264
000194  4382              BICS     r2,r2,r0              ;264
000196  2001              MOVS     r0,#1                 ;264
000198  02c0              LSLS     r0,r0,#11             ;264
00019a  1810              ADDS     r0,r2,r0              ;264
00019c  63c8              STR      r0,[r1,#0x3c]         ;264
00019e  6bca              LDR      r2,[r1,#0x3c]         ;265
0001a0  2003              MOVS     r0,#3                 ;265
0001a2  0300              LSLS     r0,r0,#12             ;265
0001a4  4382              BICS     r2,r2,r0              ;265
0001a6  2001              MOVS     r0,#1                 ;265
0001a8  0340              LSLS     r0,r0,#13             ;265
0001aa  1810              ADDS     r0,r2,r0              ;265
0001ac  e006              B        |L20.444|
0001ae  6bc8              LDR      r0,[r1,#0x3c]         ;271
0001b0  2203              MOVS     r2,#3                 ;271
0001b2  0312              LSLS     r2,r2,#12             ;271
0001b4  4390              BICS     r0,r0,r2              ;271
0001b6  2201              MOVS     r2,#1                 ;271
0001b8  0352              LSLS     r2,r2,#13             ;271
0001ba  1880              ADDS     r0,r0,r2              ;271
                  |L20.444|
0001bc  63c8              STR      r0,[r1,#0x3c]         ;271
0001be  6bca              LDR      r2,[r1,#0x3c]         ;272
0001c0  2003              MOVS     r0,#3                 ;272
0001c2  0380              LSLS     r0,r0,#14             ;272
0001c4  4382              BICS     r2,r2,r0              ;272
0001c6  2001              MOVS     r0,#1                 ;272
0001c8  03c0              LSLS     r0,r0,#15             ;272
0001ca  1810              ADDS     r0,r2,r0              ;272
0001cc  e74d              B        |L20.106|
0001ce  6b88              LDR      r0,[r1,#0x38]         ;280
0001d0  2201              MOVS     r2,#1                 ;280
0001d2  43b8              BICS     r0,r0,r7              ;280
0001d4  0412              LSLS     r2,r2,#16             ;280
0001d6  1880              ADDS     r0,r0,r2              ;280
0001d8  6388              STR      r0,[r1,#0x38]         ;280
0001da  6b8a              LDR      r2,[r1,#0x38]         ;281
0001dc  2003              MOVS     r0,#3                 ;281
0001de  0480              LSLS     r0,r0,#18             ;281
0001e0  4382              BICS     r2,r2,r0              ;281
0001e2  2001              MOVS     r0,#1                 ;281
0001e4  0480              LSLS     r0,r0,#18             ;281
0001e6  e057              B        |L20.664|
0001e8  e058              B        |L20.668|
0001ea  e047              B        |L20.636|
0001ec  e03a              B        |L20.612|
0001ee  e031              B        |L20.596|
0001f0  e02c              B        |L20.588|
0001f2  e026              B        |L20.578|
0001f4  e01f              B        |L20.566|
0001f6  e017              B        |L20.552|
0001f8  e7ff              B        |L20.506|
                  |L20.506|
0001fa  6b88              LDR      r0,[r1,#0x38]         ;286
0001fc  2201              MOVS     r2,#1                 ;286
0001fe  43b8              BICS     r0,r0,r7              ;286
000200  0412              LSLS     r2,r2,#16             ;286
000202  1880              ADDS     r0,r0,r2              ;286
000204  6388              STR      r0,[r1,#0x38]         ;286
000206  6b8a              LDR      r2,[r1,#0x38]         ;287
000208  2003              MOVS     r0,#3                 ;287
00020a  0480              LSLS     r0,r0,#18             ;287
00020c  4382              BICS     r2,r2,r0              ;287
00020e  2001              MOVS     r0,#1                 ;287
000210  0480              LSLS     r0,r0,#18             ;287
000212  1810              ADDS     r0,r2,r0              ;287
000214  6388              STR      r0,[r1,#0x38]         ;287
000216  6b88              LDR      r0,[r1,#0x38]         ;288
000218  2203              MOVS     r2,#3                 ;288
00021a  0512              LSLS     r2,r2,#20             ;288
00021c  4310              ORRS     r0,r0,r2              ;288
00021e  6388              STR      r0,[r1,#0x38]         ;288
000220  6b88              LDR      r0,[r1,#0x38]         ;289
000222  0092              LSLS     r2,r2,#2              ;289
000224  4310              ORRS     r0,r0,r2              ;289
000226  e731              B        |L20.140|
                  |L20.552|
000228  6b88              LDR      r0,[r1,#0x38]         ;297
00022a  2203              MOVS     r2,#3                 ;297
00022c  0712              LSLS     r2,r2,#28             ;297
00022e  4390              BICS     r0,r0,r2              ;297
000230  2201              MOVS     r2,#1                 ;297
000232  0712              LSLS     r2,r2,#28             ;297
000234  e020              B        |L20.632|
                  |L20.566|
000236  6b88              LDR      r0,[r1,#0x38]         ;302
000238  2201              MOVS     r2,#1                 ;302
00023a  0080              LSLS     r0,r0,#2              ;302
00023c  0880              LSRS     r0,r0,#2              ;302
00023e  0792              LSLS     r2,r2,#30             ;302
000240  e01a              B        |L20.632|
                  |L20.578|
000242  6b88              LDR      r0,[r1,#0x38]         ;310
000244  0880              LSRS     r0,r0,#2              ;310
000246  0080              LSLS     r0,r0,#2              ;310
000248  1c80              ADDS     r0,r0,#2              ;310
00024a  e71f              B        |L20.140|
                  |L20.588|
00024c  6bc8              LDR      r0,[r1,#0x3c]         ;315
00024e  43a0              BICS     r0,r0,r4              ;315
000250  1d00              ADDS     r0,r0,#4              ;315
000252  e70a              B        |L20.106|
                  |L20.596|
000254  6b88              LDR      r0,[r1,#0x38]         ;323
000256  2203              MOVS     r2,#3                 ;323
000258  0712              LSLS     r2,r2,#28             ;323
00025a  4390              BICS     r0,r0,r2              ;323
00025c  2201              MOVS     r2,#1                 ;323
00025e  0752              LSLS     r2,r2,#29             ;323
000260  1880              ADDS     r0,r0,r2              ;323
000262  e003              B        |L20.620|
                  |L20.612|
000264  6b88              LDR      r0,[r1,#0x38]         ;329
000266  2203              MOVS     r2,#3                 ;329
000268  0712              LSLS     r2,r2,#28             ;329
00026a  4310              ORRS     r0,r0,r2              ;329
                  |L20.620|
00026c  6388              STR      r0,[r1,#0x38]         ;329
00026e  6b88              LDR      r0,[r1,#0x38]         ;330
000270  2201              MOVS     r2,#1                 ;330
000272  0080              LSLS     r0,r0,#2              ;330
000274  0880              LSRS     r0,r0,#2              ;330
000276  07d2              LSLS     r2,r2,#31             ;330
                  |L20.632|
000278  1880              ADDS     r0,r0,r2              ;330
00027a  e707              B        |L20.140|
                  |L20.636|
00027c  6b88              LDR      r0,[r1,#0x38]         ;338
00027e  2203              MOVS     r2,#3                 ;338
000280  0612              LSLS     r2,r2,#24             ;338
000282  4390              BICS     r0,r0,r2              ;338
000284  2201              MOVS     r2,#1                 ;338
000286  0652              LSLS     r2,r2,#25             ;338
000288  1880              ADDS     r0,r0,r2              ;338
00028a  6388              STR      r0,[r1,#0x38]         ;338
00028c  6b8a              LDR      r2,[r1,#0x38]         ;339
00028e  2003              MOVS     r0,#3                 ;339
000290  0680              LSLS     r0,r0,#26             ;339
000292  4382              BICS     r2,r2,r0              ;339
000294  2001              MOVS     r0,#1                 ;339
000296  06c0              LSLS     r0,r0,#27             ;339
                  |L20.664|
000298  1810              ADDS     r0,r2,r0              ;339
00029a  e6f7              B        |L20.140|
                  |L20.668|
00029c  4800              LDR      r0,|L20.672|
00029e  bdf0              POP      {r4-r7,pc}
;;;355    
                          ENDP

                  |L20.672|
                          DCD      0xffff8901

                          AREA ||i.DrvGPIO_Open||, CODE, READONLY, ALIGN=2

                  DrvGPIO_Open PROC
;;;402    
;;;403    int32_t DrvGPIO_Open(DRVGPIO_PORT port,int32_t i32Bit,DRVGPIO_IO mode)
000000  b570              PUSH     {r4-r6,lr}
;;;404    {
000002  4605              MOV      r5,r0
;;;405        if(port > GPB)
;;;406        {
;;;407            return E_DRVGPIO_ARGUMENT;
000004  4815              LDR      r0,|L21.92|
000006  2d01              CMP      r5,#1                 ;405
000008  d816              BHI      |L21.56|
;;;408        }
;;;409        
;;;410        if((i32Bit < 0) || (i32Bit > 16))
00000a  2911              CMP      r1,#0x11
00000c  d214              BCS      |L21.56|
;;;411        {
;;;412            return E_DRVGPIO_ARGUMENT;
;;;413        }
;;;414        
;;;415        
;;;416        if(mode == IO_INPUT)
;;;417        {
;;;418            outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, (inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) & (~(3 << (i32Bit * 2)))));
00000e  2303              MOVS     r3,#3
000010  004c              LSLS     r4,r1,#1
000012  4e13              LDR      r6,|L21.96|
000014  40a3              LSLS     r3,r3,r4
000016  01a9              LSLS     r1,r5,#6
000018  1989              ADDS     r1,r1,r6
00001a  2a00              CMP      r2,#0                 ;416
00001c  d00d              BEQ      |L21.58|
;;;419        }
;;;420        else if(mode == IO_OUTPUT)
00001e  2a01              CMP      r2,#1
000020  d00e              BEQ      |L21.64|
;;;421        {
;;;422    		outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, (inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) & (~(3 << (i32Bit * 2)))));
;;;423            outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) | (1 << (i32Bit * 2)));
;;;424        }
;;;425        else if(mode == IO_OPENDRAIN)
000022  2a02              CMP      r2,#2
000024  d012              BEQ      |L21.76|
;;;426        {
;;;427    		outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, (inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) & (~(3 << (i32Bit * 2)))));
;;;428            outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) | (2 << (i32Bit * 2)));
;;;429        }
;;;430    	else if(mode == IO_QUASI)
000026  2a03              CMP      r2,#3
000028  d106              BNE      |L21.56|
;;;431        {
;;;432    		outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, (inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) & (~(3 << (i32Bit * 2)))));
00002a  6808              LDR      r0,[r1,#0]
00002c  4398              BICS     r0,r0,r3
00002e  6008              STR      r0,[r1,#0]
;;;433            outpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET, inpw((uint32_t)&GPIOA->PMD + port * PORT_OFFSET) | (3 << (i32Bit * 2)));
000030  6808              LDR      r0,[r1,#0]
000032  4318              ORRS     r0,r0,r3
                  |L21.52|
000034  6008              STR      r0,[r1,#0]
;;;434        }
;;;435    	else
;;;436        {
;;;437            return E_DRVGPIO_ARGUMENT;
;;;438        }
;;;439            
;;;440    	return E_SUCCESS;
000036  2000              MOVS     r0,#0
                  |L21.56|
;;;441    }
000038  bd70              POP      {r4-r6,pc}
                  |L21.58|
00003a  6808              LDR      r0,[r1,#0]            ;418
00003c  4398              BICS     r0,r0,r3              ;418
00003e  e7f9              B        |L21.52|
                  |L21.64|
000040  6808              LDR      r0,[r1,#0]            ;422
000042  4398              BICS     r0,r0,r3              ;422
000044  6008              STR      r0,[r1,#0]            ;422
000046  6808              LDR      r0,[r1,#0]            ;423
000048  2201              MOVS     r2,#1                 ;423
00004a  e004              B        |L21.86|
                  |L21.76|
00004c  6808              LDR      r0,[r1,#0]            ;427
00004e  4398              BICS     r0,r0,r3              ;427
000050  6008              STR      r0,[r1,#0]            ;427
000052  6808              LDR      r0,[r1,#0]            ;428
000054  2202              MOVS     r2,#2                 ;428
                  |L21.86|
000056  40a2              LSLS     r2,r2,r4              ;423
000058  4310              ORRS     r0,r0,r2              ;423
00005a  e7eb              B        |L21.52|
;;;442    
                          ENDP

                  |L21.92|
                          DCD      0xffff8901
                  |L21.96|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetBit PROC
;;;545    
;;;546    int32_t DrvGPIO_SetBit(DRVGPIO_PORT port,int32_t i32Bit)
000000  4b0c              LDR      r3,|L22.52|
;;;547    {
;;;548      if(port > GPB)
000002  2801              CMP      r0,#1
000004  d807              BHI      |L22.22|
;;;549        {
;;;550            return E_DRVGPIO_ARGUMENT;
;;;551        }
;;;552    
;;;553        if((i32Bit < 0) || (i32Bit > 16))
000006  2911              CMP      r1,#0x11
000008  d205              BCS      |L22.22|
;;;554        {
;;;555            return E_DRVGPIO_ARGUMENT;
;;;556        }
;;;557    
;;;558        if(port == GPA)
;;;559    		GPIOA->DOUT |=	1 << i32Bit;
00000a  2201              MOVS     r2,#1
00000c  408a              LSLS     r2,r2,r1
00000e  2800              CMP      r0,#0                 ;558
000010  d003              BEQ      |L22.26|
;;;560    	else if(port == GPB)
000012  2801              CMP      r0,#1
000014  d006              BEQ      |L22.36|
                  |L22.22|
;;;561    		GPIOB->DOUT |=	1 << i32Bit;
;;;562    	else
;;;563    		return E_DRVGPIO_ARGUMENT;	
000016  4618              MOV      r0,r3
;;;564    
;;;565    	return E_SUCCESS;
;;;566    
;;;567    }
000018  4770              BX       lr
                  |L22.26|
00001a  4807              LDR      r0,|L22.56|
00001c  6881              LDR      r1,[r0,#8]            ;559
00001e  4311              ORRS     r1,r1,r2              ;559
000020  6081              STR      r1,[r0,#8]            ;559
000022  e004              B        |L22.46|
                  |L22.36|
000024  4904              LDR      r1,|L22.56|
000026  3140              ADDS     r1,r1,#0x40           ;561
000028  6888              LDR      r0,[r1,#8]            ;561
00002a  4310              ORRS     r0,r0,r2              ;561
00002c  6088              STR      r0,[r1,#8]            ;561
                  |L22.46|
00002e  2000              MOVS     r0,#0                 ;565
000030  4770              BX       lr
;;;568    
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      0xffff8901
                  |L22.56|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetBitMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetBitMask PROC
;;;796    /*---------------------------------------------------------------------------------------------------------*/
;;;797    int32_t DrvGPIO_SetBitMask(DRVGPIO_PORT port, int32_t i32Bit)
000000  0182              LSLS     r2,r0,#6
;;;798    {
;;;799    
;;;800    	outpw((uint32_t)&GPIOA->DMASK+ port*PORT_OFFSET , inpw((uint32_t)&GPIOA->DMASK+ port*PORT_OFFSET) | (1<<i32Bit));
000002  4804              LDR      r0,|L23.20|
000004  1810              ADDS     r0,r2,r0
000006  68c2              LDR      r2,[r0,#0xc]
000008  2301              MOVS     r3,#1
00000a  408b              LSLS     r3,r3,r1
00000c  431a              ORRS     r2,r2,r3
00000e  60c2              STR      r2,[r0,#0xc]
;;;801    
;;;802    	return E_SUCCESS;
000010  2000              MOVS     r0,#0
;;;803    }
000012  4770              BX       lr
;;;804    
                          ENDP

                  |L23.20|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetDebounceTime||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetDebounceTime PROC
;;;668    
;;;669    int32_t DrvGPIO_SetDebounceTime(uint32_t u32DebounceClk,DRVGPIO_DBCLKSRC clockSource)
000000  280f              CMP      r0,#0xf
;;;670    {
;;;671    
;;;672        /* Maximum debounce time is 2^(15) * clockSource */
;;;673        if(u32DebounceClk > 15)
000002  d900              BLS      |L24.6|
;;;674        {
;;;675            u32DebounceClk = 15;
000004  200f              MOVS     r0,#0xf
                  |L24.6|
;;;676        }
;;;677        
;;;678    	GPIO_DBNCECON->DBCLKSEL = u32DebounceClk ; // 0x5000_4180[3:0]
000006  4a08              LDR      r2,|L24.40|
000008  6813              LDR      r3,[r2,#0]
00000a  0700              LSLS     r0,r0,#28
00000c  091b              LSRS     r3,r3,#4
00000e  011b              LSLS     r3,r3,#4
000010  0f00              LSRS     r0,r0,#28
000012  4303              ORRS     r3,r3,r0
000014  6013              STR      r3,[r2,#0]
;;;679    
;;;680    	GPIO_DBNCECON->DBCLKSRC = clockSource ; // 0x5000_4180[4]
000016  6810              LDR      r0,[r2,#0]
000018  2310              MOVS     r3,#0x10
00001a  07c9              LSLS     r1,r1,#31
00001c  4398              BICS     r0,r0,r3
00001e  0ec9              LSRS     r1,r1,#27
000020  4308              ORRS     r0,r0,r1
000022  6010              STR      r0,[r2,#0]
;;;681    
;;;682        return E_SUCCESS;
000024  2000              MOVS     r0,#0
;;;683    }
000026  4770              BX       lr
;;;684    
                          ENDP

                  |L24.40|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_SetIntCallback||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetIntCallback PROC
;;;112    /*---------------------------------------------------------------------------------------------------------*/
;;;113    void DrvGPIO_SetIntCallback(
000000  4901              LDR      r1,|L25.8|
;;;114        GPIO_GPAB_CALLBACK pfGPABCallback
;;;115    )
;;;116    {
;;;117        _pfGPABCallback  = (void (*)(uint32_t, uint32_t))pfGPABCallback;
000002  6008              STR      r0,[r1,#0]  ; _pfGPABCallback
;;;118          
;;;119    }
000004  4770              BX       lr
;;;120    
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      ||.data||

                          AREA ||i.DrvGPIO_SetPortBits||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetPortBits PROC
;;;456    
;;;457    int32_t DrvGPIO_SetPortBits(DRVGPIO_PORT port,int32_t i32Data)
000000  4a07              LDR      r2,|L26.32|
;;;458    {
;;;459        if(port > GPB)
000002  2801              CMP      r0,#1
000004  d803              BHI      |L26.14|
;;;460        {
;;;461            return E_DRVGPIO_ARGUMENT;
;;;462        }
;;;463        
;;;464        if(port == GPA)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L26.18|
;;;465    		GPIOA->DOUT =	i32Data; //(0x5000_0000 + 2<<2)[31:0]= 0x5000_0004[31:0]
;;;466    	else if(port == GPB)
00000a  2801              CMP      r0,#1
00000c  d003              BEQ      |L26.22|
                  |L26.14|
;;;467    		GPIOB->DOUT =	i32Data; //(0x5000_0040 + 2<<2)[31:0]= 0x5000_0044[31:0]
;;;468    	else
;;;469    		return E_DRVGPIO_ARGUMENT;	
00000e  4610              MOV      r0,r2
;;;470    
;;;471        return E_SUCCESS;
;;;472    }
000010  4770              BX       lr
                  |L26.18|
000012  4804              LDR      r0,|L26.36|
000014  e001              B        |L26.26|
                  |L26.22|
000016  4803              LDR      r0,|L26.36|
000018  3040              ADDS     r0,r0,#0x40           ;467
                  |L26.26|
00001a  6081              STR      r1,[r0,#8]            ;467
00001c  2000              MOVS     r0,#0                 ;471
00001e  4770              BX       lr
;;;473    
                          ENDP

                  |L26.32|
                          DCD      0xffff8901
                  |L26.36|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetPortMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetPortMask PROC
;;;771    /*---------------------------------------------------------------------------------------------------------*/
;;;772    int32_t DrvGPIO_SetPortMask(DRVGPIO_PORT port, uint32_t u32Mask)
000000  2801              CMP      r0,#1
;;;773    {
;;;774        if(port > GPB)
000002  d901              BLS      |L27.8|
;;;775    		return E_DRVGPIO_ARGUMENT;	
000004  4803              LDR      r0,|L27.20|
;;;776    
;;;777    	//&GPIOA->DMASK: (0x5000_4000 + 3<< 4)[31:0] = 0x5000_400C[31:0]
;;;778        outpw((uint32_t)&GPIOA->DMASK + port * PORT_OFFSET, u32Mask);
;;;779    
;;;780        return E_SUCCESS;
;;;781    }
000006  4770              BX       lr
                  |L27.8|
000008  4a03              LDR      r2,|L27.24|
00000a  0180              LSLS     r0,r0,#6              ;778
00000c  1880              ADDS     r0,r0,r2              ;778
00000e  60c1              STR      r1,[r0,#0xc]          ;778
000010  2000              MOVS     r0,#0                 ;780
000012  4770              BX       lr
;;;782    
                          ENDP

                  |L27.20|
                          DCD      0xffff8901
                  |L27.24|
                          DCD      0x50004000

                          AREA ||i.EINT0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EINT0_IRQHandler PROC
;;;74     /*---------------------------------------------------------------------------------------------------------*/
;;;75     void EINT0_IRQHandler(void)
000000  4904              LDR      r1,|L28.20|
;;;76     {
;;;77         /* EINT0 = GPB0. Clear the interrupt */
;;;78       	GPIOB->ISRC  = 1UL << 0;
000002  2001              MOVS     r0,#1
000004  6208              STR      r0,[r1,#0x20]
;;;79     	if(_pfEINT0Callback)
000006  4804              LDR      r0,|L28.24|
000008  6840              LDR      r0,[r0,#4]  ; _pfEINT0Callback
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L28.16|
;;;80             _pfEINT0Callback();
00000e  4700              BX       r0
                  |L28.16|
;;;81     }
000010  4770              BX       lr
;;;82     
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      0x50004040
                  |L28.24|
                          DCD      ||.data||

                          AREA ||i.EINT1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EINT1_IRQHandler PROC
;;;93     /*---------------------------------------------------------------------------------------------------------*/
;;;94     void EINT1_IRQHandler(void)
000000  4904              LDR      r1,|L29.20|
;;;95     {
;;;96         /* EINT1 = GPB1. Clear the interrupt */
;;;97       	GPIOB->ISRC  = 1UL << 1;
000002  2002              MOVS     r0,#2
000004  6208              STR      r0,[r1,#0x20]
;;;98     	if(_pfEINT1Callback)
000006  4804              LDR      r0,|L29.24|
000008  6880              LDR      r0,[r0,#8]  ; _pfEINT1Callback
00000a  2800              CMP      r0,#0
00000c  d000              BEQ      |L29.16|
;;;99             _pfEINT1Callback();
00000e  4700              BX       r0
                  |L29.16|
;;;100    }
000010  4770              BX       lr
;;;101    
                          ENDP

000012  0000              DCW      0x0000
                  |L29.20|
                          DCD      0x50004040
                  |L29.24|
                          DCD      ||.data||

                          AREA ||i.GPAB_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPAB_IRQHandler PROC
;;;40     //#ifdef USE_DRIVER_GPIO_IRQ
;;;41     void GPAB_IRQHandler(void)
000000  4a06              LDR      r2,|L30.28|
;;;42     {
;;;43     	uint32_t u32GpaStatus, u32GpbStatus;
;;;44     	
;;;45         /* Keep the interrupt source */
;;;46     	u32GpaStatus = GPIOA->ISRC;// (0x5000_4000 + 8 << 2)[31:0] = 0x5000_4020[31:0]
000002  6a10              LDR      r0,[r2,#0x20]
;;;47     	u32GpbStatus = GPIOB->ISRC;// (0x5000_4040 + 8 << 2)[31:0] = 0x5000_4060[31:0]
000004  4b05              LDR      r3,|L30.28|
000006  3340              ADDS     r3,r3,#0x40
000008  6a19              LDR      r1,[r3,#0x20]
;;;48     
;;;49         /* Clear the interrupt */
;;;50         GPIOA->ISRC = u32GpaStatus;
00000a  6210              STR      r0,[r2,#0x20]
;;;51         GPIOB->ISRC = u32GpbStatus;
00000c  6219              STR      r1,[r3,#0x20]
;;;52     
;;;53         /* Call the callback function of GPIOAB interrupt */
;;;54         if(_pfGPABCallback)
00000e  4a04              LDR      r2,|L30.32|
000010  6812              LDR      r2,[r2,#0]  ; _pfGPABCallback
000012  2a00              CMP      r2,#0
000014  d000              BEQ      |L30.24|
;;;55             _pfGPABCallback(u32GpaStatus, u32GpbStatus);    
000016  4710              BX       r2
                  |L30.24|
;;;56     
;;;57     }
000018  4770              BX       lr
;;;58     //	  #endif
                          ENDP

00001a  0000              DCW      0x0000
                  |L30.28|
                          DCD      0x50004000
                  |L30.32|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  _pfGPABCallback
                          DCD      0x00000000
                  _pfEINT0Callback
                          DCD      0x00000000
                  _pfEINT1Callback
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L189.16|
00000e  461d              MOV      r5,r3
                  |L189.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Src\\Driver\\DrvGPIO.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_DrvGPIO_c_90e6b153____REV16|
#line 112 "..\\..\\..\\..\\CMSIS\\CM0\\CoreSupport\\core_cmInstr.h"
|__asm___9_DrvGPIO_c_90e6b153____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_DrvGPIO_c_90e6b153____REVSH|
#line 130
|__asm___9_DrvGPIO_c_90e6b153____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
