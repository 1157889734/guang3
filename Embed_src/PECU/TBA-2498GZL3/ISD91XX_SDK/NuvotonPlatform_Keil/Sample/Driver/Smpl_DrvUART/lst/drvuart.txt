; generated by ARM C/C++ Compiler, 4.1 [Build 791]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\drvuart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\drvuart.d --cpu=Cortex-M0 --apcs=interwork -I.\ -I..\..\..\..\HW -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\ISD91xx -I..\..\..\Include -I..\..\..\Include\Driver -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\INC\?ST\STM32F10x --omf_browse=.\obj\drvuart.crf ..\..\..\Src\Driver\DrvUART.c]
                          THUMB

                          AREA ||i.DrvUART_BaudRateCalculator||, CODE, READONLY, ALIGN=2

                  DrvUART_BaudRateCalculator PROC
;;;62     /*---------------------------------------------------------------------------------------------------------*/
;;;63     void DrvUART_BaudRateCalculator(uint32_t i32clk, uint32_t i32baudRate, UART_BAUD_T *baud)
000000  b5f8              PUSH     {r3-r7,lr}
;;;64     {
000002  4614              MOV      r4,r2
;;;65       	int32_t i32tmp;
;;;66     	int32_t i32div;
;;;67     
;;;68     	if(((i32clk / i32baudRate)%16)<3)	      /* Source Clock mod 16 <3 => Using Divider X =16 (MODE#0) */
000004  f7fffffe          BL       __aeabi_uidivmod
000008  0702              LSLS     r2,r0,#28
00000a  4607              MOV      r7,r0
;;;69     	{
;;;70     		baud->DIVX_EN = 0;
00000c  2001              MOVS     r0,#1
00000e  0740              LSLS     r0,r0,#29
000010  0f12              LSRS     r2,r2,#28             ;68
;;;71     	    baud->DIVX_ONE   = 0;
000012  1041              ASRS     r1,r0,#1
000014  2a03              CMP      r2,#3                 ;68
;;;72     		i32tmp = i32clk / i32baudRate/16  -2;
;;;73     	}
;;;74     	else							  /* Source Clock mod 16 >3 => Up 5% Error BaudRate */
;;;75     	{
;;;76     	    baud->DIVX_EN = 1;			  /* Try to Set Divider X = 1 (MODE#2)*/
000016  6822              LDR      r2,[r4,#0]
000018  d207              BCS      |L1.42|
00001a  4382              BICS     r2,r2,r0              ;70
00001c  6022              STR      r2,[r4,#0]            ;70
00001e  6820              LDR      r0,[r4,#0]            ;71
000020  4388              BICS     r0,r0,r1              ;71
000022  6020              STR      r0,[r4,#0]            ;71
000024  093e              LSRS     r6,r7,#4              ;72
000026  1eb6              SUBS     r6,r6,#2              ;72
000028  e023              B        |L1.114|
                  |L1.42|
00002a  4302              ORRS     r2,r2,r0
00002c  6022              STR      r2,[r4,#0]
;;;77     	    baud->DIVX_ONE   = 1;
00002e  6820              LDR      r0,[r4,#0]
000030  4308              ORRS     r0,r0,r1
000032  6020              STR      r0,[r4,#0]
;;;78     		i32tmp = i32clk / i32baudRate  -2;
;;;79     
;;;80     		if(i32tmp > 0xFFFF)			  /* If Divider > Range  */
000034  4812              LDR      r0,|L1.128|
000036  1ebe              SUBS     r6,r7,#2              ;78
000038  4286              CMP      r6,r0
00003a  dd1a              BLE      |L1.114|
;;;81     		{
;;;82     			baud->DIVX_ONE = 0;		  /* Try to Set Divider X up 10 (MODE#1) */
00003c  6820              LDR      r0,[r4,#0]
00003e  4388              BICS     r0,r0,r1
000040  6020              STR      r0,[r4,#0]
;;;83     
;;;84     			for(i32div = 8; i32div <16;i32div++)
000042  2508              MOVS     r5,#8
                  |L1.68|
000044  4638              MOV      r0,r7
;;;85     			{
;;;86     				if(((i32clk / i32baudRate)%(i32div+1))<3)
000046  1c69              ADDS     r1,r5,#1
000048  f7fffffe          BL       __aeabi_uidivmod
00004c  2903              CMP      r1,#3
00004e  d20d              BCS      |L1.108|
;;;87     				{
;;;88     					baud->DIVX   = i32div;
000050  6820              LDR      r0,[r4,#0]
000052  210f              MOVS     r1,#0xf
000054  0609              LSLS     r1,r1,#24
000056  4388              BICS     r0,r0,r1
000058  0729              LSLS     r1,r5,#28
00005a  0909              LSRS     r1,r1,#4
00005c  4308              ORRS     r0,r0,r1
00005e  6020              STR      r0,[r4,#0]
000060  4638              MOV      r0,r7
;;;89     					i32tmp = i32clk / i32baudRate / (i32div+1) -2;
000062  1c69              ADDS     r1,r5,#1
000064  f7fffffe          BL       __aeabi_uidivmod
000068  1e86              SUBS     r6,r0,#2
;;;90     					break;
00006a  e002              B        |L1.114|
                  |L1.108|
00006c  1c6d              ADDS     r5,r5,#1              ;84
00006e  2d10              CMP      r5,#0x10              ;84
000070  dbe8              BLT      |L1.68|
                  |L1.114|
;;;91     				}
;;;92     			}
;;;93     		}
;;;94     	}
;;;95     
;;;96     	baud->BRD = i32tmp;
000072  6820              LDR      r0,[r4,#0]
000074  b2b1              UXTH     r1,r6
000076  0c00              LSRS     r0,r0,#16
000078  0400              LSLS     r0,r0,#16
00007a  4308              ORRS     r0,r0,r1
00007c  6020              STR      r0,[r4,#0]
;;;97     
;;;98     }
00007e  bdf8              POP      {r3-r7,pc}
;;;99     
                          ENDP

                  |L1.128|
                          DCD      0x0000ffff

                          AREA ||i.DrvUART_ClearInt||, CODE, READONLY, ALIGN=2

                  DrvUART_ClearInt PROC
;;;425    /*---------------------------------------------------------------------------------------------------------*/
;;;426    uint32_t DrvUART_ClearInt(UART_PORT	u16Port,uint32_t u32InterruptFlag)
000000  4a0d              LDR      r2,|L2.56|
;;;427    {
000002  b510              PUSH     {r4,lr}
;;;428    	if((u32InterruptFlag & DRVUART_RDAINT) == DRVUART_RDAINT)    			/* clear Rx read Interrupt */
000004  07cb              LSLS     r3,r1,#31
;;;429    		inpw(&UART0->DATA + u16Port);
000006  1882              ADDS     r2,r0,r2
000008  2b00              CMP      r3,#0                 ;428
00000a  d000              BEQ      |L2.14|
00000c  6813              LDR      r3,[r2,#0]
                  |L2.14|
00000e  4c0a              LDR      r4,|L2.56|
;;;430    
;;;431    	if((u32InterruptFlag & DRVUART_RLSNT) == DRVUART_RLSNT)					/* clear Receive Line Status Interrupt */
;;;432    		outpw(&UART0->FSR + u16Port , inpw(&UART0->FSR + u16Port) | 0x70);
000010  0080              LSLS     r0,r0,#2
000012  074b              LSLS     r3,r1,#29             ;431
000014  1900              ADDS     r0,r0,r4
000016  2b00              CMP      r3,#0                 ;431
000018  da03              BGE      |L2.34|
00001a  6983              LDR      r3,[r0,#0x18]
00001c  2470              MOVS     r4,#0x70
00001e  4323              ORRS     r3,r3,r4
000020  6183              STR      r3,[r0,#0x18]
                  |L2.34|
;;;433    
;;;434    	if((u32InterruptFlag & DRVUART_MOSINT) == DRVUART_MOSINT)				/* clear Modem Interrupt */
000022  070b              LSLS     r3,r1,#28
000024  d503              BPL      |L2.46|
;;;435    		outpw(&UART0->MSR + u16Port,inpw(&UART0->MSR + u16Port) | 0x1);
000026  6943              LDR      r3,[r0,#0x14]
000028  2401              MOVS     r4,#1
00002a  4323              ORRS     r3,r3,r4
00002c  6143              STR      r3,[r0,#0x14]
                  |L2.46|
;;;436    
;;;437    	if((u32InterruptFlag & DRVUART_TOUTINT) == DRVUART_TOUTINT)				/* clear Time-out Interrupt */
00002e  06c8              LSLS     r0,r1,#27
000030  d500              BPL      |L2.52|
;;;438    	{
;;;439    		inpw(&UART0->DATA + u16Port);
000032  6810              LDR      r0,[r2,#0]
                  |L2.52|
;;;440    	}
;;;441    
;;;442    	return E_SUCCESS;
000034  2000              MOVS     r0,#0
;;;443    
;;;444    
;;;445    }
000036  bd10              POP      {r4,pc}
;;;446    
                          ENDP

                  |L2.56|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Close||, CODE, READONLY, ALIGN=2

                  DrvUART_Close PROC
;;;286    
;;;287    void DrvUART_Close(UART_PORT u16Port)
000000  2800              CMP      r0,#0
;;;288    {
;;;289    	if(u16Port == UART_PORT0)
000002  d10e              BNE      |L3.34|
;;;290    	{
;;;291    		while(!UART0->FSR.TX_EMPTY);
000004  4807              LDR      r0,|L3.36|
                  |L3.6|
000006  6981              LDR      r1,[r0,#0x18]
000008  0249              LSLS     r1,r1,#9
00000a  d5fc              BPL      |L3.6|
;;;292    		SYSCLK->APBCLK.UART0_EN = 0;
00000c  4806              LDR      r0,|L3.40|
00000e  6881              LDR      r1,[r0,#8]
000010  01c2              LSLS     r2,r0,#7
000012  4391              BICS     r1,r1,r2
000014  6081              STR      r1,[r0,#8]
;;;293    		g_pfnUART0callback = NULL;
000016  4905              LDR      r1,|L3.44|
000018  2000              MOVS     r0,#0
00001a  6008              STR      r0,[r1,#0]  ; g_pfnUART0callback
00001c  4904              LDR      r1,|L3.48|
00001e  1110              ASRS     r0,r2,#4
000020  6008              STR      r0,[r1,#0]
                  |L3.34|
;;;294            NVIC_DisableIRQ(UART0_IRQn);
;;;295    	}
;;;296    }
000022  4770              BX       lr
;;;297    
                          ENDP

                  |L3.36|
                          DCD      0x40050000
                  |L3.40|
                          DCD      0x50000200
                  |L3.44|
                          DCD      ||.data||
                  |L3.48|
                          DCD      0xe000e180

                          AREA ||i.DrvUART_DisableInt||, CODE, READONLY, ALIGN=2

                  DrvUART_DisableInt PROC
;;;387    /*---------------------------------------------------------------------------------------------------------*/
;;;388    void DrvUART_DisableInt(UART_PORT u16Port,uint32_t u32InterruptFlag)
000000  b510              PUSH     {r4,lr}
;;;389    {
000002  2400              MOVS     r4,#0
;;;390    	if(u16Port == UART_PORT0)
;;;391    	{
;;;392    		outpw(&UART0->IER + u16Port,inpw(&UART0->IER + u16Port) &~u32InterruptFlag);	   /* Disable INT  */
000004  4a0b              LDR      r2,|L4.52|
000006  2800              CMP      r0,#0                 ;390
000008  d102              BNE      |L4.16|
00000a  6853              LDR      r3,[r2,#4]
00000c  438b              BICS     r3,r3,r1
00000e  6053              STR      r3,[r2,#4]
                  |L4.16|
;;;393    	}
;;;394    
;;;395    	if(u32InterruptFlag & DRVUART_TOUTINT)			  							 /* Disable Counter Enable */
000010  06c9              LSLS     r1,r1,#27
000012  d506              BPL      |L4.34|
;;;396    	{
;;;397    		if(u16Port == DRVUART_PORT0)
000014  2800              CMP      r0,#0
000016  d10c              BNE      |L4.50|
;;;398    			UART0->IER.RTO_IEN = 0;
000018  6850              LDR      r0,[r2,#4]
00001a  2110              MOVS     r1,#0x10
00001c  4388              BICS     r0,r0,r1
00001e  6050              STR      r0,[r2,#4]
000020  e001              B        |L4.38|
                  |L4.34|
;;;399    	}
;;;400    
;;;401    	switch (u16Port)									   			 /* Disable Callback function and NVIC */
000022  2800              CMP      r0,#0
000024  d105              BNE      |L4.50|
                  |L4.38|
;;;402        {
;;;403            case UART_PORT0:
;;;404    			g_pfnUART0callback = NULL;
000026  4804              LDR      r0,|L4.56|
000028  4904              LDR      r1,|L4.60|
00002a  6004              STR      r4,[r0,#0]  ; g_pfnUART0callback
00002c  2001              MOVS     r0,#1
00002e  0300              LSLS     r0,r0,#12
000030  6008              STR      r0,[r1,#0]
                  |L4.50|
;;;405                NVIC_DisableIRQ(UART0_IRQn);
;;;406                break;
;;;407            default:
;;;408                break;
;;;409        }
;;;410    
;;;411    }
000032  bd10              POP      {r4,pc}
;;;412    
                          ENDP

                  |L4.52|
                          DCD      0x40050000
                  |L4.56|
                          DCD      ||.data||
                  |L4.60|
                          DCD      0xe000e180

                          AREA ||i.DrvUART_EnableInt||, CODE, READONLY, ALIGN=2

                  DrvUART_EnableInt PROC
;;;316    /*---------------------------------------------------------------------------------------------------------*/
;;;317    int32_t DrvUART_EnableInt(
000000  b510              PUSH     {r4,lr}
;;;318    	UART_PORT   u16Port,
;;;319    	uint32_t  u32InterruptFlag,
;;;320    	PFN_DRVUART_CALLBACK pfncallback
;;;321    )
;;;322    {
;;;323        if((u16Port != UART_PORT0) )
000002  2800              CMP      r0,#0
000004  d001              BEQ      |L5.10|
;;;324        {
;;;325            return E_DRVUART_ARGUMENT;
000006  4827              LDR      r0,|L5.164|
;;;326        }
;;;327    
;;;328     	if(u16Port == UART_PORT0)											   	/* Set Specified Interrupt */
;;;329    	{
;;;330    		UART0->IER.RDA_IEN		=(u32InterruptFlag & DRVUART_RDAINT)?1:0 ;
;;;331    		UART0->IER.THRE_IEN		=(u32InterruptFlag & DRVUART_THREINT)?1:0;
;;;332    		UART0->IER.RLS_IEN		=(u32InterruptFlag & DRVUART_RLSNT)?1:0;
;;;333    		UART0->IER.MS_IEN		=(u32InterruptFlag & DRVUART_MOSINT)?1:0;
;;;334    
;;;335    		UART0->IER.TOC_EN		=(u32InterruptFlag & DRVUART_TOUTINT)?1:0;   	/* Time-out count enable */
;;;336    		UART0->IER.RTO_IEN		=(u32InterruptFlag & DRVUART_TOUTINT)?1:0;		/* Time-out INT enable */
;;;337    
;;;338    		UART0->IER.BUF_ERR_IEN	=(u32InterruptFlag & DRVUART_BUFERRINT)?1:0;
;;;339    		UART0->IER.LIN_RX_BRK_IEN=(u32InterruptFlag & DRVUART_LININT)?1:0;
;;;340    
;;;341    	}
;;;342        if(u16Port == UART_PORT0)											   	/* Install Callback function */
;;;343        {
;;;344    		g_pfnUART0callback = pfncallback;
;;;345    		NVIC_EnableIRQ(UART0_IRQn);
;;;346        }
;;;347    
;;;348    	return E_SUCCESS;
;;;349    
;;;350    }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  4b27              LDR      r3,|L5.168|
00000c  6858              LDR      r0,[r3,#4]            ;330
00000e  07cc              LSLS     r4,r1,#31             ;330
000010  0840              LSRS     r0,r0,#1              ;330
000012  0040              LSLS     r0,r0,#1              ;330
000014  0fe4              LSRS     r4,r4,#31             ;330
000016  4320              ORRS     r0,r0,r4              ;330
000018  6058              STR      r0,[r3,#4]            ;330
00001a  0788              LSLS     r0,r1,#30             ;331
00001c  2402              MOVS     r4,#2                 ;331
00001e  2800              CMP      r0,#0                 ;331
000020  6858              LDR      r0,[r3,#4]            ;331
000022  da01              BGE      |L5.40|
000024  4320              ORRS     r0,r0,r4              ;331
000026  e000              B        |L5.42|
                  |L5.40|
000028  43a0              BICS     r0,r0,r4              ;331
                  |L5.42|
00002a  6058              STR      r0,[r3,#4]            ;331
00002c  0748              LSLS     r0,r1,#29             ;332
00002e  2404              MOVS     r4,#4                 ;332
000030  2800              CMP      r0,#0                 ;332
000032  6858              LDR      r0,[r3,#4]            ;332
000034  da01              BGE      |L5.58|
000036  4320              ORRS     r0,r0,r4              ;332
000038  e000              B        |L5.60|
                  |L5.58|
00003a  43a0              BICS     r0,r0,r4              ;332
                  |L5.60|
00003c  6058              STR      r0,[r3,#4]            ;332
00003e  0708              LSLS     r0,r1,#28             ;333
000040  2408              MOVS     r4,#8                 ;333
000042  2800              CMP      r0,#0                 ;333
000044  6858              LDR      r0,[r3,#4]            ;333
000046  da01              BGE      |L5.76|
000048  4320              ORRS     r0,r0,r4              ;333
00004a  e000              B        |L5.78|
                  |L5.76|
00004c  43a0              BICS     r0,r0,r4              ;333
                  |L5.78|
00004e  6058              STR      r0,[r3,#4]            ;333
000050  06c8              LSLS     r0,r1,#27             ;335
000052  4c16              LDR      r4,|L5.172|
000054  6858              LDR      r0,[r3,#4]            ;335
000056  d501              BPL      |L5.92|
000058  4320              ORRS     r0,r0,r4              ;335
00005a  e000              B        |L5.94|
                  |L5.92|
00005c  43a0              BICS     r0,r0,r4              ;335
                  |L5.94|
00005e  6058              STR      r0,[r3,#4]            ;335
000060  06c8              LSLS     r0,r1,#27             ;336
000062  2410              MOVS     r4,#0x10              ;336
000064  2800              CMP      r0,#0                 ;336
000066  6858              LDR      r0,[r3,#4]            ;336
000068  da01              BGE      |L5.110|
00006a  4320              ORRS     r0,r0,r4              ;336
00006c  e000              B        |L5.112|
                  |L5.110|
00006e  43a0              BICS     r0,r0,r4              ;336
                  |L5.112|
000070  6058              STR      r0,[r3,#4]            ;336
000072  0688              LSLS     r0,r1,#26             ;338
000074  2420              MOVS     r4,#0x20              ;338
000076  2800              CMP      r0,#0                 ;338
000078  6858              LDR      r0,[r3,#4]            ;338
00007a  da01              BGE      |L5.128|
00007c  4320              ORRS     r0,r0,r4              ;338
00007e  e000              B        |L5.130|
                  |L5.128|
000080  43a0              BICS     r0,r0,r4              ;338
                  |L5.130|
000082  6058              STR      r0,[r3,#4]            ;338
000084  0608              LSLS     r0,r1,#24             ;339
000086  490a              LDR      r1,|L5.176|
000088  6858              LDR      r0,[r3,#4]            ;339
00008a  d501              BPL      |L5.144|
00008c  4308              ORRS     r0,r0,r1              ;339
00008e  e000              B        |L5.146|
                  |L5.144|
000090  4388              BICS     r0,r0,r1              ;339
                  |L5.146|
000092  6058              STR      r0,[r3,#4]            ;339
000094  4807              LDR      r0,|L5.180|
000096  4908              LDR      r1,|L5.184|
000098  6002              STR      r2,[r0,#0]            ;344  ; g_pfnUART0callback
00009a  2001              MOVS     r0,#1                 ;344
00009c  0300              LSLS     r0,r0,#12             ;344
00009e  6008              STR      r0,[r1,#0]            ;344
0000a0  2000              MOVS     r0,#0                 ;348
0000a2  bd10              POP      {r4,pc}
;;;351    
                          ENDP

                  |L5.164|
                          DCD      0xffff9807
                  |L5.168|
                          DCD      0x40050000
                  |L5.172|
                          DCD      0x00000800
                  |L5.176|
                          DCD      0x00000100
                  |L5.180|
                          DCD      ||.data||
                  |L5.184|
                          DCD      0xe000e100

                          AREA ||i.DrvUART_GetCTS||, CODE, READONLY, ALIGN=2

                  DrvUART_GetCTS PROC
;;;520    /*---------------------------------------------------------------------------------------------------------*/
;;;521    void DrvUART_GetCTS(UART_PORT u16Port,uint8_t *pu8CTSValue,	uint8_t	*pu8CTSChangeState)
000000  2800              CMP      r0,#0
;;;522    {
;;;523    	if(u16Port == UART_PORT0)
000002  d108              BNE      |L6.22|
;;;524    	{
;;;525    		*pu8CTSValue 		= UART0->MSR.CTS;
000004  4804              LDR      r0,|L6.24|
000006  6943              LDR      r3,[r0,#0x14]
000008  06db              LSLS     r3,r3,#27
00000a  0fdb              LSRS     r3,r3,#31
00000c  700b              STRB     r3,[r1,#0]
;;;526    		*pu8CTSChangeState 	= UART0->MSR.DCTS;
00000e  6940              LDR      r0,[r0,#0x14]
000010  07c0              LSLS     r0,r0,#31
000012  0fc0              LSRS     r0,r0,#31
000014  7010              STRB     r0,[r2,#0]
                  |L6.22|
;;;527    	}
;;;528    	else
;;;529    		return;   /* CTS */
;;;530    }
000016  4770              BX       lr
;;;531    
                          ENDP

                  |L6.24|
                          DCD      0x40050000

                          AREA ||i.DrvUART_GetIntStatus||, CODE, READONLY, ALIGN=2

                  DrvUART_GetIntStatus PROC
;;;460    /*---------------------------------------------------------------------------------------------------------*/
;;;461    int8_t DrvUART_GetIntStatus(UART_PORT u16Port,uint32_t u32InterruptFlag)
000000  4a10              LDR      r2,|L7.68|
;;;462    {
;;;463    
;;;464    	switch(u32InterruptFlag)
;;;465    	{
;;;466    		case DRVUART_MOSINT:				  	/* MODEM Status Interrupt */
;;;467    				return (inpw(&UART0->ISR + u16Port) & DRVUART_MOSINT)?TRUE:FALSE;
000002  0080              LSLS     r0,r0,#2
000004  1880              ADDS     r0,r0,r2
000006  2904              CMP      r1,#4                 ;464
000008  d00e              BEQ      |L7.40|
00000a  dc04              BGT      |L7.22|
00000c  2901              CMP      r1,#1                 ;464
00000e  d011              BEQ      |L7.52|
000010  2902              CMP      r1,#2                 ;464
000012  d104              BNE      |L7.30|
000014  e00b              B        |L7.46|
                  |L7.22|
000016  2908              CMP      r1,#8                 ;464
000018  d003              BEQ      |L7.34|
00001a  2910              CMP      r1,#0x10              ;464
00001c  d00d              BEQ      |L7.58|
                  |L7.30|
;;;468    
;;;469    		case DRVUART_RLSNT:						/* Receive Line Status Interrupt */
;;;470    				return (inpw(&UART0->ISR + u16Port) & DRVUART_RLSNT)?TRUE:FALSE;
;;;471    
;;;472    		case DRVUART_THREINT:					/* Transmit Holding Register Empty Interrupt */
;;;473    				return (inpw(&UART0->ISR + u16Port) & DRVUART_THREINT)?TRUE:FALSE;
;;;474    
;;;475    		case DRVUART_RDAINT:					/* Receive Data Available Interrupt */
;;;476    				return (inpw(&UART0->ISR + u16Port) & DRVUART_RDAINT)?TRUE:FALSE;
;;;477    
;;;478    		case DRVUART_TOUTINT:					/* Time-out Interrupt */
;;;479    				return (inpw(&UART0->ISR + u16Port) & DRVUART_TOUTINT)?TRUE:FALSE;
;;;480    
;;;481    		default:
;;;482    			return FALSE;
00001e  2000              MOVS     r0,#0
;;;483    	}
;;;484    
;;;485    }
000020  4770              BX       lr
                  |L7.34|
000022  69c0              LDR      r0,[r0,#0x1c]         ;467
000024  0700              LSLS     r0,r0,#28             ;467
000026  e00a              B        |L7.62|
                  |L7.40|
000028  69c0              LDR      r0,[r0,#0x1c]         ;470
00002a  0740              LSLS     r0,r0,#29             ;470
00002c  e007              B        |L7.62|
                  |L7.46|
00002e  69c0              LDR      r0,[r0,#0x1c]         ;473
000030  0780              LSLS     r0,r0,#30             ;473
000032  e004              B        |L7.62|
                  |L7.52|
000034  69c0              LDR      r0,[r0,#0x1c]         ;476
000036  07c0              LSLS     r0,r0,#31             ;476
000038  e001              B        |L7.62|
                  |L7.58|
00003a  69c0              LDR      r0,[r0,#0x1c]         ;479
00003c  06c0              LSLS     r0,r0,#27             ;479
                  |L7.62|
00003e  0fc0              LSRS     r0,r0,#31             ;479
000040  4770              BX       lr
;;;486    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x40050000

                          AREA ||i.DrvUART_GetUartCLk||, CODE, READONLY, ALIGN=2

                  DrvUART_GetUartCLk PROC
;;;111    //static uint32_t DrvUART_GetUartCLk(void)
;;;112    uint32_t DrvUART_GetUartCLk(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114    	uint32_t u32clk =0;
;;;115    													/* Check UART Clock Source Setting */
;;;116    //	u32clk = 49152000;								    /* Clock 49Mhz  */
;;;117    	u32clk = DrvSYS_GetHCLK() * 1000 / (SYSCLK->CLKDIV.UART_N + 1) ;					
000002  f7fffffe          BL       DrvSYS_GetHCLK
000006  217d              MOVS     r1,#0x7d
000008  00c9              LSLS     r1,r1,#3
00000a  4348              MULS     r0,r1,r0
00000c  4903              LDR      r1,|L8.28|
00000e  6989              LDR      r1,[r1,#0x18]
000010  0509              LSLS     r1,r1,#20
000012  0f09              LSRS     r1,r1,#28
000014  1c49              ADDS     r1,r1,#1
000016  f7fffffe          BL       __aeabi_uidivmod
;;;118    	return u32clk;
;;;119    }
00001a  bd10              POP      {r4,pc}
;;;120    
                          ENDP

                  |L8.28|
                          DCD      0x50000200

                          AREA ||i.DrvUART_GetVersion||, CODE, READONLY, ALIGN=2

                  DrvUART_GetVersion PROC
;;;757    /*---------------------------------------------------------------------------------------------------------*/
;;;758    int32_t	DrvUART_GetVersion(void)
000000  4800              LDR      r0,|L9.4|
;;;759    {
;;;760    	return DRVUART_VERSION_NUM;
;;;761    
;;;762    }
000002  4770              BX       lr
;;;763    
                          ENDP

                  |L9.4|
                          DCD      0x00010001

                          AREA ||i.DrvUART_Init||, CODE, READONLY, ALIGN=2

                  DrvUART_Init PROC
;;;781    
;;;782    void DrvUART_Init(int baudrate)
000000  b510              PUSH     {r4,lr}
;;;783    {
000002  4604              MOV      r4,r0
;;;784        /* Multi-Function Pin: Enable UART0:Tx Rx */
;;;785    	SYS->GPA_ALT.GPA8 = 1;
000004  2005              MOVS     r0,#5
000006  0700              LSLS     r0,r0,#28
000008  6b81              LDR      r1,[r0,#0x38]
00000a  2203              MOVS     r2,#3
00000c  0412              LSLS     r2,r2,#16
00000e  4391              BICS     r1,r1,r2
000010  2201              MOVS     r2,#1
000012  0412              LSLS     r2,r2,#16
000014  1889              ADDS     r1,r1,r2
000016  6381              STR      r1,[r0,#0x38]
;;;786    	SYS->GPA_ALT.GPA9 = 1;
000018  6b81              LDR      r1,[r0,#0x38]
00001a  2303              MOVS     r3,#3
00001c  049b              LSLS     r3,r3,#18
00001e  4399              BICS     r1,r1,r3
000020  0093              LSLS     r3,r2,#2
000022  18c9              ADDS     r1,r1,r3
000024  6381              STR      r1,[r0,#0x38]
;;;787        /* Configure GCR to reset UART0 */
;;;788        SYS->IPRSTC2.UART0_RST = 1;
000026  68c1              LDR      r1,[r0,#0xc]
000028  4311              ORRS     r1,r1,r2
00002a  60c1              STR      r1,[r0,#0xc]
;;;789        SYS->IPRSTC2.UART0_RST = 0;
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  4391              BICS     r1,r1,r2
000030  60c1              STR      r1,[r0,#0xc]
;;;790    
;;;791        /* Enable UART clock */
;;;792    	SYSCLK->APBCLK.UART0_EN = 1;
000032  4808              LDR      r0,|L10.84|
000034  6881              LDR      r1,[r0,#8]
000036  4311              ORRS     r1,r1,r2
000038  6081              STR      r1,[r0,#8]
;;;793    
;;;794        /* Select UART clock source */
;;;795    //    SYSCLK->CLKSEL1.UART_S = 0;
;;;796    
;;;797        /* Data format */
;;;798        UART0->LCR.WLS = 3;
00003a  4807              LDR      r0,|L10.88|
00003c  68c1              LDR      r1,[r0,#0xc]
00003e  2203              MOVS     r2,#3
000040  4311              ORRS     r1,r1,r2
000042  60c1              STR      r1,[r0,#0xc]
;;;799    
;;;800        /* Configure the baud rate */
;;;801    	DrvUART_BaudRateCalculator(DrvUART_GetUartCLk(), baudrate, &UART0->BAUD);
000044  f7fffffe          BL       DrvUART_GetUartCLk
000048  4a03              LDR      r2,|L10.88|
00004a  4621              MOV      r1,r4
00004c  3224              ADDS     r2,r2,#0x24
00004e  f7fffffe          BL       DrvUART_BaudRateCalculator
;;;802    }
000052  bd10              POP      {r4,pc}
;;;803    
                          ENDP

                  |L10.84|
                          DCD      0x50000200
                  |L10.88|
                          DCD      0x40050000

                          AREA ||i.DrvUART_IsIntEnabled||, CODE, READONLY, ALIGN=2

                  DrvUART_IsIntEnabled PROC
;;;364    /*---------------------------------------------------------------------------------------------------------*/
;;;365    uint32_t DrvUART_IsIntEnabled(UART_PORT	u16Port,uint32_t u32InterruptFlag)
000000  4803              LDR      r0,|L11.16|
;;;366    {
;;;367    		/* Read IER Register and check specified flag is enable */
;;;368    		return ((inpw(&UART0->IER) &
000002  6840              LDR      r0,[r0,#4]
000004  b2c9              UXTB     r1,r1
000006  4008              ANDS     r0,r0,r1
000008  d000              BEQ      |L11.12|
;;;369    		 (u32InterruptFlag & (DRVUART_LININT | DRVUART_WAKEUPINT | DRVUART_BUFERRINT |
;;;370    		 		DRVUART_TOUTINT | DRVUART_MOSINT | DRVUART_RLSNT | DRVUART_THREINT | DRVUART_RDAINT))))?1:0;
00000a  2001              MOVS     r0,#1
                  |L11.12|
;;;371    
;;;372    
;;;373    }
00000c  4770              BX       lr
;;;374    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Open||, CODE, READONLY, ALIGN=2

                  DrvUART_Open PROC
;;;171    /*---------------------------------------------------------------------------------------------------------*/
;;;172    int32_t DrvUART_Open(UART_PORT u16Port, STR_UART_T *sParam)
000000  b510              PUSH     {r4,lr}
;;;173    {
000002  460c              MOV      r4,r1
;;;174    
;;;175        /*-----------------------------------------------------------------------------------------------------*/
;;;176        /* Check UART port                                                                                     */
;;;177        /*-----------------------------------------------------------------------------------------------------*/
;;;178        if (u16Port != UART_PORT0) 
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L12.12|
;;;179        {
;;;180    
;;;181    		return E_DRVUART_ERR_PORT_INVALID;
000008  4848              LDR      r0,|L12.300|
;;;182        }
;;;183    
;;;184    
;;;185        /*-----------------------------------------------------------------------------------------------------*/
;;;186        /* Check the supplied parity                                                                           */
;;;187        /*-----------------------------------------------------------------------------------------------------*/
;;;188        if ((sParam->u8cParity != DRVUART_PARITY_NONE) &&
;;;189            (sParam->u8cParity != DRVUART_PARITY_EVEN) &&
;;;190            (sParam->u8cParity != DRVUART_PARITY_ODD)  &&
;;;191            (sParam->u8cParity != DRVUART_PARITY_MARK) &&
;;;192            (sParam->u8cParity != DRVUART_PARITY_SPACE))
;;;193        {
;;;194     		return E_DRVUART_ERR_PARITY_INVALID;
;;;195        }
;;;196        /*-----------------------------------------------------------------------------------------------------*/
;;;197        /* Check the supplied number of data bits                                                              */
;;;198        /*-----------------------------------------------------------------------------------------------------*/
;;;199        else if ((sParam->u8cDataBits != DRVUART_DATABITS_5) &&
;;;200                 (sParam->u8cDataBits != DRVUART_DATABITS_6) &&
;;;201                 (sParam->u8cDataBits != DRVUART_DATABITS_7) &&
;;;202                 (sParam->u8cDataBits != DRVUART_DATABITS_8))
;;;203        {
;;;204     		return E_DRVUART_ERR_DATA_BITS_INVALID;
;;;205        }
;;;206        /*-----------------------------------------------------------------------------------------------------*/
;;;207        /* Check the supplied number of stop bits                                                              */
;;;208        /*-----------------------------------------------------------------------------------------------------*/
;;;209        else if ((sParam->u8cStopBits != DRVUART_STOPBITS_1) &&
;;;210                 (sParam->u8cStopBits != DRVUART_STOPBITS_2) &&
;;;211                 (sParam->u8cStopBits != DRVUART_STOPBITS_1_5)
;;;212                 )
;;;213        {
;;;214          	return E_DRVUART_ERR_STOP_BITS_INVALID;
;;;215        }
;;;216    
;;;217    
;;;218        /*-----------------------------------------------------------------------------------------------------*/
;;;219        /* Check the supplied nember of trigger level bytes                                                    */
;;;220        /*-----------------------------------------------------------------------------------------------------*/
;;;221        else if ((sParam->u8cRxTriggerLevel != DRVUART_FIFO_1BYTES) &&
;;;222                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_4BYTES) &&
;;;223                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_8BYTES) &&
;;;224                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_14BYTES)&&
;;;225                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_30BYTES)&&
;;;226                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_46BYTES)&&
;;;227                 (sParam->u8cRxTriggerLevel != DRVUART_FIFO_62BYTES))
;;;228        {
;;;229    		return E_DRVUART_ERR_TRIGGERLEVEL_INVALID;
;;;230        }
;;;231    
;;;232    	if(u16Port == UART_PORT0)
;;;233    	{
;;;234    		/* Reset IP */
;;;235    		SYS->IPRSTC2.UART0_RST = 1;
;;;236    		SYS->IPRSTC2.UART0_RST = 0;
;;;237    
;;;238    		/* Enable UART clock */
;;;239    	    SYSCLK->APBCLK.UART0_EN = 1;
;;;240    
;;;241    
;;;242    	}
;;;243    
;;;244    	/* Tx FIFO Reset & Rx FIFO Reset & FIFO Mode Enable */
;;;245    	if(u16Port == UART_PORT0)
;;;246    	{
;;;247    	  	UART0->FCR.TFR =1;
;;;248    	  	UART0->FCR.RFR =1;
;;;249    	}
;;;250    
;;;251    	if (u16Port == UART_PORT0)
;;;252    	{
;;;253    		/* Set Rx Trigger Level */
;;;254    		UART0->FCR.RFITL = sParam->u8cRxTriggerLevel;
;;;255    
;;;256    		/* Set Parity & Data bits & Stop bits */
;;;257    		UART0->LCR.SPE	=((sParam->u8cParity)&0x4)?1:0;
;;;258    		UART0->LCR.EPE	=((sParam->u8cParity)&0x2)?1:0;
;;;259    		UART0->LCR.PBE	=((sParam->u8cParity)&0x1)?1:0;
;;;260    
;;;261    		UART0->LCR.WLS	=sParam->u8cDataBits;
;;;262    		UART0->LCR.NSB	=sParam->u8cStopBits;
;;;263    
;;;264    		/* Set Time-Out */
;;;265    		UART0->TOR.TOIC 		=sParam->u8TimeOut;
;;;266    
;;;267    		/* Set BaudRate */
;;;268    		DrvUART_BaudRateCalculator(DrvUART_GetUartCLk(), sParam->u32BaudRate, &UART0->BAUD);
;;;269    	}
;;;270    
;;;271    	return E_SUCCESS;
;;;272    }
00000a  bd10              POP      {r4,pc}
                  |L12.12|
00000c  79a0              LDRB     r0,[r4,#6]            ;188
00000e  2800              CMP      r0,#0                 ;188
000010  d00a              BEQ      |L12.40|
000012  2803              CMP      r0,#3                 ;189
000014  d008              BEQ      |L12.40|
000016  2801              CMP      r0,#1                 ;190
000018  d006              BEQ      |L12.40|
00001a  2805              CMP      r0,#5                 ;191
00001c  d004              BEQ      |L12.40|
00001e  2807              CMP      r0,#7                 ;192
000020  d002              BEQ      |L12.40|
000022  4842              LDR      r0,|L12.300|
000024  1c40              ADDS     r0,r0,#1              ;194
000026  bd10              POP      {r4,pc}
                  |L12.40|
000028  7920              LDRB     r0,[r4,#4]            ;199
00002a  2800              CMP      r0,#0                 ;199
00002c  d008              BEQ      |L12.64|
00002e  2801              CMP      r0,#1                 ;200
000030  d006              BEQ      |L12.64|
000032  2802              CMP      r0,#2                 ;201
000034  d004              BEQ      |L12.64|
000036  2803              CMP      r0,#3                 ;202
000038  d002              BEQ      |L12.64|
00003a  483c              LDR      r0,|L12.300|
00003c  1c80              ADDS     r0,r0,#2              ;204
00003e  bd10              POP      {r4,pc}
                  |L12.64|
000040  7960              LDRB     r0,[r4,#5]            ;209
000042  2800              CMP      r0,#0                 ;209
000044  d004              BEQ      |L12.80|
000046  2801              CMP      r0,#1                 ;210
000048  d002              BEQ      |L12.80|
00004a  4838              LDR      r0,|L12.300|
00004c  1cc0              ADDS     r0,r0,#3              ;214
00004e  bd10              POP      {r4,pc}
                  |L12.80|
000050  79e0              LDRB     r0,[r4,#7]            ;221
000052  2800              CMP      r0,#0                 ;221
000054  d00e              BEQ      |L12.116|
000056  2801              CMP      r0,#1                 ;222
000058  d00c              BEQ      |L12.116|
00005a  2802              CMP      r0,#2                 ;223
00005c  d00a              BEQ      |L12.116|
00005e  2803              CMP      r0,#3                 ;224
000060  d008              BEQ      |L12.116|
000062  2804              CMP      r0,#4                 ;225
000064  d006              BEQ      |L12.116|
000066  2805              CMP      r0,#5                 ;226
000068  d004              BEQ      |L12.116|
00006a  2806              CMP      r0,#6                 ;227
00006c  d002              BEQ      |L12.116|
00006e  482f              LDR      r0,|L12.300|
000070  1d00              ADDS     r0,r0,#4              ;229
000072  bd10              POP      {r4,pc}
                  |L12.116|
000074  2005              MOVS     r0,#5                 ;235
000076  0700              LSLS     r0,r0,#28             ;235
000078  68c2              LDR      r2,[r0,#0xc]          ;235
00007a  2101              MOVS     r1,#1                 ;235
00007c  0409              LSLS     r1,r1,#16             ;235
00007e  430a              ORRS     r2,r2,r1              ;235
000080  60c2              STR      r2,[r0,#0xc]          ;235
000082  68c2              LDR      r2,[r0,#0xc]          ;236
000084  438a              BICS     r2,r2,r1              ;236
000086  60c2              STR      r2,[r0,#0xc]          ;236
000088  4829              LDR      r0,|L12.304|
00008a  6882              LDR      r2,[r0,#8]            ;239
00008c  430a              ORRS     r2,r2,r1              ;239
00008e  6082              STR      r2,[r0,#8]            ;239
000090  4828              LDR      r0,|L12.308|
000092  6881              LDR      r1,[r0,#8]            ;247
000094  2204              MOVS     r2,#4                 ;247
000096  4311              ORRS     r1,r1,r2              ;247
000098  6081              STR      r1,[r0,#8]            ;247
00009a  6881              LDR      r1,[r0,#8]            ;248
00009c  2302              MOVS     r3,#2                 ;248
00009e  4319              ORRS     r1,r1,r3              ;248
0000a0  6081              STR      r1,[r0,#8]            ;248
0000a2  6881              LDR      r1,[r0,#8]            ;254
0000a4  23f0              MOVS     r3,#0xf0              ;254
0000a6  4399              BICS     r1,r1,r3              ;254
0000a8  79e3              LDRB     r3,[r4,#7]            ;254
0000aa  071b              LSLS     r3,r3,#28             ;254
0000ac  0e1b              LSRS     r3,r3,#24             ;254
0000ae  4319              ORRS     r1,r1,r3              ;254
0000b0  6081              STR      r1,[r0,#8]            ;254
0000b2  79a1              LDRB     r1,[r4,#6]            ;257
0000b4  2320              MOVS     r3,#0x20              ;257
0000b6  0749              LSLS     r1,r1,#29             ;257
0000b8  2900              CMP      r1,#0                 ;257
0000ba  68c1              LDR      r1,[r0,#0xc]          ;257
0000bc  da01              BGE      |L12.194|
0000be  4319              ORRS     r1,r1,r3              ;257
0000c0  e000              B        |L12.196|
                  |L12.194|
0000c2  4399              BICS     r1,r1,r3              ;257
                  |L12.196|
0000c4  60c1              STR      r1,[r0,#0xc]          ;257
0000c6  79a1              LDRB     r1,[r4,#6]            ;258
0000c8  2310              MOVS     r3,#0x10              ;258
0000ca  0789              LSLS     r1,r1,#30             ;258
0000cc  2900              CMP      r1,#0                 ;258
0000ce  68c1              LDR      r1,[r0,#0xc]          ;258
0000d0  da01              BGE      |L12.214|
0000d2  4319              ORRS     r1,r1,r3              ;258
0000d4  e000              B        |L12.216|
                  |L12.214|
0000d6  4399              BICS     r1,r1,r3              ;258
                  |L12.216|
0000d8  60c1              STR      r1,[r0,#0xc]          ;258
0000da  68c1              LDR      r1,[r0,#0xc]          ;259
0000dc  2308              MOVS     r3,#8                 ;259
0000de  4399              BICS     r1,r1,r3              ;259
0000e0  79a3              LDRB     r3,[r4,#6]            ;259
0000e2  07db              LSLS     r3,r3,#31             ;259
0000e4  0f1b              LSRS     r3,r3,#28             ;259
0000e6  4319              ORRS     r1,r1,r3              ;259
0000e8  60c1              STR      r1,[r0,#0xc]          ;259
0000ea  68c1              LDR      r1,[r0,#0xc]          ;261
0000ec  7923              LDRB     r3,[r4,#4]            ;261
0000ee  0889              LSRS     r1,r1,#2              ;261
0000f0  0089              LSLS     r1,r1,#2              ;261
0000f2  079b              LSLS     r3,r3,#30             ;261
0000f4  0f9b              LSRS     r3,r3,#30             ;261
0000f6  4319              ORRS     r1,r1,r3              ;261
0000f8  60c1              STR      r1,[r0,#0xc]          ;261
0000fa  68c1              LDR      r1,[r0,#0xc]          ;262
0000fc  4391              BICS     r1,r1,r2              ;262
0000fe  7962              LDRB     r2,[r4,#5]            ;262
000100  07d2              LSLS     r2,r2,#31             ;262
000102  0f52              LSRS     r2,r2,#29             ;262
000104  4311              ORRS     r1,r1,r2              ;262
000106  60c1              STR      r1,[r0,#0xc]          ;262
000108  6a01              LDR      r1,[r0,#0x20]         ;265
00010a  7a22              LDRB     r2,[r4,#8]            ;265
00010c  09c9              LSRS     r1,r1,#7              ;265
00010e  0652              LSLS     r2,r2,#25             ;265
000110  01c9              LSLS     r1,r1,#7              ;265
000112  0e52              LSRS     r2,r2,#25             ;265
000114  4311              ORRS     r1,r1,r2              ;265
000116  6201              STR      r1,[r0,#0x20]         ;265
000118  f7fffffe          BL       DrvUART_GetUartCLk
00011c  4a05              LDR      r2,|L12.308|
00011e  6821              LDR      r1,[r4,#0]            ;268
000120  3224              ADDS     r2,r2,#0x24           ;268
000122  f7fffffe          BL       DrvUART_BaudRateCalculator
000126  2000              MOVS     r0,#0                 ;271
000128  bd10              POP      {r4,pc}
;;;273    
                          ENDP

00012a  0000              DCW      0x0000
                  |L12.300|
                          DCD      0xffff9802
                  |L12.304|
                          DCD      0x50000200
                  |L12.308|
                          DCD      0x40050000

                          AREA ||i.DrvUART_OpenIRCR||, CODE, READONLY, ALIGN=2

                  DrvUART_OpenIRCR PROC
;;;649    /*---------------------------------------------------------------------------------------------------------*/
;;;650    void DrvUART_OpenIRCR(UART_PORT u16Port,STR_IRCR_T str_IRCR )
000000  b503              PUSH     {r0,r1,lr}
;;;651    {
;;;652    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d122              BNE      |L13.76|
;;;653    	{
;;;654    		UART0->FUNSEL.LIN_EN 	= 0;
000006  4812              LDR      r0,|L13.80|
000008  6b01              LDR      r1,[r0,#0x30]
00000a  0849              LSRS     r1,r1,#1
00000c  0049              LSLS     r1,r1,#1
00000e  6301              STR      r1,[r0,#0x30]
;;;655    		UART0->FUNSEL.IrDA_EN 	= 1;
000010  6b01              LDR      r1,[r0,#0x30]
000012  2202              MOVS     r2,#2
000014  4311              ORRS     r1,r1,r2
000016  6301              STR      r1,[r0,#0x30]
;;;656    		//UART0->IRCR.RX_EN 		= str_IRCR.u8cRXSelect ;
;;;657    		UART0->IRCR.TX_SELECT	= str_IRCR.u8cTXSelect ;
000018  6a81              LDR      r1,[r0,#0x28]
00001a  4391              BICS     r1,r1,r2
00001c  466a              MOV      r2,sp
00001e  7952              LDRB     r2,[r2,#5]
000020  07d2              LSLS     r2,r2,#31
000022  0f92              LSRS     r2,r2,#30
000024  4311              ORRS     r1,r1,r2
000026  6281              STR      r1,[r0,#0x28]
;;;658    		UART0->IRCR.TX_INV_EN	= str_IRCR.u8cInvTX ;
000028  6a81              LDR      r1,[r0,#0x28]
00002a  2220              MOVS     r2,#0x20
00002c  4391              BICS     r1,r1,r2
00002e  466a              MOV      r2,sp
000030  7992              LDRB     r2,[r2,#6]
000032  07d2              LSLS     r2,r2,#31
000034  0e92              LSRS     r2,r2,#26
000036  4311              ORRS     r1,r1,r2
000038  6281              STR      r1,[r0,#0x28]
;;;659    		UART0->IRCR.RX_INV_EN	= str_IRCR.u8cInvRX ;
00003a  6a81              LDR      r1,[r0,#0x28]
00003c  2240              MOVS     r2,#0x40
00003e  4391              BICS     r1,r1,r2
000040  466a              MOV      r2,sp
000042  79d2              LDRB     r2,[r2,#7]
000044  07d2              LSLS     r2,r2,#31
000046  0e52              LSRS     r2,r2,#25
000048  4311              ORRS     r1,r1,r2
00004a  6281              STR      r1,[r0,#0x28]
                  |L13.76|
;;;660    
;;;661    	}
;;;662    
;;;663    }
00004c  bd0c              POP      {r2,r3,pc}
;;;664    
                          ENDP

00004e  0000              DCW      0x0000
                  |L13.80|
                          DCD      0x40050000

                          AREA ||i.DrvUART_OpenLIN||, CODE, READONLY, ALIGN=2

                  DrvUART_OpenLIN PROC
;;;678    /*---------------------------------------------------------------------------------------------------------*/
;;;679    void DrvUART_OpenLIN(UART_PORT u16Port,uint16_t u16DIRECTION,uint16_t U16BCNT)
000000  b510              PUSH     {r4,lr}
;;;680    {
;;;681    
;;;682    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d119              BNE      |L14.58|
;;;683    	{
;;;684    		UART0->FUNSEL.LIN_EN 	= 1;
000006  4810              LDR      r0,|L14.72|
000008  6b03              LDR      r3,[r0,#0x30]
00000a  2401              MOVS     r4,#1
00000c  4323              ORRS     r3,r3,r4
00000e  6303              STR      r3,[r0,#0x30]
;;;685    		UART0->FUNSEL.IrDA_EN 	= 0;
000010  6b03              LDR      r3,[r0,#0x30]
000012  2402              MOVS     r4,#2
000014  43a3              BICS     r3,r3,r4
000016  6303              STR      r3,[r0,#0x30]
;;;686    		if(u16DIRECTION ==MODE_TX )
;;;687    		{
;;;688    			UART0->LINCON.LINTX_EN	= 1;
000018  2380              MOVS     r3,#0x80
;;;689    			UART0->LINCON.LINRX_EN	= 0;
00001a  2440              MOVS     r4,#0x40
00001c  2900              CMP      r1,#0                 ;686
;;;690    		}else
;;;691    		{
;;;692    			UART0->LINCON.LINTX_EN	= 0;
00001e  6ac1              LDR      r1,[r0,#0x2c]
000020  d00c              BEQ      |L14.60|
000022  4399              BICS     r1,r1,r3
000024  62c1              STR      r1,[r0,#0x2c]
;;;693    			UART0->LINCON.LINRX_EN	= 1;
000026  6ac1              LDR      r1,[r0,#0x2c]
000028  4321              ORRS     r1,r1,r4
                  |L14.42|
00002a  62c1              STR      r1,[r0,#0x2c]
;;;694    		}
;;;695    	    UART0->LINCON.LINBCNT = U16BCNT;
00002c  6ac1              LDR      r1,[r0,#0x2c]
00002e  0712              LSLS     r2,r2,#28
000030  0909              LSRS     r1,r1,#4
000032  0109              LSLS     r1,r1,#4
000034  0f12              LSRS     r2,r2,#28
000036  4311              ORRS     r1,r1,r2
000038  62c1              STR      r1,[r0,#0x2c]
                  |L14.58|
;;;696    	}
;;;697    
;;;698    }
00003a  bd10              POP      {r4,pc}
                  |L14.60|
00003c  4319              ORRS     r1,r1,r3              ;688
00003e  62c1              STR      r1,[r0,#0x2c]         ;688
000040  6ac1              LDR      r1,[r0,#0x2c]         ;689
000042  43a1              BICS     r1,r1,r4              ;689
000044  e7f1              B        |L14.42|
;;;699    
                          ENDP

000046  0000              DCW      0x0000
                  |L14.72|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Read||, CODE, READONLY, ALIGN=2

                  DrvUART_Read PROC
;;;566    /*---------------------------------------------------------------------------------------------------------*/
;;;567    int32_t DrvUART_Read(UART_PORT	u16Port,uint8_t	*pu8RxBuf, uint32_t	u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;568    {
;;;569        uint32_t  u32Count, u32delayno;
;;;570    
;;;571    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d112              BNE      |L15.44|
;;;572    	{
;;;573    	    for (u32Count=0; u32Count < u32ReadBytes; u32Count++)
;;;574    	    {
;;;575    	    	 u32delayno = 0;
;;;576    	         while (UART0->FSR.RX_EMPTY ==1)					  /* Check RX empty => failed */
000006  4d0a              LDR      r5,|L15.48|
000008  2300              MOVS     r3,#0                 ;573
;;;577    	         {
;;;578    	             u32delayno++;
;;;579    	             if ( u32delayno >= 0x40000000 )
00000a  03ae              LSLS     r6,r5,#14
00000c  e00c              B        |L15.40|
                  |L15.14|
00000e  2000              MOVS     r0,#0                 ;575
000010  e004              B        |L15.28|
                  |L15.18|
000012  1c40              ADDS     r0,r0,#1              ;578
000014  42b0              CMP      r0,r6
000016  d301              BCC      |L15.28|
;;;580    	                return E_DRVUART_ERR_TIMEOUT;
000018  4806              LDR      r0,|L15.52|
;;;581    
;;;582    	         }
;;;583    	         pu8RxBuf[u32Count] = UART0->DATA;					  /* Get Data from UART RX  */
;;;584    	    }
;;;585    	}
;;;586    
;;;587        return E_SUCCESS;
;;;588    
;;;589    }
00001a  bd70              POP      {r4-r6,pc}
                  |L15.28|
00001c  69ac              LDR      r4,[r5,#0x18]         ;576
00001e  0464              LSLS     r4,r4,#17             ;576
000020  d4f7              BMI      |L15.18|
000022  7828              LDRB     r0,[r5,#0]            ;583
000024  54c8              STRB     r0,[r1,r3]            ;583
000026  1c5b              ADDS     r3,r3,#1              ;573
                  |L15.40|
000028  4293              CMP      r3,r2                 ;573
00002a  d3f0              BCC      |L15.14|
                  |L15.44|
00002c  2000              MOVS     r0,#0                 ;587
00002e  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

                  |L15.48|
                          DCD      0x40050000
                  |L15.52|
                          DCD      0xffff9801

                          AREA ||i.DrvUART_SetFIFOTriggerLevel||, CODE, READONLY, ALIGN=2

                  DrvUART_SetFIFOTriggerLevel PROC
;;;499    /*---------------------------------------------------------------------------------------------------------*/
;;;500    void DrvUART_SetFIFOTriggerLevel(UART_PORT	u16Port,uint16_t u16TriggerLevel)
000000  2800              CMP      r0,#0
;;;501    {
;;;502    	if(u16Port == UART_PORT0)
000002  d107              BNE      |L16.20|
;;;503    		UART0->FCR.RFITL = u16TriggerLevel;
000004  4a04              LDR      r2,|L16.24|
000006  6890              LDR      r0,[r2,#8]
000008  23f0              MOVS     r3,#0xf0
00000a  0709              LSLS     r1,r1,#28
00000c  4398              BICS     r0,r0,r3
00000e  0e09              LSRS     r1,r1,#24
000010  4308              ORRS     r0,r0,r1
000012  6090              STR      r0,[r2,#8]
                  |L16.20|
;;;504    
;;;505    }
000014  4770              BX       lr
;;;506    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x40050000

                          AREA ||i.DrvUART_SetPDMA||, CODE, READONLY, ALIGN=2

                  DrvUART_SetPDMA PROC
;;;733    /*---------------------------------------------------------------------------------------------------------*/
;;;734    void DrvUART_SetPDMA(UART_PORT u16Port,uint16_t u16IsEnable)
000000  2800              CMP      r0,#0
;;;735    {
;;;736    
;;;737    	if(u16Port == UART_PORT0)
000002  d112              BNE      |L17.42|
;;;738    	{
;;;739    		UART0->IER.DMA_TX_EN 	= u16IsEnable ?1:0;
000004  4a09              LDR      r2,|L17.44|
000006  2301              MOVS     r3,#1
000008  039b              LSLS     r3,r3,#14
00000a  6850              LDR      r0,[r2,#4]
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L17.20|
000010  4318              ORRS     r0,r0,r3
000012  e000              B        |L17.22|
                  |L17.20|
000014  4398              BICS     r0,r0,r3
                  |L17.22|
000016  6050              STR      r0,[r2,#4]
;;;740    		UART0->IER.DMA_RX_EN	= u16IsEnable ?1:0;
000018  2301              MOVS     r3,#1
00001a  03db              LSLS     r3,r3,#15
00001c  6850              LDR      r0,[r2,#4]
00001e  2900              CMP      r1,#0
000020  d001              BEQ      |L17.38|
000022  4318              ORRS     r0,r0,r3
000024  e000              B        |L17.40|
                  |L17.38|
000026  4398              BICS     r0,r0,r3
                  |L17.40|
000028  6050              STR      r0,[r2,#4]
                  |L17.42|
;;;741    	}
;;;742    	else
;;;743    		return;
;;;744    }
00002a  4770              BX       lr
;;;745    
                          ENDP

                  |L17.44|
                          DCD      0x40050000

                          AREA ||i.DrvUART_SetRTS||, CODE, READONLY, ALIGN=2

                  DrvUART_SetRTS PROC
;;;132    /*---------------------------------------------------------------------------------------------------------*/
;;;133    void DrvUART_SetRTS(UART_PORT u16Port,uint8_t u8Value)
000000  2800              CMP      r0,#0
;;;134    {
;;;135    
;;;136    	if(u16Port == UART_PORT0)
000002  d107              BNE      |L18.20|
;;;137    		UART0->MCR.RTS_SET = u8Value;
000004  4a04              LDR      r2,|L18.24|
000006  6910              LDR      r0,[r2,#0x10]
000008  2302              MOVS     r3,#2
00000a  07c9              LSLS     r1,r1,#31
00000c  4398              BICS     r0,r0,r3
00000e  0f89              LSRS     r1,r1,#30
000010  4308              ORRS     r0,r0,r1
000012  6110              STR      r0,[r2,#0x10]
                  |L18.20|
;;;138    	else
;;;139    		return;
;;;140    }
000014  4770              BX       lr
;;;141    
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      0x40050000

                          AREA ||i.DrvUART_SetRxTimeOut||, CODE, READONLY, ALIGN=2

                  DrvUART_SetRxTimeOut PROC
;;;543    /*---------------------------------------------------------------------------------------------------------*/
;;;544    void DrvUART_SetRxTimeOut(UART_PORT	u16Port, uint8_t u8TimeOut)
000000  2800              CMP      r0,#0
;;;545    {
;;;546    	if(u16Port == UART_PORT0)
000002  d10b              BNE      |L19.28|
;;;547    	{
;;;548    		UART0->TOR.TOIC = u8TimeOut;					/* Set Time out value */
000004  4806              LDR      r0,|L19.32|
000006  6a02              LDR      r2,[r0,#0x20]
000008  0649              LSLS     r1,r1,#25
00000a  09d2              LSRS     r2,r2,#7
00000c  01d2              LSLS     r2,r2,#7
00000e  0e49              LSRS     r1,r1,#25
000010  430a              ORRS     r2,r2,r1
000012  6202              STR      r2,[r0,#0x20]
;;;549    		UART0->IER.TOC_EN =1;							/* Enable Time-out count  */
000014  6841              LDR      r1,[r0,#4]
000016  14c2              ASRS     r2,r0,#19
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
                  |L19.28|
;;;550    	}
;;;551    
;;;552    }
00001c  4770              BX       lr
;;;553    
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      0x40050000

                          AREA ||i.DrvUART_Write||, CODE, READONLY, ALIGN=2

                  DrvUART_Write PROC
;;;605    /*---------------------------------------------------------------------------------------------------------*/
;;;606    int32_t DrvUART_Write(UART_PORT	u16Port,uint8_t	*pu8TxBuf, 	uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;607    {
;;;608        uint32_t  u32Count, u32delayno;
;;;609    
;;;610    	if(u16Port == UART_PORT0)
000002  2800              CMP      r0,#0
000004  d112              BNE      |L20.44|
;;;611    	{
;;;612    	    for (u32Count=0; u32Count<u32WriteBytes; u32Count++)
;;;613    	    {
;;;614    	       u32delayno = 0;
;;;615    		   while (UART0->FSR.TX_EMPTY !=1)							/* Wait Tx empty and Time-out manner */
000006  4d0a              LDR      r5,|L20.48|
000008  2300              MOVS     r3,#0                 ;612
;;;616    	       {
;;;617    	       	    u32delayno++;
;;;618    	       	    if ( u32delayno >= 0x40000000 )
00000a  03ae              LSLS     r6,r5,#14
00000c  e00c              B        |L20.40|
                  |L20.14|
00000e  2000              MOVS     r0,#0                 ;614
000010  e004              B        |L20.28|
                  |L20.18|
000012  1c40              ADDS     r0,r0,#1              ;617
000014  42b0              CMP      r0,r6
000016  d301              BCC      |L20.28|
;;;619    	       	       return E_DRVUART_ERR_TIMEOUT;
000018  4806              LDR      r0,|L20.52|
;;;620    
;;;621    	       }
;;;622    		   UART0->DATA = pu8TxBuf[u32Count];						/* Send UART Data from buffer */
;;;623    	    }
;;;624    	}
;;;625    
;;;626        return E_SUCCESS;
;;;627    
;;;628    
;;;629    }
00001a  bd70              POP      {r4-r6,pc}
                  |L20.28|
00001c  69ac              LDR      r4,[r5,#0x18]         ;615
00001e  0264              LSLS     r4,r4,#9              ;615
000020  d5f7              BPL      |L20.18|
000022  5cc8              LDRB     r0,[r1,r3]            ;622
000024  7028              STRB     r0,[r5,#0]            ;622
000026  1c5b              ADDS     r3,r3,#1              ;612
                  |L20.40|
000028  4293              CMP      r3,r2                 ;612
00002a  d3f0              BCC      |L20.14|
                  |L20.44|
00002c  2000              MOVS     r0,#0                 ;626
00002e  bd70              POP      {r4-r6,pc}
;;;630    
                          ENDP

                  |L20.48|
                          DCD      0x40050000
                  |L20.52|
                          DCD      0xffff9801

                          AREA ||i.DrvUART_kbhit||, CODE, READONLY, ALIGN=2

                  DrvUART_kbhit PROC
;;;709    /*---------------------------------------------------------------------------------------------------------*/
;;;710    int32_t DrvUART_kbhit(void)
000000  4802              LDR      r0,|L21.12|
;;;711    {
;;;712    
;;;713        if(UART0->ISR.RDA_IF ==1)
000002  69c0              LDR      r0,[r0,#0x1c]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L21.10|
;;;714        {
;;;715            return TRUE;
000008  2001              MOVS     r0,#1
                  |L21.10|
;;;716        }
;;;717    
;;;718        return FALSE;
;;;719    }
00000a  4770              BX       lr
;;;720    
                          ENDP

                  |L21.12|
                          DCD      0x40050000

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;31     /*---------------------------------------------------------------------------------------------------------*/
;;;32     void UART02_IRQHandler(void)
000000  4803              LDR      r0,|L22.16|
;;;33     {
;;;34         uint32_t u32uart0IntStatus;
;;;35     
;;;36         u32uart0IntStatus = inpw(&UART0->ISR) ;
000002  69c0              LDR      r0,[r0,#0x1c]
;;;37     
;;;38         if(g_pfnUART0callback != NULL)
000004  4903              LDR      r1,|L22.20|
000006  6809              LDR      r1,[r1,#0]  ; g_pfnUART0callback
000008  2900              CMP      r1,#0
00000a  d000              BEQ      |L22.14|
;;;39     	{
;;;40             g_pfnUART0callback(u32uart0IntStatus);
00000c  4708              BX       r1
                  |L22.14|
;;;41         }
;;;42     
;;;43     }
00000e  4770              BX       lr
;;;44     
                          ENDP

                  |L22.16|
                          DCD      0x40050000
                  |L22.20|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  g_pfnUART0callback
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Src\\Driver\\DrvUART.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_DrvUART_c_9d14be4d____REV16|
#line 112 "..\\..\\..\\..\\CMSIS\\CM0\\CoreSupport\\core_cmInstr.h"
|__asm___9_DrvUART_c_9d14be4d____REV16| PROC
#line 113

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_DrvUART_c_9d14be4d____REVSH|
#line 130
|__asm___9_DrvUART_c_9d14be4d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
